	.Z80
	subttl	common file for basic interpreter
	.sall

conto	set	15 ;character to supress output (usually control-o)
dbltrn	set	0 ;for double precision transcendentals
	if2

	.printx	/extended/


	.printx	/lpt/

	.printx	/cpm disk/


	.printx	/z80/

	.printx	/fast/

	.printx	/5.0 features/

	.printx	/ansi compatible/
	endif

clmwid	set	14 ;make comma columns fourteen characters
datpsc	set	128 ;number of data bytes in disk sector
linln	set	80 ;terminal line length 
lptlen	set	132
buflen	set	255 ;long lines
namlen	set	40 ;maximum length name -- 3 to 127

numlev	set	0*20+19+2*5 ;number of stack levels reserved
					;by an explicit call to getstk

strsiz	set	4

strsiz	set	3
numtmp	set	3 ;number of string temporaries

numtmp	set	10

md.rnd	set	3 ;the mode number for random files
md.sqi	set	1 ;the mode number for sequential input files
					;never written into a file
md.sqo	set	2 ;the mode for sequential output files
					;and program files
cpmwrm	set	0 ;cp/m warm boot addr
cpment	set	cpmwrm+5 ;cp/m bdos call addr
	cseg
trurom	set	0
	page
	title	basic mpu 8080/8085/z80/8086 (5.11)   /bill gates/paul allen
	subttl	version 5.11 -- not many features to go
;
;
;--------- ---- -- ---- ----- --- ---- -----
;copyright 1975 by bill gates and paul allen
;--------- ---- -- ---- ----- --- ---- -----
;
;originally written on the pdp-10 from
;february 9 to  april 9 1975
;
;bill gates wrote a lot of stuff.
;paul allen wrote other stuff and fast code.
;monte davidoff wrote the math package (f4i.mac).
;
;*

	.xlist
	.list

bufofs	set	0
bufofs	set	2 ;must crunch into earlier place for single quote
kbflen	set	buflen+(buflen/4) ;make krunch buffer somewhat
					;larger than source buffer (buf)



					;reader input

start:
jmpini:	JP init ;init is the intialization routine
					;it sets up certain
					;locations deletes functions if
					;desired and
					;changes this to jmp ready
					;warm start for isis

					;of the routine to convert [a,b]
					;to a floating point number in the fac
	dw	frcint ;turn fac into an integer in [h,l]
	dw	makint ;turn [h,l] into a value in the fac
					;set valtyp for integer

	page
	subttl	rom version initalization, and constants
	page
	subttl	dispatch tables, reserved word tables

;define some equivalences in case lptsw & cassw off
cload	set	snerr
csave	set	snerr


; these macro calls define the reswrd values
; and the table dispatch for statements and functions

; statements:
stmdsp:;marks start of statement list
q	set	128
	dw	ends
q	set	q+1
$end	set	q
	dw	for
q	set	q+1
$for	set	q
	dw	next
q	set	q+1
$next	set	q
	dw	datas
q	set	q+1
$data	set	q
	dw	input
q	set	q+1
$input	set	q
	dw	dim
q	set	q+1
$dim	set	q
	dw	read
q	set	q+1
$read	set	q
	dw	let
q	set	q+1
$let	set	q
	dw	goto
q	set	q+1
$goto	set	q
	dw	run
q	set	q+1
$run	set	q
	dw	ifs
q	set	q+1
$if	set	q
	dw	restor
q	set	q+1
$resto	set	q
	dw	gosub
q	set	q+1
$gosub	set	q
	dw	return
q	set	q+1
$retur	set	q
	dw	rem
q	set	q+1
$rem	set	q
	dw	stop
q	set	q+1
$stop	set	q
	dw	print
q	set	q+1
$print	set	q
	dw	clear
q	set	q+1
$clear	set	q
	dw	list
q	set	q+1
$list	set	q
	dw	scrath
q	set	q+1
$new	set	q

; 8k and above statements

	dw	ongoto
q	set	q+1
$on	set	q
	dw	null
q	set	q+1
$null	set	q

	dw	fnwait
q	set	q+1
$wait	set	q
	dw	def
q	set	q+1
$def	set	q
	dw	poke
q	set	q+1
$poke	set	q
	dw	cont
q	set	q+1
$cont	set	q
	dw	csave
q	set	q+1
$csave	set	q
	dw	cload
q	set	q+1
$cload	set	q

	dw	fnout
q	set	q+1
$out	set	q
	dw	lprint
q	set	q+1
$lprin	set	q
	dw	llist
q	set	q+1
$llist	set	q

; len2 and above statements

iogor:;dont allow console if code deleted
	ds	2
q	set	q+1 ;pad the hole
	dw	width
q	set	q+1
$width	set	q
	dw	elses
q	set	q+1
$else	set	q
	dw	ton
q	set	q+1
$tron	set	q
	dw	toff
q	set	q+1
$troff	set	q
	dw	swap
q	set	q+1
$swap	set	q
	dw	erase
q	set	q+1
$erase	set	q
	dw	edit
q	set	q+1
$edit	set	q
	dw	errors
q	set	q+1
$error	set	q
	dw	resume
q	set	q+1
$resum	set	q
	dw	delete
q	set	q+1
$delet	set	q
	dw	auto
q	set	q+1
$auto	set	q
	dw	reseq
q	set	q+1
$renum	set	q

; extended and above

	dw	defstr
q	set	q+1
$defst	set	q
	dw	defint
q	set	q+1
$defin	set	q
	dw	defrea
q	set	q+1
$defsn	set	q
	dw	defdbl
q	set	q+1
$defdb	set	q
	dw	line
q	set	q+1
$line	set	q


;***********
; padding initially set to 10
q	set	q+2
	ds	4
	dw	while
q	set	q+1
$while	set	q
	dw	wend
q	set	q+1
$wend	set	q
	dw	calls
q	set	q+1
$call	set	q
	dw	write
q	set	q+1
$write	set	q
	dw	datas
q	set	q+1
$commo	set	q
	dw	chain
q	set	q+1
$chain	set	q
	dw	option
q	set	q+1
$optio	set	q
	dw	random
q	set	q+1
$rando	set	q

; disk and above

	ds	2
q	set	q+1
	dw	system
q	set	q+1
$syste	set	q
q	set	q+1
	ds	2
	dw	open
q	set	q+1
$open	set	q
	dw	field
q	set	q+1
$field	set	q
	dw	get
q	set	q+1
$get	set	q
	dw	put
q	set	q+1
$put	set	q
	dw	close
q	set	q+1
$close	set	q
	dw	load
q	set	q+1
$load	set	q
	dw	merge
q	set	q+1
$merge	set	q
	dw	files
q	set	q+1
$files	set	q
	dw	name
q	set	q+1
$name	set	q
	dw	kill
q	set	q+1
$kill	set	q
	dw	lset
q	set	q+1
$lset	set	q
	dw	rset
q	set	q+1
$rset	set	q
	dw	save
q	set	q+1
$save	set	q
	dw	reset
q	set	q+1
$reset	set	q
; ncr version ones.

numcmd	set	q-$end+1
; tokens
;**********
;padding initially set to 2 between last disk statement and tokens
;padding set to 1 - feb 4, 1977
q	set	q+1
;q must be set so tokens start at right place


q	set	q+1
$to	set	q
$to	set	q
q	set	q+1
$then	set	q
thentk	set	q
q	set	q+1
$tab	set	q
tabtk	set	q
q	set	q+1
$step	set	q
steptk	set	q

q	set	q+1
$usr	set	q
usrtk	set	q
; 8k functions

q	set	q+1
$fn	set	q
fntk	set	q
q	set	q+1
$spc	set	q
spctk	set	q
q	set	q+1
$not	set	q
nottk	set	q

; len2 tokens

q	set	q+1
$erl	set	q
erltk	set	q
q	set	q+1
$err	set	q
erctk	set	q

; extended tokens

q	set	q+1
$strin	set	q
q	set	q+1
$using	set	q
usintk	set	q
q	set	q+1
$instr	set	q
insrtk	set	q
q	set	q+1
$dummy	set	q
sngqtk	set	q
q	set	q+1
$varpt	set	q

;ncr version tokens

;spcdsk tokens
q	set	q+1
$inkey	set	q
q	set	q-1 ;make sure doesnt interfere with reswrds below
;*********
;padding initially set to 18
q	set	q+18

; operators

q	set	q+1
$dummy	set	q
greatk	set	q
q	set	q+1
$dummy	set	q
equltk	set	q
q	set	q+1
$dummy	set	q
lesstk	set	q
q	set	q+1
$dummy	set	q
plustk	set	q
q	set	q+1
$dummy	set	q
minutk	set	q
q	set	q+1
$dummy	set	q
multk	set	q
q	set	q+1
$dummy	set	q
divtk	set	q


; 8k operators

q	set	q+1
$dummy	set	q
exptk	set	q
q	set	q+1
$and	set	q
q	set	q+1
$or	set	q

; extended operators

q	set	q+1
$xor	set	q
q	set	q+1
$eqv	set	q
q	set	q+1
$imp	set	q
q	set	q+1
$mod	set	q
q	set	q+1
$dummy	set	q
idivtk	set	q
lstopk	set	q+1-plustk

; functions

q	set	128
fundsp:
	dw	left$
q	set	q+1
$left$	set	q
onefun	set	q
	dw	right$
q	set	q+1
$right	set	q
	dw	mid$
q	set	q+1
$mid$	set	q
midtk	set	q
	dw	sgn
q	set	q+1
$sgn	set	q
	dw	vint
q	set	q+1
$int	set	q
	dw	abs
q	set	q+1
$abs	set	q
sqrfix:
	dw	sqr
q	set	q+1
$sqr	set	q
sqrtk	set	q
	dw	rnd
q	set	q+1
$rnd	set	q
sinfix:
	dw	sin
q	set	q+1
$sin	set	q

; 8k functions

	dw	log
q	set	q+1
$log	set	q
	dw	exp
q	set	q+1
$exp	set	q
cosfix:
	dw	cos
q	set	q+1
$cos	set	q
tanfix:
	dw	tan
q	set	q+1
$tan	set	q
atnfix:
	dw	atn
q	set	q+1
$atn	set	q
atntk	set	q
	dw	fre
q	set	q+1
$fre	set	q

	dw	fninp
q	set	q+1
$inp	set	q
	dw	pos
q	set	q+1
$pos	set	q
	dw	len
q	set	q+1
$len	set	q
	dw	str$
q	set	q+1
$str$	set	q
	dw	val
q	set	q+1
$val	set	q
	dw	asc
q	set	q+1
$asc	set	q
	dw	chr$
q	set	q+1
$chr$	set	q
	dw	peek
q	set	q+1
$peek	set	q
	dw	space$
q	set	q+1
$space	set	q
	dw	stro$
q	set	q+1
$oct$	set	q
	dw	strh$
q	set	q+1
$hex$	set	q
	dw	lpos
q	set	q+1
$lpos	set	q
lasnum	set	q

; extended functions

	dw	frcint
q	set	q+1
$cint	set	q
	dw	frcsng
q	set	q+1
$csng	set	q
	dw	frcdbl
q	set	q+1
$cdbl	set	q
	dw	fixer
q	set	q+1
$dummy	set	q
$fix	set	q

;ncr version functions


; disk functions

;**********
;padding initially set to 10
q	set	q+10
	ds	20
	ds	2 ;pad in the hole
q	set	q+1
	dw	cvi
q	set	q+1
$cvi	set	q
	dw	cvs
q	set	q+1
$cvs	set	q
	dw	cvd
q	set	q+1
$cvd	set	q
	ds	2 ;pad in the hole
q	set	q+1
	dw	eof
q	set	q+1
$eof	set	q
	dw	loc
q	set	q+1
$loc	set	q
	dw	lof
q	set	q+1
$lof	set	q
	dw	mki$
q	set	q+1
$mki$	set	q
	dw	mks$
q	set	q+1
$mks$	set	q
	dw	mkd$
q	set	q+1
$mkd$	set	q
					;end disk functions
; spcdsk functions
; the following tables are the alphabetic dispatch table
; followed by the reserved word table itself

alptab:

	dw	atab
	dw	btab
	dw	ctab
	dw	dtab
	dw	etab
	dw	ftab
	dw	gtab
	dw	htab
	dw	itab
	dw	jtab
	dw	ktab
	dw	ltab
	dw	mtab
	dw	ntab
	dw	otab
	dw	ptab
	dw	qtab
	dw	rtab
	dw	stab
	dw	ttab
	dw	utab
	dw	vtab
	dw	wtab
	dw	xtab
	dw	ytab
	dw	ztab


; the following macro is for functions. it doesnt turn the token bit 7 on.

reslst:

atab:
	db	'UT'
	db	'O' or 128
	db	$auto
	db	'N'
	db	'D' or 128
	db	$and
	db	'B'
	db	'S' or 128
	db	$abs-128
	db	'T'
	db	'N' or 128
	db	$atn-128
	db	'S'
	db	'C' or 128
	db	$asc-128
	db	0

btab:
	db	0

ctab:
	db	'LOS'
	db	'E' or 128
	db	$close
	db	'ON'
	db	'T' or 128
	db	$cont
	db	'LEA'
	db	'R' or 128
	db	$clear
	db	'IN'
	db	'T' or 128
	db	$cint-128
	db	'SN'
	db	'G' or 128
	db	$csng-128
	db	'DB'
	db	'L' or 128
	db	$cdbl-128
	db	'V'
	db	'I' or 128
	db	$cvi-128
	db	'V'
	db	'S' or 128
	db	$cvs-128
	db	'V'
	db	'D' or 128
	db	$cvd-128
	db	'O'
	db	'S' or 128
	db	$cos-128
	db	'HR'
	db	'$' or 128
	db	$chr$-128
	db	'AL'
	db	'L' or 128
	db	$call
	db	'OMMO'
	db	'N' or 128
	db	$commo
	db	'HAI'
	db	'N' or 128
	db	$chain
	db	0

dtab:

	db	'ELET'
	db	'E' or 128
	db	$delet
	db	'AT'
	db	'A' or 128
	db	$data
	db	'I'
	db	'M' or 128
	db	$dim
	db	'EFST'
	db	'R' or 128
	db	$defst
	db	'EFIN'
	db	'T' or 128
	db	$defin
	db	'EFSN'
	db	'G' or 128
	db	$defsn
	db	'EFDB'
	db	'L' or 128
	db	$defdb
	db	'E'
	db	'F' or 128
	db	$def


	db	0

etab:
	db	'LS'
	db	'E' or 128
	db	$else
	db	'N'
	db	'D' or 128
	db	$end
	db	'RAS'
	db	'E' or 128
	db	$erase
	db	'DI'
	db	'T' or 128
	db	$edit
	db	'RRO'
	db	'R' or 128
	db	$error
	db	'R'
	db	'L' or 128
	db	$erl
	db	'R'
	db	'R' or 128
	db	$err
	db	'X'
	db	'P' or 128
	db	$exp-128
	db	'O'
	db	'F' or 128
	db	$eof-128
	db	'Q'
	db	'V' or 128
	db	$eqv
	db	0

ftab:
	db	'O'
	db	'R' or 128
	db	$for
	db	'IEL'
	db	'D' or 128
	db	$field
	db	'ILE'
	db	'S' or 128
	db	$files
	db	''
	db	'N' or 128
	db	$fn
	db	'R'
	db	'E' or 128
	db	$fre-128
	db	'I'
	db	'X' or 128
	db	$fix-128



	db	0

gtab:
	db	'OT'
	db	'O' or 128
	db	$goto
	db	'O'
	db	' '
	db	'T'
	db	'O'+128
	db	$goto
	db	'OSU'
	db	'B' or 128
	db	$gosub
	db	'E'
	db	'T' or 128
	db	$get
	db	0

htab:
	db	'EX'
	db	'$' or 128
	db	$hex$-128
	db	0

itab:
	db	'NPU'
	db	'T' or 128
	db	$input
	db	''
	db	'F' or 128
	db	$if
	db	'NST'
	db	'R' or 128
	db	$instr
	db	'N'
	db	'T' or 128
	db	$int-128
	db	'N'
	db	'P' or 128
	db	$inp-128
	db	'M'
	db	'P' or 128
	db	$imp
	db	'NKEY'
	db	'$' or 128
	db	$inkey
	db	0

jtab:
	db	0

ktab:
	db	'IL'
	db	'L' or 128
	db	$kill
	db	0

ltab:
	db	'PRIN'
	db	'T' or 128
	db	$lprin
	db	'LIS'
	db	'T' or 128
	db	$llist
	db	'PO'
	db	'S' or 128
	db	$lpos-128
	db	'E'
	db	'T' or 128
	db	$let
	db	'IN'
	db	'E' or 128
	db	$line
	db	'OA'
	db	'D' or 128
	db	$load
	db	'SE'
	db	'T' or 128
	db	$lset
	db	'IS'
	db	'T' or 128
	db	$list
	db	'O'
	db	'G' or 128
	db	$log-128
	db	'O'
	db	'C' or 128
	db	$loc-128
	db	'E'
	db	'N' or 128
	db	$len-128
	db	'EFT'
	db	'$' or 128
	db	$left$-128
	db	'O'
	db	'F' or 128
	db	$lof-128
	db	0

mtab:
	db	'ERG'
	db	'E' or 128
	db	$merge
	db	'O'
	db	'D' or 128
	db	$mod
	db	'KI'
	db	'$' or 128
	db	$mki$-128
	db	'KS'
	db	'$' or 128
	db	$mks$-128
	db	'KD'
	db	'$' or 128
	db	$mkd$-128
	db	'ID'
	db	'$' or 128
	db	$mid$-128
	db	0

ntab:
	db	'EX'
	db	'T' or 128
	db	$next
	db	'UL'
	db	'L' or 128
	db	$null
	db	'AM'
	db	'E' or 128
	db	$name
	db	'E'
	db	'W' or 128
	db	$new
	db	'O'
	db	'T' or 128
	db	$not
	db	0

otab:
	db	'PE'
	db	'N' or 128
	db	$open
	db	'U'
	db	'T' or 128
	db	$out
	db	''
	db	'N' or 128
	db	$on
	db	''
	db	'R' or 128
	db	$or
	db	'CT'
	db	'$' or 128
	db	$oct$-128

	db	'PTIO'
	db	'N' or 128
	db	$optio

	db	0

ptab:
	db	'RIN'
	db	'T' or 128
	db	$print
	db	'U'
	db	'T' or 128
	db	$put
	db	'OK'
	db	'E' or 128
	db	$poke
	db	'O'
	db	'S' or 128
	db	$pos-128
	db	'EE'
	db	'K' or 128
	db	$peek-128
	db	0
qtab:
	db	0

rtab:
	db	'ETUR'
	db	'N' or 128
	db	$retur
	db	'EA'
	db	'D' or 128
	db	$read
	db	'U'
	db	'N' or 128
	db	$run
	db	'ESTOR'
	db	'E' or 128
	db	$resto
	db	'E'
	db	'M' or 128
	db	$rem
	db	'ESUM'
	db	'E' or 128
	db	$resum
	db	'SE'
	db	'T' or 128
	db	$rset
	db	'IGHT'
	db	'$' or 128
	db	$right-128
	db	'N'
	db	'D' or 128
	db	$rnd-128
	db	'ENU'
	db	'M' or 128
	db	$renum
	db	'ESE'
	db	'T' or 128
	db	$reset
	db	'ANDOMIZ'
	db	'E' or 128
	db	$rando
	db	0

stab:
	db	'TO'
	db	'P' or 128
	db	$stop
	db	'WA'
	db	'P' or 128
	db	$swap
	db	'AV'
	db	'E' or 128
	db	$save
	db	'P'
	db	'C'
	db	'('+128
	db	spctk
	db	'TE'
	db	'P' or 128
	db	$step
	db	'G'
	db	'N' or 128
	db	$sgn-128
	db	'Q'
	db	'R' or 128
	db	$sqr-128
	db	'I'
	db	'N' or 128
	db	$sin-128
	db	'TR'
	db	'$' or 128
	db	$str$-128
	db	'TRING'
	db	'$' or 128
	db	$strin
	db	'PACE'
	db	'$' or 128
	db	$space-128

	db	'YSTE'
	db	'M' or 128
	db	$syste
	db	0

ttab:
	db	'HE'
	db	'N' or 128
	db	$then
	db	'RO'
	db	'N' or 128
	db	$tron
	db	'ROF'
	db	'F' or 128
	db	$troff
	db	'A'
	db	'B'
	db	'('+128
	db	tabtk
	db	''
	db	'O' or 128
	db	$to
	db	'A'
	db	'N' or 128
	db	$tan-128
	db	0

utab:
	db	'SIN'
	db	'G' or 128
	db	$using
	db	'S'
	db	'R' or 128
	db	$usr
	db	0

vtab:
	db	'A'
	db	'L' or 128
	db	$val-128
	db	'ARPT'
	db	'R' or 128
	db	$varpt
	db	0

wtab:
	db	'IDT'
	db	'H' or 128
	db	$width
	db	'AI'
	db	'T' or 128
	db	$wait
	db	'HIL'
	db	'E' or 128
	db	$while
	db	'EN'
	db	'D' or 128
	db	$wend
	db	'RIT'
	db	'E' or 128
	db	$write
	db	0

xtab:
	db	'O'
	db	'R' or 128
	db	$xor
	db	0
ytab:
	db	0
ztab:
	db	0

spctab:
	db	'+'+128
	db	plustk
	db	'-'+128
	db	minutk
	db	'*'+128
	db	multk
	db	'/'+128
	db	divtk
	db	'^'+128
	db	exptk
	db	'\'+128
	db	idivtk
	db	''''+128
	db	sngqtk
	db	62+128
	db	greatk
	db	'='+128
	db	equltk
	db	60+128
	db	lesstk
	db	0

optab:	db	121 ;operator table contains
					;precedence followed by
					;the routine address
	db	121
	db	124
	db	124
	db	127
	db	80
	db	70
	db	60 ;precedence of "XOR"
	db	50 ;precedence of "EQV"
	db	40 ;precedence of "IMP"
	db	122 ;precedence of "MOD"
	db	123 ;precedence of "IDIV"

;
; used by assignment code to force the right hand value
; to correspond to the value type of the variable being
; assigned to.
;
frctbl:	dw	frcdbl
	ds	2
	dw	frcint
	dw	chkstr
	dw	frcsng
;
; these tables are used after the decision has been made
; to apply an operator and all the necessary conversion has
; been done to match the two argument types (applop)
;
dbldsp:	dw	dadd ;double precision routines
	dw	dsub
	dw	dmult
	dw	ddiv
	dw	dcomp
opcnt	set	(($-dbldsp)/2)-1
sngdsp:	dw	fadd ;single precision routines
	dw	fsub
	dw	fmult
	dw	fdiv
	dw	fcomp
intdsp:	dw	iadd ;integer routines
	dw	isub
	dw	imult
	dw	intdiv
	dw	icomp
	page
	subttl	error message table

q	set	-2

errtab:
	db	0
q	set	0
q	set	q+1
	db	'NEXT without FOR',0
errnf	set	q
q	set	q+1
	db	'Syntax error',0
errsn	set	q
q	set	q+1
	db	'RETURN without GOSUB',0
errrg	set	q
q	set	q+1
	db	'Out of DATA',0
errod	set	q
q	set	q+1
	db	'Illegal function call',0
errfc	set	q
ovrmsg:
q	set	q+1
	db	'Overflow',0
errov	set	q
q	set	q+1
	db	'Out of memory',0
errom	set	q
q	set	q+1
	db	'Undefined line number',0
errus	set	q
q	set	q+1
	db	'Subscript out of range',0
errbs	set	q
q	set	q+1
	db	'Duplicate Definition',0
errdd	set	q
divmsg:
q	set	q+1
	db	'Division by zero',0
errdv0	set	q
q	set	q+1
	db	'Illegal direct',0
errid	set	q
q	set	q+1
	db	'Type mismatch',0
errtm	set	q
q	set	q+1
	db	'Out of string space',0
errso	set	q
q	set	q+1
	db	'String too long',0
errls	set	q
q	set	q+1
	db	'String formula too complex',0
errst	set	q
q	set	q+1
	db	'Can''t continue',0
errcn	set	q
q	set	q+1
	db	'Undefined user function',0
erruf	set	q
q	set	q+1
	db	'No RESUME',0
errnr	set	q
q	set	q+1
	db	'RESUME without error',0
errre	set	q
q	set	q+1
	db	'Unprintable error',0
errue	set	q
q	set	q+1
	db	'Missing operand',0
errmo	set	q
q	set	q+1
	db	'Line buffer overflow',0
errlbo	set	q

q	set	q+1
	db	'?',0
q	set	q+1
	db	'?',0
q	set	q+1
	db	'FOR Without NEXT',0
errfn	set	q
q	set	q+1
	db	'?',0
q	set	q+1
	db	'?',0
q	set	q+1
	db	'WHILE without WEND',0
errwh	set	q
q	set	q+1
	db	'WEND without WHILE',0
errwe	set	q
nondsk	set	q ;last non disk error.

q	set	49 ;disk errors start at 50.
dskerr	set	q ;first disk error
q	set	q+1
	db	'FIELD overflow',0
errfov	set	q
q	set	q+1
	db	'Internal error',0
errier	set	q
q	set	q+1
	db	'Bad file number',0
errbfn	set	q
q	set	q+1
	db	'File not found',0
errfnf	set	q
q	set	q+1
	db	'Bad file mode',0
errbfm	set	q
q	set	q+1
	db	'File already open',0
errfao	set	q
q	set	q+1
	db	'?',0 ;pad in hole
dskloc	set	$+6
q	set	q+1
	db	'Disk I/O error',0
errioe	set	q
q	set	q+1
	db	'File already exists',0
errfae	set	q
q	set	q+1
	db	'?',0
q	set	q+1
	db	'?',0 ;pad in hole
q	set	q+1
	db	'Disk full',0
errdfl	set	q
q	set	q+1
	db	'Input past end',0
errrpe	set	q
q	set	q+1
	db	'Bad record number',0
errbrn	set	q
q	set	q+1
	db	'Bad file name',0
errnmf	set	q
q	set	q+1
	db	'?',0
errmmm	set	q
q	set	q+1
	db	'Direct statement in file',0
errfdr	set	q
q	set	q+1
	db	'Too many files',0
errtmf	set	q

lsterr	set	q+1 ;last error used for range checks in len2
	page
	subttl	constants for rom basic i/o, rndx, fdiv, usrgo
	page
	subttl	low segment -- ram -- ie this stuff is not constant
;
; this is the "VOLATILE" storage area and none of it
; can be kept in rom. any constants in this area cannot
; be kept in a rom, but must be loaded in by the 
; program instructions in rom.
;

usrtab:
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr
	dw	fcerr ;set up dispatches
nulcnt:	db	1 ;store here the number of nulls
					;to print after crlf
charc:	db	0 ;iscntc stores eaten char here when not a ^c
errflg:	db	0 ;used to save the error number so edit can be
					;called on "SYNTAX ERROR"
lptlst:	db	0 ;last line printer operation. zero means linefeed
					;non-zero means print command (okia only)
lptpos:	db	0 ;position of lpt print head
prtflg:	db	0 ;whether output goes to lpt
lncmps	set	(((lptlen/clmwid)-1)*clmwid) ;last comma field posit
nlppos:	db	lncmps ;last col # beyond which no more comma fields
lptsiz:	db	lptlen ;default line printer width
linlen:	db	linln ;line length
ncmpos	set	(((linln/clmwid)-1)*clmwid) ;position beyond which there are
					;no more comma fields	
clmlst:	db	ncmpos ;position of last comma column
					;non-zero means send output to lpt
rubsw:	db	0 ;rubout switch =1 inside
					;the processing of a rubout (inlin)
cntofl:	db	0 ;supress output flag
					;non-zero means supress
					;reset by "INPUT",ready and errors
					;complemented by input of ^o
ptrfil:	dw	0 ;pointer to data block of current file
					;used by disk and ncr cassette code

topmem:
	dw	stka3 ;top location to use for the stack
					;initially set up by init
					;according to memory size
					;to allow for 50 bytes of string space.
					;changed by a clear command with
					;an argument.
curlin:	dw	0+65534 ;current line #
					;set to 65534 in pure version during init execution
					;set to 65535 when direct statements execute
txttab:	dw	stk40 ;pointer to beginning of text
					;doesn'T CHANGE AFTER BEING
					;setup by init.
overri:	dw	ovrmsg ;address of message to print (overflow)
					;data segment again
;
;	end of initialized part of ram
;
;
; disk data storage area
;
lstfre:	ds	2 ;free place in directory
maxtrk:	ds	1 ;allocate inside this track
dskmod:	ds	1 ;mode of file just looked up
					;zero if file was just created
filpt1:	ds	2 ;[filptr] always refetched from here
filptr:	ds	32 ;pointers to data blocks for each file
maxfil:	ds	1 ;highest file number allowed
namcnt:	ds	1 ;the number of character beyond #2 in a var name
nambuf:	ds	namlen-2 ;storage for chars beyond #2. used in ptrget
namtmp:	ds	2 ;temp storage during name save at indlop
dirtmp	set	cpmwrm+128 ;use cpm default buffer in low memory
filna2:	ds	16 ;used by name code
filnam:	ds	1 ;5.21: split for filnam+N workaround
filnm1:	ds	8 ;5.21: filnam+1
filnm9:	ds	3 ;5.21: filnam+9
filnm12:	ds	21 ;5.21: filnam+12

;	cp/m 1.4 and 2.x support


cpmvrn:	ds	1 ;cp/m version number (#0 is 2.x)
cpmrea:	ds	1 ;cp/m read call
cpmwri:	ds	1 ;cp/m write call
	db	':' ;a colon for restarting input
kbuf:	ds	kbflen ;this is the krunch buffer
bufmin:	db	44 ;a comma (preload or rom)
					;used by input statement since the
					;data pointer always starts on a
					;comma or terminator
buf:	ds	buflen+1 ;type in stored here
					;direct statements execute out of
					;here. remember "INPUT" smashes buf.
					;must be at a lower address
					;than dsctmp or assignment of string
					;values in direct statements won'T COPY
					;into string space -- which it must
	ds	2 ;allow for single quote in big line
endbuf:	ds	1 ;place to stop big lines
ttypos:	ds	1 ;store terminal position here
dimflg:	ds	1 ;in getting a pointer to a variable
					;it is important to remember whether it
					;is being done for "DIM" or not
					;dimflg and valtyp must be
					;consecutive locations
valtyp:	ds	1 ;the type indicator
					;in the 8k 0=numeric 1=string
oprtyp:;used to store operator number
					;in the extended momentarily before
					;operator application (applop)
dores:	ds	1 ;whether can or can'T CRUNCH RES'd words
					;turned on in the 8k when "DATA"
					;being scanned by crunch so unquoted
					;strings won'T BE CRUNCHED.
donum:	ds	1 ;flag for crunch =0 means
					;numbers allowed, (floating,int, dbl)
					;1 means numbers allowed, krunch by calling linget
					;-1 (377) means numbers disallowed 
					;(scanning variable name)
contxt:	ds	2 ;saved text pointer used by chrget
					;to save the text pointer after constant
					;has been scanned.
consav:	ds	1 ;the saved token for a constant
					;after chrget has been called
contyp:	ds	1 ;saved constant valtype
conlo:	ds	4 ;saved constant value
	ds	4 ;extra four bytes for double precision
memsiz:	ds	2 ;highest location in memory
temppt:	ds	2 ;pointer at first free temp descriptor
					;initialized to point to tempst
tempst:	ds	strsiz*numtmp ;storage for numtmp temp descriptors
dsctmp:	ds	strsiz ;string functions build answer descriptor here
					;must be after tempst and before parm1
dscptr	set	$-2 ;where string address is store in dsctmp
fretop:	ds	2 ;top of string free space
temp3:	ds	2 ;used to store the address of the end of
					;string arrays in garbage collection
					;and used momentarily by frmevl
					;used in extended by fout and
					;user defined functions
					;array variable handling temporary
temp8:	ds	2 ;7/3/79 now used by garbage collection
					;not temp3 due to conflict
endfor:	ds	2 ;saved text pointer at end of "FOR" statement
datlin:	ds	2 ;data line # -- remember for errors
subflg:	ds	1 ;flag whether subscripted variable allowed
					;"FOR" and user-defined function
					;pointer fetching turn
					;this on before calling ptrget
					;so arrays won'T BE DETECTED.
					;stkini and ptrget clear it.
usflg:
flginp:	ds	1 ;flags whether we are doing "INPUT"
					;or a read
temp:	ds	2 ;temporary for statement code
					;newstt saves [h,l] here for input and ^c
					;"LET" saves variable
					;pointers here for "FOR"
					;"NEXT" saves its text pointer here
					;clearc saves [h,l] here
ptrflg:	ds	1 ;=0 if no line numbers converted
					;to pointers, non zero if pointers exist.
autflg:	ds	1 ;flag to inicate auto command in
					;progress =0 if not, non-zero if so.
autlin:	ds	2 ;current line being inserted by auto
autinc:	ds	2 ;the auto increment
savtxt:	ds	2 ;place where newstt saves text pointer
					;for "RESUME" statement
savstk:	ds	2 ;newstt saves stack here before
					;so that error revery can
					;can restore the stack when an
					;error occurs
errlin:	ds	2 ;line number where last error occured.
dot:	ds	2 ;keeps current line for edit & list
errtxt:	ds	2 ;text pointer for use by "RESUME"
onelin:	ds	2 ;the line to goto when an error 
					;occurs
oneflg:	ds	1 ;oneflg=1 if were are executing
					;an error trap routine, otherwise 0
temp2:	ds	2 ;formula evaluator temp
					;must be preserved by operators
					;used in extended by fout and
					;user-defined functions
					;array variable handler temporary
oldlin:	ds	2 ;old line number (setup by ^c,"STOP"
					;or "END" in a program)
oldtxt:	ds	2 ;old text pointer
					;points at statement to be executed next
vartab:	ds	2 ;pointer to start of simple
					;variable space
					;updated whenever the size of the
					;program changes, set to [txttab]
					;by scratch ("NEW").
arytab:	ds	2 ;pointer to beginning of array
					;table
					;incremented by 6 whenever
					;a new simple variable is found, and
					;set to [vartab] by clearc.
strend:	ds	2 ;end of storage in use
					;increased whenever a new array
					;or simple variable is encountered
					;set to [vartab] by clearc.
datptr:	ds	2 ;pointer to data. initialized to point
					;at the zero in front of [txttab]
					;by "RESTORE" which is called by clearc
					;updated by execution of a "READ"
deftbl:	ds	26 ;this gives the default valtyp for each
defta	equ	deftbl-'A' ;5.21: base for type table lookup
					;letter of the alphabet
					;it is set up by "CLEAR" and changed by
					;"DEFSTR" "DEFINT" "DEFSNG" "DEFDBL" and used
					;by ptrget when ! # % or $ don'T FOLLOW
					;a varaible name
;
; ram storage for user defined function parameter information
;
prmsiz	set	100 ;number of bytes for definition block
prmstk:	dw	0 ;previous definition block on stack
					;block (for garbage collection)
prmlen:	ds	2 ;the number of bytes in the active table
parm1:	ds	prmsiz ;the active parameter definition table
prmprv:	ds	2 ;the pointer at the previous parameter
					;block (for garbage collection)
prmln2:	ds	2 ;size of parameter block being built
parm2:	ds	prmsiz ;place to keep parameters being made
prmflg:	ds	1 ;used by ptrget to flag if parm1 has been searched
aryta2:	ds	2 ;stopping point for simple search
					;(either [arytab] or parm1+[prmlen])
nofuns:	ds	1 ;zero if no functions active. saves time in simple search
temp9:	ds	2 ;garbage collection temp to chain through parameter blocks
funact:	ds	2 ;count of active functions
inppas:	ds	1 ;flag telling whether input is scanning first or
					;second time. zero if first.
nxttxt:	ds	2 ;used to save text pointer at start of next
nxtflg:	ds	1 ;zero if "FOR" is using next code
					;to check for empty loop
fvalsv:	ds	4 ;use to store the start value of the loop variable
					;since ansi says start and end are evaluated
					;before assignment takes place
nxtlin:	ds	2 ;the line number during scan for "NEXT"
optval:	ds	1 ;zero for option base 0 one for option base 1
optflg:	ds	1 ;non-zero if "OPTION BASE" has been scanned
patch:	ds	30 ;thirty bytes of patch space
tempa:	ds	2 ;misc temp used by call and list
savfre:	ds	2 ;fretop saved here by chain
maxrec:	ds	2 ;maximum record size
proflg:	ds	1 ;non-zero if we have loaded a protected file w/o passwrd
mrgflg:	ds	1 ;non-zero if chain w/ merge in progress
mdlflg:	ds	1 ;non-zero i chain w/ merge and delete in progress
cmeptr:	ds	2 ;pointer tto end line to delete
cmsptr:	ds	2 ;pointer to start line to delete
chnflg:	ds	1 ;non-zero if chain in progress
chnlin:	ds	2 ;destination line in new program
swptmp:	ds	4 ;value of first "SWAP" variable stored here
	ds	4 ;enough room for double precision
trcflg:	ds	1 ;zero means no trace in progress

; this is the ram termporary area for the math package routines
;
;the floating accumulator
dfacx:	ds	1 ;5.21: extra byte before dfaclo (dfaclo-1)
dfaclo:	ds	4 ;[four lowest orders for double precision]
faclo:	ds	2
facs:	ds	1 ;5.21: sign byte of fac (fac-1)
					;[middle order of mantissa]
					;[high order of mantissa]
fac:	ds	2 ;[exponent]
					;[temporary complement of sign in msb]
flgovc:	ds	1 ;overflow print flag,=0,1 print 
					;further =1 change to 2
ovcstr:	ds	1 ;place to store overflow flag after fin
fansii:	ds	1 ;flag to force fixed output (see ansi)
arglox:	ds	1 ;5.21: extra byte before arglo (arglo-1)
arglo:	ds	6 ;[location of second argument for double
args:	ds	1 ;5.21: sign byte of arg (arg-1)
arg:	ds	1 ; precision]
					;for intel formats must have space for
					;11 bits of exponent
fbuffr:	ds	1 ;buffer for fout
fbufp1:	ds	26 ;5.21: fbuffr+1
fbufp27:	ds	6 ;5.21: fbuffr+27
fbufp33:	ds	1 ;5.21: fbuffr+33
fbufp34:	ds	6 ;5.21: fbuffr+34
fmltt1:	ds	1 ;5.21: fbuffr+40
fmltt2:	ds	2 ;5.21: fbuffr+41 (plus padding to 43)
	page
	subttl	text constants for print out
;
; needed for messages in all versions
;
intxt:	dc	' in '
reddym:	db	0 ;5.21: reddy-1 (null terminator)
reddy:
	dc	'Ok'
	db	13
	db	10
	db	0
brktxt:	dc	'Break'
	db	0

	page
	subttl	general storage management routines - fndfor, bltu, getstk
;
; find a "FOR" entry on the stack with the variable pointer
; passed in [d,e].
;
fndfor:	LD HL,4+0 ;ignoring everyones "NEWSTT"
					;and the return address of this
	ADD HL,SP ;subroutine, set [h,l]=sp
looper:
	LD A,(HL) ;see what type of thing is on the stack
	INC HL
whlsiz	set	6
	CP $while
	JP NZ,stksrc
	LD BC,0+whlsiz
	ADD HL,BC
	JP looper
stksrc:
	CP $for ;is this stack entry a "FOR"?
	RET NZ ;no so ok
	LD C,(HL)
	INC HL ;do equivalent of pushm / xthl
	LD B,(HL)
	INC HL
	PUSH HL ;put h  on
	LD H,B ;push b / xthl is slower
	LD L,C
	LD A,D ;for the "NEXT" statment without an argument
	OR E ;we match on anything
	EX DE,HL ;make sure we return [d,e]
	JP Z,popgof ;pointing to the variable
	EX DE,HL
	CALL dcompr
forsiz	set	13

forsiz	set	14

forsiz	set	forsiz+2
forszc	set	0+forsiz
popgof:	LD BC,forszc ;to wipe out a "FOR" entry
	POP HL
	RET Z ;if variable in this entry matches
					;return with [h,l] pointing the bottom
					;of the entry
	ADD HL,BC
	JP looper ;now pointing to the start of the next
					;entry. see if its a "FOR" entry
					;and if the variable matches
	page
	subttl	error handling
; this routine is called to reset the stack if basic is
; externally stopped and then restarted.
readyr:	LD BC,stprdy ;address go to, also pop off garbage stack entry.
	JP ereset ;reset stack, goto ready.

prgend:	LD HL,(curlin) ;get current line #
	LD A,H ;see if direct
	AND L ;and together
	INC A ;set cc'S
	JP Z,endcnj ;if direct done, allow for debugging purposes
	LD A,(oneflg) ;see if in on error
	OR A ;set cc
	LD E,errnr ;"NO RESUME" error
	JP NZ,error ;yes, forgot resume
endcnj:	JP endcon ;no, let it end
derdfl:	LD E,errdfl
	db	1 ;"DISK FULL"
derioe:	LD E,errioe
	db	1 ;"DISK I/O ERROR"
derbfm:	LD E,errbfm
	db	1 ;"BAD FILE MODE"
derfnf:	LD E,errfnf
	db	1 ;"FILE NOT FOUND"
derbfn:	LD E,errbfn
	db	1 ;"BAD FILE NUMBER"
derier:	LD E,errier
	db	1 ;"INTERNAL ERROR"
derrpe:	LD E,errrpe
	db	1 ;"READ PAST END"
derfao:	LD E,errfao
	db	1 ;"FILE ALREADY OPEN"
dernmf:	LD E,errnmf
	db	1 ;"BAD FILE NAME"
derbrn:	LD E,errbrn
	db	1 ;"BAD RECORD NUMBER"
derfov:	LD E,errfov
	db	1 ;"FIELD OVERFLOW"
dertmf:	LD E,errtmf
	db	1 ;"TOO MANY FILES"
derfae:	LD E,errfae
	db	1 ;"FILE ALREADY EXISTS"
	org	$-1
	JP error
datsne:	LD HL,(datlin) ;get data line
	LD (curlin),HL ;make it current line
snerr:	LD E,errsn ;"SYNTAX ERROR"
	db	1q ;"LXI B," over the next 2
dv0err:	LD E,errdv0 ;division by zero
	db	1q ;"LXI B," over the next 2
nferr:	LD E,errnf ;"NEXT WITHOUT FOR" error
	db	1q ;"LXI B," over the next two bytes
dderr:	LD E,errdd ;"REDIMENSIONED VARIABLE"
	db	1q ;"LXI B," over the next 2 bytes
uferr:	LD E,erruf ;"UNDEFINED FUNCTION" error
	db	1q ;"LXI B," over the next two
reerr:	LD E,errre ;"RESUME WITHOUT ERROR"
	db	1q ;"LXI B," over the next two
overr:	LD E,errov ;set overflow error code
	db	1q ;"LXI B," over next two
moerr:	LD E,errmo ;type mismatch error
	db	1q ;"LXI	B," over the next two
tmerr:	LD E,errtm ;type mismatch error
error:
	LD HL,(curlin) ;get current line number
	LD (errlin),HL ;save it for erl variable
	XOR A ;clear chain flag in case of error
	LD (mrgflg),A ;also merge flag
	LD (chnflg),A ;so it doesnt try to chain
	LD A,H ;only set up dot if it isnt direct
	AND L
	INC A
	JP Z,erresm
	LD (dot),HL ;save it for edit or list
erresm:	LD BC,errmor ;get return address in [b,c]
ereset:	LD HL,(savstk) ;get a good stack back
	JP stkerr ;jump into stkini
errmor:	POP BC ;pop off fndfor stopper
	LD A,E ;[a]=error number
	LD C,E ;also save it for later restore
	LD (errflg),A ;save it so we know whether to call "EDIT"
	LD HL,(savtxt) ;get saved text pointer
	LD (errtxt),HL ;save for resume.
	EX DE,HL ;save savtxt ptr
	LD HL,(errlin) ;get error line #
	LD A,H ;test if direct line
	AND L ;set cc'S
	INC A ;sets zero if direct line (65535)
	JP Z,ntmdcn ;if direct, dont modify oldtxt & oldlin
	LD (oldlin),HL ;set oldlin=errlin.
	EX DE,HL ;get back savtxt
	LD (oldtxt),HL ;save in oldtxt.
ntmdcn:	LD HL,(onelin) ;see if we are trapping errors.
	LD A,H ;by checking for line zero.
	OR L ;is it?
	EX DE,HL ;put line to go to in [d,e]
	LD HL,oneflg ;point to error flag
	JP Z,notrap ;sorry, no trapping...
	AND (HL) ;a is non-zero, setzero if oneflg zero
	JP NZ,notrap ;if flag already set, force error
	DEC (HL) ;if already in error routine, force error
	EX DE,HL ;get line pointer in [h,l]
	JP gone4 ;go directly to newstt code
notrap:	XOR A ;a must be zero for contro
	LD (HL),A ;reset oneflg
	LD E,C ;get back error code
	LD (cntofl),A ;force output
	CALL crdonz ;crlf
	LD HL,errtab ;get start of error table
	LD A,E ;get error code
	CP lsterr ;is it past last error?
	JP NC,uperr ;yes, too big to print
	CP dskerr+1 ;disk error?
	JP NC,ntder2 ;yes
	CP nondsk+1 ;is it between last normal & first disk?
	JP C,ntderr ;yes, ok to print it
uperr:	LD A,errue+dskerr-nondsk ;print "UNPRINTABLE ERROR"
ntder2:	SUB dskerr-nondsk ;fix offset into table of messages
	LD E,A ;save back error code
ntderr:
					;on "SYNTAX ERROR"s
lepskp:	CALL rem ;skip an error message
	INC HL ;skip over this error message
	DEC E ;decrement error count
	JP NZ,lepskp ;skip some more
	PUSH HL ;save text pointer
	LD HL,(errlin) ;get error line number
	EX (SP),HL ;get back error text pointer
errfin:
	LD A,(HL) ;get 1st char of error
	CP '?' ;padded error?
	JP NZ,errfn1 ;no,print
	POP HL ;get line # off stack
	LD HL,errtab
	JP uperr ;make unprintable error

errfn1:
	CALL strout ;print message
	POP HL ;restore line number
	LD DE,0+65534 ;is init executing?
	CALL dcompr
	CALL Z,crdo ;do crlf
	JP Z,systme ;system error exit
					;exit to os
					;if so, restart it
	LD A,H ;see if in direct mode
	AND L
	INC A ;zero says direct mode
	CALL NZ,inprt ;print line number in [h,l]
; now fall into main interpreter loop
	page
	subttl	stprdy, ready, main, chead
;
; for "LIST" command stopping
; and for returning from a failed "CVER"
; and to correct a direct gosub which does input
;
	db	76q ;skip the next byte with "MVI A,0"
stprdy:	POP BC
ready:
	CALL finlpt ;print any left overs
	XOR A
	LD (cntofl),A ;force output
	CALL prgfin ;finish output of a file
	CALL crdonz ;if not already at left, send crlf
	LD HL,reddy ;"OK" crlf crlf
repini:
					;by the init code. this is here so after
					;errors during init, init is restarted
	CALL cpmwrm ;errors in cp/m initialization, return to cp/m
	LD A,(errflg) ;see if it was a "SYNTAX ERROR"
	SUB errsn
	CALL Z,erredt ;"EDIT" the bad line
main:	LD HL,0+65535
	LD (curlin),HL ;setup curlin for direct mode
	LD A,(autflg) ;in an auto command?
	OR A ;set cc'S
	JP Z,ntauto ;no, reuglar mode
	LD HL,(autlin) ;get current auto line
	PUSH HL ;save away for later use
	CALL linprt ;print the line #
	POP DE ;get it back
	PUSH DE ;save back again
	CALL fndlin ;see if it exists
	LD A,'*' ;char to print if line already exists
	JP C,auteln ;doesnt exist
	LD A,' ' ;print space
auteln:	CALL outdo ;print char
	CALL inlin ;read a line
	POP DE ;get line # off stack
	JP NC,autgod ;if no control-c, proceed
	XOR A ;clear autflg
	LD (autflg),A ;by setting it to zero
	JP ready ;print ready message

autres:	XOR A
	LD (autflg),A ;clear auto flag
	JP autstr ;and enter line

autgod:	LD HL,(autinc) ;get increment
	ADD HL,DE ;add increment to this line
	JP C,autres ;check for pathetic case
	PUSH DE ;save line number #
	LD DE,0+65529 ;check for line # too big
	CALL dcompr
	POP DE ;get back line #
	JP NC,autres ;if too big, quit
	LD (autlin),HL ;save in next line
autstr:
					;set non-zero condition codes (see edit)
	LD A,(buf) ;get char from buffer
	OR A ;is it null line?
	JP Z,main ;yes, leave line alone
	JP editrt ;jump into edit code
ntauto:
	CALL inlin ;get a line from tty
	JP C,main ;ignore ^c s
	CALL chrgtr ;get the first
	INC A ;see if 0 saving the carry flag
	DEC A
	JP Z,main ;if so, a blank line was input
	PUSH AF ;save status indicator for 1st character
	CALL linget ;read in a line #
	CALL baksp ;back up the pointer
	LD A,(HL) ;get the char
	CP ' ' ;character a space?
	CALL Z,inxhrt ;then eat past it
					;one space always printed after line #
edent:	PUSH DE ;save line #
	CALL crunch ;crunch the line down
	POP DE ;restore line #
	POP AF ;was there a line #?
	LD (savtxt),HL ;for resuming a direct stmt
					;restore text pointer
	JP NC,dirdo ;make sure we'RE NOT READING A FILE
	PUSH DE
	PUSH BC ;save line # and character count
	CALL prochk ;dont allow any funny business with existing pgm
	CALL chrgtr ;remember if this line is
	OR A ;set the zero flag on zero
					;lines that start with ":" should not be
					;ignored
	PUSH AF ;blank so we don'T INSERT IT
	EX DE,HL ;save this line # in dot
	LD (dot),HL
	EX DE,HL
	CALL fndlin ;get a pointer to the line
	JP C,lexist ;line exists, delete it
	POP AF ;get flag says whether line blank
	PUSH AF ;save back
	JP Z,userr ;trying to delete non-existant line, error
	OR A ;clear flag that says line exists
lexist:	PUSH BC ;save the pointer
	PUSH AF ;save registers
	PUSH HL ;save [h,l]
	CALL deptr ;get rid of ptrs in pgm
	POP HL ;get back pointer to next line
	POP AF ;get back psw
	POP BC ;restore pointer to this line
	PUSH BC ;save back again
	CALL C,del ;delete the line
nodel:	POP DE ;pop pointer at place to insert
	POP AF ;see if this line had
					;anything on it
	PUSH DE ;save place to start fixing links
	JP Z,fini ;if not don'T INSERT
	POP DE ;get rid of start of link fix
	LD A,(chnflg) ;only changet fretop if not chaining
	OR A
	JP NZ,levfre ;leave fretop alone
	LD HL,(memsiz) ;delete all strings
	LD (fretop),HL ;so reason doesnt use them
levfre:
	LD HL,(vartab) ;current end
	EX (SP),HL ;[h,l]=character count. vartab
					;onto the stack
	POP BC ;[b,c]=old vartab
	PUSH HL ;save count of chars to move
	ADD HL,BC
	PUSH HL ;save new vartab
	CALL bltu
	POP HL ;pop off vartab
	LD (vartab),HL ;update vartab
	EX DE,HL
	LD (HL),H ;fool chead with non-zero link
	POP BC ;restore count of chars to move
	POP DE ;get line # off stack
	PUSH HL ;save start of place to fix links
	INC HL ;so it doesn'T THINK
					;this link is the
					;end of the program
	INC HL
	LD (HL),E
	INC HL ;put down line #
	LD (HL),D
	INC HL
	LD DE,kbuf ;move line frm kbuf to program area
	DEC BC ;fix up count of chars to move
	DEC BC ;(dont include line # & link)
	DEC BC ;
	DEC BC
mloopr:	LD A,(DE) ;now transfering line
					;in from buf
	LD (HL),A
	INC HL
	INC DE
	DEC BC ;decrement char count by 1
	LD A,C ;test for count exhausted
	OR B ;by seeing if [b,c]=0
	JP NZ,mloopr
fini:
	POP DE ;get start of link fixing area
	CALL chead ;fix links
	LD HL,dirtmp ;don'T ALLOW ZERO TO BE CLOSED
	LD (HL),0 ;not sequential output
	LD (filptr),HL
	LD HL,(ptrfil) ;get file pointer, could be zero
	LD (temp2),HL ;save it
	CALL runc ;do clear & set up stack 
	LD HL,(filpt1) ;reset [filptr]
	LD (filptr),HL
	LD HL,(temp2) ;reset [ptrfil]
	LD (ptrfil),HL
	JP main ;go to main code
linker:
	LD HL,(txttab)
	EX DE,HL
;
; chead goes through program storage and fixes
; up all the links. the end of each
; line is found by searching for the zero at the end.
; the double zero link is used to detect the end of the program
;
chead:	LD H,D ;[h,l]=[d,e]
	LD L,E
	LD A,(HL) ;see if end of chain
	INC HL ;bump pointer
	OR (HL) ;2nd byte

	RET Z
	INC HL ;fix h to start of text
	INC HL
czloop:	INC HL ;bump pointer
	LD A,(HL) ;get byte
czloo2:	OR A ;set cc'S
	JP Z,czlin ;end of line, done.
	CP dblcon+1 ;embedded constant?
	JP NC,czloop ;no, get next
	CP 11 ;is it linefeed or below?
	JP C,czloop ;then skip past
	CALL chrgt2 ;get constant
	CALL chrgtr ;get over it
	JP czloo2 ;go back for more
czlin:	INC HL ;make [h,l] point after text
	EX DE,HL ;switch temp
	LD (HL),E ;do first byte of fixup
	INC HL ;advance pointer
	LD (HL),D ;2nd byte of fixup
	JP chead ;keep chaining til done
	page
	subttl	scnlin, fndlin - scan line range and find line # in program
;
; scnlin scans a line range of
; the form  #-# or # or #- or -# or blank
; and then finds the first line in the range
;
scnlin:	LD DE,0 ;assume start list at zero
	PUSH DE ;save initial assumption
	JP Z,alllst ;if finished, list it all
	POP DE ;we are going to grab a #
	CALL linspc ;get a line #. if none, returns zero
	PUSH DE ;save first
	JP Z,snglin ;if only # then done.
	CALL synchr
	db	minutk ;must be a dash.
alllst:	LD DE,0+65530 ;assume max end of range
	CALL NZ,linspc ;get the end of range
	JP NZ,snerr ;must be terminator
snglin:	EX DE,HL ;[h,l] = final
	POP DE ;get initial in [d,e]
fndln1:	EX (SP),HL ;put max on stack, return addr to [h,l]
	PUSH HL ;save return address back
;
; fndlin searches the program text for the line
; whose line # is passed in [d,e]. [d,e] is preserved.
; there are three possible returns:
;
;	1) zero flag set. carry not set.  line not found.
;	   no line in program greater than one sought.
;	   [b,c] points to two zero bytes at end of program.
;	   [h,l]=[b,c]
;
;	2) zero, carry set. 
;	   [b,c] points to the link field in the line
;	   which is the line searched for.
;	   [h,l] points to the link field in the next line.
;
;	3) non-zero, carry not set.
;	   line not found, [b,c]  points to line in program
;	   greater than one searched for.
;	   [h,l] points to the link field in the next line.
;
fndlin:
	LD HL,(txttab) ;get pointer to start of text
loop:
	LD B,H ;if exiting because of end of program,
					;set [b,c] to point to double zeroes.
	LD C,L
	LD A,(HL) ;get word pointer to
	INC HL ;bump pointer
	OR (HL) ;get 2nd byte
	DEC HL ;go back
	RET Z ;if zero then done
	INC HL ;skip past and get the line #
	INC HL
	LD A,(HL) ;into [h,l] for comparison with
	INC HL ;the line # being searched for
	LD H,(HL) ;which is in [d,e]
	LD L,A
	CALL dcompr ;see if it matches or if we'VE GONE TOO FAR
	LD H,B ;make [h,l] point to the start of the
	LD L,C ;line beyond this one, by picking
	LD A,(HL) ;up the link that [b,c] points at
	INC HL
	LD H,(HL)
	LD L,A
	CCF ;turn carry on
	RET Z ;equal return
	CCF ;make carry zero
	RET NC ;no match return (greater)
	JP loop ;keep looping
	page
	subttl	pre fast crunch - compactification
	page
	page
	subttl	fast crunch - compactification
;
; all "RESERVED" words are translated into single
; one or two (if two, first is always 377 octal)
; bytes with the msb on. this saves space and time
; by allowing for table dispatch during execution.
; therefore all statements appear together in the
; reserved word list in the same
; order they appear in in stmdsp.
;
; numeric constants are also converted to their internal
; binary representation to improve execution speed
; line numbers are also preceeded by a special token
; so that line numbers can be converted to pointers at execution
; time.
crunch:	XOR A ;say expecting floating numbers
	LD (donum),A ;set flag acordingly
	LD (dores),A ;allow crunching
	LD BC,0+kbflen-3 ;get length of krunch buffer
					;minus three because of zeros at end
	LD DE,kbuf ;setup destination pointer
kloop:	LD A,(HL) ;get character from buf
	OR A ;5.21: check end of line FIRST
	JP NZ,kloop2 ;not end, continue checking
crdone:;5.21: crdone code inline here
	LD HL,0+kbflen+2 ;get offset
	LD A,L ;get count to subtract from
	SUB C ;subtract
	LD C,A
	LD A,H
	SBC B
	LD B,A
	LD HL,kbuf-1 ;get pointer to char before kbuf
	XOR A ;get a zero
	LD (DE),A ;need three 0'S ON THE END
	INC DE
	LD (DE),A
	INC DE
	LD (DE),A
	RET ;end of crunching
kloop2:;continue checking
	CP 34 ;quote sign? 
	JP Z,strng ;yes, go to special string handling
	CP ' ' ;space?
	JP Z,kstuff ;5.21: space goes to inline stuff
	LD A,(dores) ;in data statement and no crunch?
	OR A
	LD A,(HL) ;get the character again
	JP Z,kcont ;5.21: if NOT in DATA, continue crunching
					;fall through when IN DATA statement
kstuff:	INC HL ;advance text pointer
	PUSH AF ;save character
	CALL krnsav ;store char in krunch buffer
	POP AF ;restore character
	SUB ':' ;was it colon?
	JP Z,ksetfl ;yes, go clear DATA flags
	CP $data-':' ;check for DATA token
	JP NZ,kchknd ;no
	LD A,1 ;set DATA flag value
ksetfl:	LD (dores),A ;store to dores
	LD (donum),A ;store to donum
kchknd:	SUB $rem-':' ;check for REM token
	JP NZ,kloop ;not REM, loop back
	PUSH AF ;5.21: push terminator (0) for REM string
str1:	LD A,(HL) ;get a char
	OR A ;set condition codes
	EX (SP),HL ;get saved terminator off stack, save [h,l]
	LD A,H ;get terminator into [a] without affecting psw
	POP HL ;restore [h,l]
	JP Z,crdone ;if end of line then done
	CP (HL) ;compare char with this terminator
	JP Z,kstuff ;5.21: string done goes to kstuff
strng:
	PUSH AF ;save terminator
	LD A,(HL) ;get back line char
strng2:	INC HL ;increment text pointer
	CALL krnsav ;save char in krunch buffer
	JP str1 ;keep looping

kcont:	CP '?' ;a qmark?
	LD A,$print
	PUSH DE ;save store pointer
	PUSH BC ;save char count
	JP Z,notfn2 ;then use a "PRINT" token
					;***5.11 dont allow following line #***
	LD DE,spctab ;assume we'LL SEARCH SPECIAL CHAR TABLE
	CALL makupl ;translate this char to upper case
	CALL islet2 ;letter?
	JP C,tstnum ;not a letter, test for number
	PUSH HL ;save text pointer
	LD DE,gostr ;point to "GO " string
	CALL gostrcm ;compare string
	JP NZ,notgos ;no match
	CALL chrgtr ;skip past match, get next char
	LD DE,tostr ;"TO"
	CALL gostrcm
	LD A,$goto
	JP Z,gputrs ;matched GOTO
	LD DE,ubstr ;"UB"
	CALL gostrcm
	JP NZ,notgos ;neither TO nor UB
gputrs:	LD A,$gosub
	POP BC ;discard saved text ptr
	JP notfn2 ;store the token
;
; string compare subroutine for GO parsing
;
gostrcm:	LD A,(DE) ;get string char
	OR A ;null terminator?
	RET Z ;yes, match succeeded
	LD C,A ;save string char
	CALL makupl ;get input char uppercase
	CP C ;compare
	RET NZ ;mismatch
	INC HL ;advance input
	INC DE ;advance string
	JP gostrcm ;loop
;
gostr:	db	'GO ',0
tostr:	db	'TO',0
ubstr:	db	'UB',0

notgos:	POP HL
	CALL makupl ;get back the character
	PUSH HL ;resave the text pointer
	LD HL,alptab ;get pointer to alpha dispatch table
	SUB 'A' ;subtract alpha offset
	ADD A ;multiply by two
	LD C,A ;save offset in [c] for dad.
	LD B,0 ;make high part of offset zero
	ADD HL,BC ;add to table address
	LD E,(HL) ;set up pointer in [d,e]
	INC HL
	LD D,(HL) ;get high part of address
	POP HL ;get back source pointer
	INC HL ;point to char after first alpha
tryaga:	PUSH HL ;save txtptr to start of search area
loppsi:
	CALL makupl ;translate this char to upper case
	LD C,A ;save char in [c]
	LD A,(DE) ;get byte from reserved word list
	AND 127 ;get rid of high bit
	JP Z,notres ;if=0 then end of this chars reslt
	INC HL ;bump source pointer
	CP C ;compare to char from source line
	JP NZ,lopskp ;if no match, search for next reswrd
	LD A,(DE) ;get reswrd byte again
	INC DE ;bump reslst pointer
	OR A ;set cc'S
	JP P,loppsi ;see if rest ofchars match
	LD A,C ;get last char of reswrd
	CP '(' ;if tab( or spc(, space need not follow
	JP Z,isresw ;is a resword
	LD A,(DE) ;look after char
	CP $fn ;function?
	JP Z,isresw ;then no space need afterward
	CP $usr ;or usr definition?
	JP Z,isresw
	CALL makupl ;get next char in line (mc 6/22/80)
	CP '.' ;is it a dot
	JP Z,isvars ;yes
	CALL tstanm ;is it a letter immediately following reswrd
isvars:	LD A,0 ;set donum to -1
	JP NC,notres ;if alpha, cant be reserved word
isresw:
	POP AF ;get rid of saved [h,l]
	LD A,(DE) ;get reswrd value
	OR A ;set cc'S
	JP M,notfnt ;if minus, wasnt function token
	POP BC ;get char count off stack
	POP DE ;get deposit pointer off stack
	OR 200o ;make high order bit one
	PUSH AF ;save fn char
	LD A,377o ;get byte which preceeds fns
	CALL krnsav ;save in krunch buffer
	XOR A ;make a zero
	LD (donum),A ;to reset donum (floatings allowed)
	POP AF ;get function token
	CALL krnsav ;store it
	JP kloop ;keep krunching

lopskp:	POP HL ;restore undefiled text pointer
lopsk2:	LD A,(DE) ;get a byte from reswrd list
	INC DE ;bump reslst pointer
	OR A ;set cc'S
	JP P,lopsk2 ;not end of reswrd, keep skipping
	INC DE ;point after token
	JP tryaga ;try another reswrd

notfnt:	DEC HL ;fix text pointer
notfn2:	PUSH AF ;5.21: save char to be saved in krunch buffer
	LD DE,lntktb ;5.21: point to line number token table
	LD C,A ;5.21: save token in C
lntkl:	LD A,(DE) ;5.21: get table byte
	OR A ;5.21: end of table?
	JP Z,lntknd ;5.21: yes, not found
	INC DE ;5.21: next table entry
	CP C ;5.21: match?
	JP NZ,lntkl ;5.21: no, keep looking
	JP notrs2 ;5.21: found, go to line# handler
;
; 5.21 line number token table
;
lntktb:	db	$resto ;restore
	db	$auto ;auto
	db	$renum ;renum
	db	$delet ;delete
	db	$edit ;edit
	db	$resum ;resume
	db	$erl ;erl
	db	$else ;else
	db	$run ;run
	db	$list ;list
	db	$llist ;llist
	db	$goto ;goto
	db	$then ;then
	db	$gosub ;gosub
	db	0 ;end of table
lntknd:	XOR A ;5.21: get a zero (not found, line#s NOT allowed)
	db	302q ;"JNZ" over next two bytes
notrs2:	LD A,1 ;say line #'S ALLOWED.
notrs6:	LD (donum),A ;save in flag
	POP AF ;restore character to save in krunch buffer
	POP BC ;get back the character count
	POP DE ;get stuff pointer back
	CP $else ;have to put a hidden
					;colon in front of "ELSE"s
	PUSH AF ;save current char ($else)
	CALL Z,krnsvc ;save ":" in crunch buffer
	POP AF ;get back token
	CP $while ;5.21: check for WHILE token
	JP NZ,cksngq ;not WHILE, skip to sngqtk check
	CALL krnsav ;5.21: save token
	LD A,plustk ;5.21: set to non-sngqtk value
cksngq:	CP sngqtk ;single quoatation mark?
	JP NZ,ntsngt
	PUSH AF ;save sngqtk
	CALL krnsvc ;save ":" in crunch buffer
	LD A,$rem ;store ":$REM" in front for execution
	CALL krnsav ;save it
	POP AF ;get sngqtk back
	PUSH AF ;save back as terminator for strng
	JP strng2 ;stuff the rest of the line without crunching
tstnum:	LD A,(HL) ;get char
	CP '.' ;test for start of floating #
	JP Z,numtry ;try inputting it as constant
	CP '9'+1 ;is it a digit?
	JP NC,srcspc ;no, try other things
	CP '0' ;try lower end
	JP C,srcspc ;no try other possibilities
numtry:	LD A,(donum) ;test for numbers allowed
	OR A ;set cc'S
	LD A,(HL) ;get char if going to stuffh
	POP BC ;restore char count
	POP DE ;restore dep. pointer
	JP M,kstuff ;5.21: no, just stuff it (!)
	JP Z,fltget ;if donum=0 then floating #'S ALLOWED
	CP '.' ;is it dot?
	JP Z,kstuff ;5.21: stuff it (edit .)
	LD A,lincon ;get line # token
	CALL krnsav ;save it
	PUSH DE ;save deposit pointer
	CALL linget ;get the line #.
	CALL baksp ;back up pointer to after last digit
savint:	EX (SP),HL ;exchange current [h,l] with saved [d,e]
	EX DE,HL ;get saved [d,e] in [d,e]
savi:	LD A,L ;get low byte of value returned by linget
	CALL krnsav ;save the low byte of line #
	LD A,H ;get high byte
popstf:	POP HL ;restore [h,l]
	CALL krnsav ;save it too
	JP kloop ;eat some more

fltget:	PUSH DE ;save deposit pointer
	PUSH BC ;save char count
	LD A,(HL) ;fin assumes char in [a]
	CALL fin ;read the #
	CALL baksp ;back up pointer to after last digit
	POP BC ;restore char count
	POP DE ;restore deposit pointer
	PUSH HL ;save text pointer
	LD A,(valtyp) ;get value type
	CP 2 ;integer?
	JP NZ,ntintg ;no
	LD HL,(faclo) ;get it
	LD A,H ;get high part
	OR A ;is it zero?
	LD A,2 ;restore int valtyp
	JP NZ,ntintg ;then isnt single byte int
	LD A,L ;get low byte
	LD H,L ;get low byte in high byte to store
	LD L,in2con ;get constant for 1 byte ints
	CP 10 ;is it too big for a single byte constant?
	JP NC,savi ;too big, use single byte int
	ADD onecon ;make single byte constant
	JP popstf ;pop h & stuff away char
ntintg:	PUSH AF ;save for later
	RRCA ;divide by two
	ADD intcon-1 ;add offset to get token
	CALL krnsav ;save the token
	LD HL,faclo ;get start pointer
	CALL getypr ;set cc'S ON VALTYPE
	JP C,ntdbl ;if not double, start moving at faclo
	LD HL,dfaclo ;double, start moving at dfaclo
ntdbl:	POP AF ;restore count of bytes to move
movcon:	PUSH AF ;save byte move count
	LD A,(HL) ;get a byte
	CALL krnsav ;save it in krunch buffer
	POP AF ;get back count
	INC HL ;bump pointer into fac
	DEC A ;move it down
	JP NZ,movcon ;keep moving it
	POP HL ;get back saved text pointer
	JP kloop ;keep looping

srcspc:	LD DE,spctab-1 ;get pointer to special character table
srcsp2:	INC DE ;move pointer ahead
	LD A,(DE) ;get byte from table
	AND 177o ;mask off high bit
	JP Z,notrs5 ;if end of table, stuff away, dont change donum
	INC DE ;bump pointer
	CP (HL) ;is this special char same as current text char?
	LD A,(DE) ;get next reswrd
	JP NZ,srcsp2 ;if no match, keep looking
	JP notrs1 ;found, save away and set donum=1.

ntsngt:
	CP '&' ;octal constant?
	JP NZ,kstuff ;5.21: just stuff it away
	PUSH HL ;save text pointer
	CALL chrgtr ;get next char
	POP HL ;restore text pointer
	CALL makups ;make char upper case
	CP 'H' ;hex constant?
	LD A,octcon ;assume octal constant
	JP NZ,wuzoct ;yes, it was
	LD A,hexcon ;no, was hex
wuzoct:	CALL krnsav ;save it
	PUSH DE ;save current deposit pointer
	PUSH BC ;save count
	CALL octcns ;get the value
	POP BC ;restore [b,c]
	JP savint ;save the integer in the krunch buffer
krnsvc:	LD A,':' ;get colon
krnsav:	LD (DE),A ;save byte in krunch buffer
	INC DE ;bump pointer
	DEC BC ;decrement count of bytes left in buffer
	LD A,C ;test if it went to zero
	OR B ;by seeing if double byte zero.
	RET NZ ;all done if still space left
lboerr:	LD E,errlbo ;get error code
	JP error ;jump to error routine

notres:	POP HL ;get back pointer to original char
	DEC HL ;now point to first alpha char
	DEC A ;set a to minus one
	LD (donum),A ;flag were in variable name
	POP BC ;get back char count
	POP DE ;get back deposit pointer
	CALL makupl ;get char from line, make upper case
krnvar:	CALL krnsav ;save char
	INC HL ;incrment source pointer
	CALL makupl ;make upper case (?)
	CALL islet2 ;is it a letter?
	JP NC,krnvar ;yes, eat
	CP '9'+1 ;digit?
	JP NC,jkloop ;no, too large
	CP '0'
	JP NC,krnvar ;yes, eat
	CP '.' ;is it dot
	JP Z,krnvar ;yes, dots ok in var names
jkloop:	JP kloop ;done looking at variable name
notrs5:	LD A,(HL) ;get char from line
	CP 32 ;space or higher ?
	JP NC,notrs1 ;yes = save it
	CP 9 ;tab ?
	JP Z,notrs1 ;yes = that'S OK
	CP 10 ;also allow...
	JP Z,notrs1 ;...line feeds
	LD A,32 ;force rest to spaces
notrs1:	PUSH AF ;save this char
	LD A,(donum) ;get number ok flag
	INC A ;see if in a variable name.
	JP Z,jntrs6 ;if so & special char seen, reset donum
	DEC A ;otherwise leave donum unchanged.
jntrs6:	JP notrs6

; routine to back up pointer after # eaten
baksp:	DEC HL ;point to previous char
	LD A,(HL) ;get the char
	CP ' ' ;a space?
	JP Z,baksp ;yes, keep backing up
	CP 9 ;tab?
	JP Z,baksp ;yes, back up
	CP 10 ;lf?
	JP Z,baksp
	INC HL ;point to char after last non-space
	RET ;all done.
	page
	page
	subttl	the non-extended "LIST" command



	page
	subttl	"FOR" statement
;
; a "FOR" entry on the stack has the following format:
;
; low address
;	token ($for in high byte)  1 byte
;	a pointer to the loop variable  2 bytes
;	a byte reflecting the sign of the increment 1 byte
;	the step 4 bytes
;	the upper value 4 bytes
;	the line # of the "FOR" statement 2 bytes
;	a text pointer into the "FOR" statement 2 bytes
; high address
;
; total 16 bytes
;

for:	LD A,100
	LD (subflg),A ;dont recognize subscripted variables
	CALL ptrget ;get pointer to loop variable
	CALL synchr
	db	equltk ;skip over assignment "="
	PUSH DE ;save the variable pointer
	EX DE,HL ;save the loop variable in temp
	LD (temp),HL ;for use later on
	EX DE,HL
	LD A,(valtyp) ;remember the loop variable type
	PUSH AF
	CALL frmevl ;get the start value
	POP AF ;reget the loop type
	PUSH HL ;save the text pointer
	CALL docnvf ;force conversion to loop type
	LD HL,fvalsv ;place to save the value
	CALL movmf ;store for use in "NEXT"
	POP HL ;get back the text pointer
	POP DE ;get back the variable pointer
					;the correct intial value
					;and store a pointer
					;to the variable in [temp]
	POP BC ;get rid of the newstt return
	PUSH HL ;save the text pointer
	CALL data ;set [h,l]=end of statement
	LD (endfor),HL ;save for comparison
	LD HL,0+2 ;set up pointer into stack
	ADD HL,SP
lpform:	CALL looper ;5.21: must have variable pointer in [d,e]
	JP NZ,notol ;5.21: if no matching entry, don't
					;eliminate anything
	ADD HL,BC ;in the case of "FOR"
					;we eliminate the matching entry
					;as well as everything after it
	PUSH DE ;save the text pointer
	DEC HL ;see if end text pointer of matching entry
	LD D,(HL) ;matches the for we are handling
	DEC HL ;pick up the end of the "FOR" text pointer
	LD E,(HL) ;for the entry on the stack
	INC HL ;without changing [h,l]
	INC HL
	PUSH HL ;save the stack pointer for the comparison
	LD HL,(endfor) ;get ending text pointer for this "FOR"
	CALL dcompr ;see if they match
	POP HL ;get back the stack pointer
	POP DE ;5.21: get text pointer before jnz
	JP NZ,lpform ;keep searching if no match
	POP DE ;get back the text pointer
	LD SP,HL ;do the elimination
	LD (savstk),HL ;update saved stack
					;since a matching entry was found
	db	0Eh ;5.21: MVI C opcode
notol:	POP DE ;5.21: D1 serves as MVI operand AND POP D
	EX DE,HL ;[h,l]=text pointer
	LD C,8 ;make sure 16 bytes are available
					;off of the stack
	CALL getstk
	PUSH HL ;really save the text pointer
	LD HL,(endfor) ;pick up pointer at end of "FOR"
					;just beyond the terminator
	EX (SP),HL ;put [h,l] pointer to terminator on the stack
					;and restore [h,l] as text pointer at
					;variable name
	PUSH HL ;push the text pointer onto the stack
	LD HL,(curlin) ;[h,l] get the current line #
	EX (SP),HL ;now the current line # is on the stack and
					;[h,l] is the text pointer
	CALL synchr
	db	$to ;"TO" is necessary
	CALL getypr ;see what type this value has
	JP Z,tmerr ;give strings a "TYPE MISMATCH"
	JP NC,tmerr ;as well as double-precision
	PUSH AF ;save the integer/floating flag
	CALL frmevl ;evaluate the target value formula
	POP AF ;pop off the flag
	PUSH HL ;save the text pointer
	JP P,sngfor ;positive means single precision "FOR"-loop
	CALL frcint ;coerce the final value
	EX (SP),HL ;save it on the stack and reget the
					;text pointer
	LD DE,0+1 ;default the step to be 1
	LD A,(HL) ;see what character is next
	CP steptk ;is there a "STEP" clause?
	CALL Z,getint ;if so, read the step into [d,e]
	PUSH DE ;put the step onto the stack
	PUSH HL ;save the text pointer
	EX DE,HL ;step into [h,l]
	CALL isign ;the sign of the step into [a]
	JP stpsgn ;finish up the entry
					;by putting the sign of the step
					;and the dummy entries on the stack
sngfor:	CALL frcsng
	CALL movrf ;get the stuff
	POP HL ;regain text pointer
	PUSH BC ;opposite of pushr
	PUSH DE ;save the sign of the increment
	LD BC,0+201o*256
	LD D,C
	LD E,D ;get 1.0 in the registers
	LD A,(HL) ;get terminating character
	CP steptk ;do we have "STEP" ?
	LD A,1 ;setup default sign
	JP NZ,oneon ;push some constants on if not
	CALL frmchk ;don'T NEED TO CHECK THE TYPE
	PUSH HL
	CALL frcsng
	CALL movrf ;set up the registers
	CALL sign ;get the sign of the increment
stpsgn:	POP HL ;pop off the text pointer
oneon:	PUSH BC ;put value on backwards
	PUSH DE ;opposite of pushr
	LD C,A ;[c]=sign of step
	CALL getypr ;must put on integer/single-precision flag
					;minus is set for integer case
	LD B,A ;high byte = integer/single precision flag
	PUSH BC ;save flag and sign of step both
	DEC HL ;make sure the "FOR" ended properly
	CALL chrgtr
	JP NZ,snerr
	CALL nxtscn ;scan until the matching "NEXT" is found
	CALL chrgtr ;fetch first character of "NEXT"
	PUSH HL ;make the next txtptr part of the entry
	PUSH HL
	LD HL,(nxtlin) ;get the line number of next
	LD (curlin),HL ;make it the current line
	LD HL,(temp) ;get the pointer to the variable back
	EX (SP),HL ;put the pointer to the variable
					;onto the stack and restore the text pointer
	LD B,$for ;finish up "FOR"
	PUSH BC
	INC SP
	PUSH AF ;save the character
	PUSH AF ;make a stack entry to substitute for "NEWSTT"
	JP nexts ;go execute "NEXT" with nxtflg zero
nxtcon:	LD B,$for ;put a 'FOR' token onto the stack
	PUSH BC
	INC SP ;the "TOKEN" only takes one byte of
					;stack space
;	jmp	newstt		;all done
	page
	subttl	new statement fetcher
;
; back here for new statement. character pointed to by [h,l]
; ":" or end-of-line. the address of this location is
; left on the stack when a statement is executed so
; it can merely do a return when it is done.
;
newstt:
	PUSH HL
csts	set	0
const2:	CALL csts ;get console status
	POP HL ;restore all registers
	OR A ;set cc'S - 0 FALSE - NO CHAR TYPED
	CALL NZ,cntccn ;see if its control-c
					;if so, check for contrl-c
	LD (savtxt),HL ;used by continue and input and clear and print using
	EX DE,HL ;save text pointer
	LD HL,0 ;save stack pointer
	ADD HL,SP ;copy to [h,l]
	LD (savstk),HL ;save it
					;to remember how to restart this
					;statement
	EX DE,HL ;get current text pointer back in [h,l]
					;to save bytes & speed
	LD A,(HL) ;get current character
					;which terminated the last statement
	CP ':' ;is it a colon?
	JP Z,gone
	OR A
	JP NZ,snerr ;must be a zero
	INC HL
gone4:	LD A,(HL) ;check pointer to see if
					;it is zero, if so we are at the
					;end of the program
	INC HL
	OR (HL) ;or in high part
	JP Z,prgend ;fix syntax error in unended error routine
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL) ;get line # in [d,e]
	EX DE,HL ;[h,l]=line #
	LD (curlin),HL ;setup curlin with the current line #
	LD A,(trcflg) ;see if trace is on
	OR A ;non-zero means yes
	JP Z,nottrc ;skip this printing
	PUSH DE ;save the text pointer
	LD A,'[' ;format the line number
	CALL outdo ;output it
	CALL linprt ;print the line # in [h,l]
	LD A,']' ;some more formating
	CALL outdo
	POP DE ;[d,e]=text pointer
nottrc:
	EX DE,HL ;restore the text pointer
gone:	CALL chrgtr ;get the statement type
	LD DE,newstt ;push on a return address of newstt
	PUSH DE ;statement
gone3:	RET Z ;if a terminator try again
					;"IF" comes here
gone2:	SUB $end ;"ON ... GOTO" and "ON ... GOSUB" come here
	JP C,let ;must be a let
	CP numcmd
					;a statement reserved word
	JP NC,ismid$ ;see if lhs mid$ case
	RLCA ;multiply by 2
	LD C,A
	LD B,0
	EX DE,HL
	LD HL,stmdsp ;statement dispatch table
	ADD HL,BC ;add on offset 
	LD C,(HL) ;push the address to go to onto
	INC HL ;the stack
	LD B,(HL) ;pushm saves bytes but not speed
	PUSH BC
	EX DE,HL ;restore the text pointer
; newstt falls into chrget. this fetches the first char after
; the statement token and the chrget'S "RET" DISPATCHES TO STATEMENT
	page
	subttl	chrget - the next character scan routine
chrgtr:	INC HL ;duplication of chrget rst for speed
chrgt2:	LD A,(HL) ;see chrget rst for explanation
	CP ':'
	RET NC
;
; chrcon is the continuation of the chrget rst
;
; in extended, check for inline constant and if one
; move it into the fac & set valtyp appropriately
octcon	set	11 ;embeded octal constant
hexcon	set	12 ;embeded constant
ptrcon	set	13 ;a line reference constant
lincon	set	14 ;a line number unconverted to pointer
in2con	set	15 ;single byte (two byte with token) integer
concn2	set	16 ;token returned second type constant is scanned.
onecon	set	17 ;first of 10 (0-9) integer special tokens
intcon	set	28 ;regular 16 bit two'S COMPLEMENT INT
sngcon	set	29 ;single prec (4 byte) constant
concon	set	30 ;token returned by chrget after constant scanned
dblcon	set	31 ;double prec (8 byte) constant
chrcon:	CP ' ' ;must skip spaces
	JP Z,chrgtr ;get another character
	JP NC,notlft ;not special try other possib.
	OR A ;null at eol?
	RET Z ;yes, all done
	CP octcon ;is it inline constant
	JP C,notcon ;no, should be tab or lf
	CP concon ;are we trying to re-scan a constant?
	JP NZ,ntrscc ;no.
	LD A,(consav) ;get the saved constant token
	OR A ;set non-zero, non carry cc'S
	RET ;all done

ntrscc:	CP concn2 ;going to scan past embedded constant?
	JP Z,conscn ;5.21: yes, jump forward to conscn
ntrsc2:	PUSH AF ;save token to return
	INC HL ;point to number
	LD (consav),A ;save current token
	SUB intcon ;is it less than integer constant?
	JP NC,maktkn ;no, not line number constant
	SUB 365o ;<onecon-intcon>&^o377
					;less than embedded 1 byter
	JP NC,onei ;was one byter
	CP in2con-onecon ;is it two byter?
	JP NZ,frcinc ;nope, normal int
	LD A,(HL) ;get embeded int
	INC HL ;point after constant
onei:	LD (contxt),HL ;save text pointer
	LD H,0 ;get upper byte of zero
onei2:	LD L,A ;get value
	LD (conlo),HL ;save constant value
	LD A,2 ;get valtype
	LD (contyp),A ;set it up in save place
	LD HL,numcon ;point to number re-scanner
	POP AF ;get back token
	OR A ;make sure number flag re-set
	RET ;return to caller

frcinc:	LD A,(HL) ;get low byte of constant
	INC HL ;point past it
	INC HL ;to next thing
	LD (contxt),HL ;save pointer past
	DEC HL ;back to high byte
	LD H,(HL) ;get high byte
	JP onei2 ;finish scanning
jfccsc:	CALL confac ;5.21: trampoline entry for JC from eval
conscn:	LD HL,(contxt) ;5.21: get saved text pointer
	JP chrgt2 ;and scan thing after constant
maktkn:	INC A ;calculate valtype
	RLCA ;*2 to get valtype 0=2, 1=4, 3=8
	LD (contyp),A ;contype now setup
	PUSH DE ;save some rgs
	PUSH BC
	LD DE,conlo ;place to store saved constant
	EX DE,HL ;get text pointer in [d,e]
	LD B,A ;setup counter in [b]
	CALL move1 ;move data in
	EX DE,HL ;get text pointer back
	POP BC ;restore [b,c]
	POP DE
finin1:	LD (contxt),HL ;save the good text pointer
	POP AF ;restore token
	LD HL,numcon ;get pointer to fake text
	OR A ;clear carry so others dont think its a number
					;and set non-zero so not terminator
	RET ;all done
notcon:
	CP 9 ;line feed or tab?
	JP NC,chrgtr ;yes, eat.
notlft:	CP '0' ;all characters greater than
					;"9" have returned, so see if numeric
	CCF ;make numerics have carry on
	INC A ;set zero if [a]=0
	DEC A
	RET

numcon:	db	concon ;these fake tokens force chrget
	db	concn2 ;to effectively re-scan the embeded constant

; this routine moves the saved constant into the fac
confac:
	LD A,(consav) ;get constant token
	CP lincon+1 ;line# constant? (erl=#)
	JP NC,ntline ;no
	CP ptrcon ;line pointer constant?
	JP C,ntline ;no
	LD HL,(conlo) ;get value
	JP NZ,fltlin ;must be line number, not pointer
	INC HL ;point to line #
	INC HL
	INC HL
	LD E,(HL) ;get line # in [d,e]
	INC HL
	LD D,(HL) ;get high part
	EX DE,HL ;value to [h,l]
fltlin:	JP ineg2 ;5.21: float it (returns via chain)
ntline:
	LD A,(contyp) ;get saved constant valtyp
	LD (valtyp),A ;save in real valtyp
	CP 8 ;double precision
	JP Z,confdb ;yes
	LD HL,(conlo) ;get low two bytes of fac
	LD (faclo),HL ;save them
	LD HL,(conlo+2) ;get next two bytes
	LD (faclo+2),HL ;save them
	RET ;5.21: return directly
confdb:	LD HL,conlo ;get pointer to saved constant area
	JP vmovfm ;5.21: move into fac (returns via vmovfm)
	page
	subttl	defstr, defint, defsng, defdbl, intidx
defstr:	LD E,3 ;default some letters to string
	db	1q ;"LXI B," over the next 2 bytes
defint:	LD E,2 ;default some letters to integer
	db	1q ;"LXI B," over the next 2 bytes
defrea:	LD E,4 ;default some letters to single precision
	db	1q ;"LXI B," over the next 2 bytes
defdbl:	LD E,8 ;default some letters to double precision
defcon:	CALL islet ;make sure the argument is a letter
	LD BC,snerr ;prepare "SYNTAX ERROR" return
	PUSH BC
	RET C ;return if theres no letter
	SUB 'A' ;make an offset into deftbl
	LD C,A ;save the initial offset
	LD B,A ;assume it will be the final offset
	CALL chrgtr ;get the possible dash
	CP minutk ;a range argument?
	JP NZ,notrng ;if not, just one letter
	CALL chrgtr ;get the final position
	CALL islet ;check for a letter
	RET C ;give a syntax error if improper
	SUB 'A' ;make it an offset
	LD B,A ;put the final in [b]
	CALL chrgtr ;get the terminator
notrng:	LD A,B ;get the final character
	SUB C ;subtract the start
	RET C ;if it'S LESS THATS NONSENSE
	INC A ;setup the count right
	EX (SP),HL ;save the text pointer and get rid
					;of the "SYNTAX ERROR" return
	LD HL,deftbl ;point to the table of defaults
	LD B,0 ;setup a two-byte starting offset
	ADD HL,BC ;make [h,l] point to the first entry
					;to be modified
lpdchg:	LD (HL),E ;modify the default table
	INC HL
	DEC A ;count dount the number of changes to make
	JP NZ,lpdchg
	POP HL ;get back the text pointer
	LD A,(HL) ;get last character
	CP 44 ;is it a comma?
	RET NZ ;if not statement should have ended
	CALL chrgtr ;otherwise set up to scan new range
	JP defcon
;
; intidx reads a formula from the current position and
; turns it into a positive integer
; leaving the result in [d,e].  negative arguments
; are not allowed. [h,l] points to the terminating
; character of the formula on return.
;
intidx:	CALL chrgtr
intid2:	CALL getin2 ;read a formula and get the
					;result as an integer in [d,e]
					;also set the condition codes based on
					;the high order of the result
	RET P ;don'T ALLOW NEGATIVE NUMBERS
fcerr:	LD E,errfc ;too big. function call error
	JP error
	page
	subttl	linspc, linget
;
; linspc is the same as linget except in allows the
; current line (.) specifier
;
linspc:	LD A,(HL) ;get char from memory
	CP '.' ;is it current line specifier
	EX DE,HL ;save text pointer
	LD HL,(dot) ;get current line #
	EX DE,HL ;get back text pointer
	JP Z,chrgtr ;all done.

;
; linget reads a line # from the current text position
;
; line numbers range from 0 to 65529
;
; the answer is returned in [d,e].
; [h,l] is updated to point to the terminating character
; and [a] contains the terminating character with condition
; codes set up to reflect its value.
;
linget:	DEC HL ;backspace ptr
lingt2:	CALL chrgtr ;fetch char (gobble line constants)
	CP lincon ;embedded line constant?
	JP Z,lingt3 ;yes, return double byte value
	CP ptrcon ;also check for pointer
lingt3:	EX DE,HL ;save text ptr in [d,e]
	LD HL,(conlo) ;get embedded line #
	EX DE,HL ;restore text ptr.
	JP Z,chrgtr ;eat following char
	XOR A ;5.21: clear consav
	LD (consav),A ;5.21: for non-line-constant case
	DEC HL ;back up pointer
	LD DE,0 ;zero accumulated line #
morlin:	CALL chrgtr
	RET NC ;was it a digit
	PUSH HL
	PUSH AF
	LD HL,0+6552 ;see if the line # is too big
	CALL dcompr
	JP C,pophsr ;yes, don'T SCAN ANY MORE DIGITS IF SO
					;force caller to see digit and give syntax error
					;can'T JUST GO TO SYNTAX ERROR BECAUSE OF NON-FAST
					;renum which can'T TERMINATE
	LD H,D ;save [d,e]
	LD L,E
	ADD HL,DE
	ADD HL,HL
	ADD HL,DE
	ADD HL,HL ;putting [d,e]*10 into [h,l]
	POP AF
	SUB '0'
	LD E,A
	LD D,0
	ADD HL,DE ;add the new digit
	EX DE,HL
	POP HL ;get back text pointer
	JP morlin
pophsr:	POP AF ;get off terminating digit
	POP HL ;get back old text pointer
	RET
	page
	subttl	run, goto, gosub, return, data, rem
run:	JP Z,runc ;no line # argument
	CP lincon ;line number constant?
	JP Z,conrun ;yes
	CP ptrcon ;line pointer (rather unlikely)
	JP NZ,lrun
conrun:
					;clean up,set [h,l]=[txttab]-1 and
					;return to newstt
	CALL clearc ;clean up -- reset the stack
					;datptr,variables ...
					;[h,l] is the only thing preserved
	LD BC,newstt
	JP runc2 ;put "NEWSTT" on and fall into "GOTO"
; a "GOSUB" entry on the stack has the following format
;
; low address
;
;	a token equal to $gosub 1 byte
;	the line # of the the "GOSUB" statement 2 bytes
;	a pointer into the text of the "GOSUB" 2 bytes
;
; high address
;
; total 5 bytes
;
gosub:	LD C,3 ;"GOSUB" entries are 5 bytes long
	CALL getstk ;make sure there is room
	CALL linget ;must scan line number now
	POP BC ;pop off return address of "NEWSTT"
	PUSH HL ;really push the text pointer
	PUSH HL ;save text pointer
	LD HL,(curlin) ;get the current line #
	EX (SP),HL ;put curlin on the stack and [h,l]=text ptr
	LD A,$gosub
	PUSH AF ;put gosub token on the stack
	INC SP ;the gosub token takes only one byte
	PUSH BC ;save newstt on stack
	JP goto2 ;have now grab line # properly
					;continue with subroutine
runc2:	PUSH BC ;restore return address
					;of "NEWSTT"
; and search. in the 8k we start where we
; are if we are  going to a forward location.
;
goto:	CALL linget ;pick up the line #
					;and put it in [d,e]
goto2:
	LD A,(consav) ;get token for line # back
	CP ptrcon ;was it a pointer
	EX DE,HL ;assume so
	RET Z ;if it was, go back to newstt
					;with [h,l] as text ptr
	CP lincon ;5.21: was it a line number constant?
	JP NZ,snerr ;5.21: no, error - invalid constant type
	EX DE,HL ;flip back if not
	PUSH HL ;save current text ptr on stack
	LD HL,(contxt) ;get pointer to right after constant
	EX (SP),HL ;save on stack, restore current text ptr
	CALL rem ;skip to the end of this line
	INC HL ;point at the link beyond it
	PUSH HL ;save the pointer
	LD HL,(curlin) ;get the current line #
	CALL dcompr ;[d,e] contains where we are going
					;[h,l] contains the current line #
					;so comparing them tells us whether to
					;start searching from where we are or
					;to start searching from the beginning
					;of txttab
	POP HL ;[h,l]=current pointer
	CALL C,loop ;search from this point
	CALL NC,fndlin ;search from the beginning -- actually
					;search again if above search failed
	JP NC,userr ;line not found, death
	DEC BC ;point to zero at end of previous line
	LD A,ptrcon ;pointer constant
	LD (ptrflg),A ;set ptrflg
	POP HL ;get saved pointer to right after constant
	CALL conch2 ;change line # to ptr
	LD H,B ;[h,l]= pointer to the start of the
					;matched line
	LD L,C ;now pointing at the first byte of the pointer
					;to the start of the next line
	RET ;go to newstt
userr:	LD E,errus
	JP error ;c=match, so if no match we
					;give a "US" error
;
; see "GOSUB" for the format of the stack entry
; "RETURN" restores the line number and text pointer on the stack
; after eliminating all the "FOR" entries in front of the "GOSUB"
; entry
;
return:	RET NZ ;blow him up if there isn'T A TERMINATOR
	LD D,255 ;make sure this variable pointer
					;in [d,e] never gets matched
	CALL fndfor ;go past all the "FOR" entries
	LD SP,HL ;update the stack
	LD (savstk),HL ;update saved stack
	CP $gosub
	LD E,errrg ;error errrg is "RETURN WITHOUT GOSUB"
	JP NZ,error
	POP HL ;get line # "GOSUB" was from
	LD (curlin),HL ;put it into curlin
	LD HL,newstt
	EX (SP),HL ;put return address of "NEWSTT"
					;back onto the stack. get text pointer
					;from "GOSUB"
					;skip over some characters
					;since when "GOSUB" stuck the text pointer
					;onto the stack the line # argument hadn'T
					;been read in yet.

	db	76q ;"MVI A," around pop h.
datah:	POP HL ;get text pointer off stack

data:	db	1q ;"LXI B," to pick up ":" into c and skip
	db	':' ;"DATA" terminates on ":"
					;and 0. ":" only applies if
					;quotes have matched up

elses:;executed "ELSE"s are skipped
;
; note: rem must preserve [d,e] because of "GO TO" and error
;
rem:	db	16q ;"MVI C,"   the only terminator is zero
	db	0 ;no-operation
					;"DATA" actually executes this 0
remzer:	LD B,0 ;inside quotes the only terminator is zero
exchqt:	LD A,C ;when a quote is seen the second
	LD C,B ;terminator is traded, so in "DATA"
	LD B,A ;colons inside quotations will have no effect
remer:
	DEC HL ;nop the inx h in chrget
remer1:	CALL chrgtr ;get a char
	OR A ;zero is always a terminator
	RET Z
	CP B ;test for the other terminator
	RET Z
	INC HL
	CP 34 ;is it a quote?
	JP Z,exchqt ;if so time to trade
;
; when an "IF" takes a false branch it must find the appropriate "ELSE"
; to start execution at. "DATA" counts the number of "IF"s
; it sees so that the "ELSE" code can match "ELSE"s with
; "IF"s. the count is kept in [d]
					;because then s have tno colon
					;multiple ifs can be found in a single
					;statement scan
					;this causes a problem for 8-bit data
					;in unquoted string data because $if might
					;be matched. fix is to have falsif ignore changes
					;in [d] if its a data statement
;
	INC A ;function token?
	JP Z,remer1 ;then ignore following fn number
	SUB $if+1 ;is it an "IF"
	JP NZ,remer ;if not, continue on
	CP B ;since "REM" can'T SMASH
					;[d,e] we have to be careful
					;so only if b doesn'T EQUAL
					;zero we increment d. (the "IF" count)
	ADC D ;carry on if [b] not zero
	LD D,A ;update [d]
	JP remer
	page
	subttl	"LET"

; letcon is let entry point with valtyp-3 in [a]
; because getypr has been called
letcon:	POP AF ;get valtype off stack
	ADD 3 ;make valtype correct
	JP letcn2 ;continue

let:	CALL ptrget ;get the pointer to the variable
					;named in text and put
					;it into [d,e]
	CALL synchr
	db	equltk ;check for "="
	EX DE,HL ;must set up temp for "FOR"
	LD (temp),HL ;up here so when user-functions
	EX DE,HL ;call redinp, temp doesn'T GET CHANGED
redinp:	PUSH DE
	LD A,(valtyp)
	PUSH AF
	CALL frmevl ;get the value of the formula
	POP AF ;get the valtyp of the
					;variable into [a]
					;into fac
letcn2:	EX (SP),HL ;[h,l]=pointer to variable
					;text pointer to on top of stack
inpcom:	LD B,A ;save valtyp
	LD A,(valtyp) ;get present valtype
	CP B ;compare the two
	LD A,B ;get back current
	JP Z,letcn5 ;valtype already set up, go!
	CALL docnvf ;force valtpes to be [a]'S
letcn4:	LD A,(valtyp) ;get valtype
letcn5:	LD DE,faclo ;assume this is where to start moveing
	CP 5 ;is it?
	JP C,letcn6 ;yes
	LD DE,dfaclo ;no, use d.p. fac
letcn6:	PUSH HL ;save the pointer at the value position
	CP 3 ;string?
	JP NZ,copnum ;numeric, so force it and copy
	LD HL,(faclo) ;get pointer to the descriptor of the result
	PUSH HL ;save the pointer at the descriptor
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL)
	LD HL,(txttab) ;if the data is in buf, or in disk
					;random buffer, copy.
	CALL dcompr ;since buf changes all the time
	JP NC,inbufc ;go copy, if data really is in buf
	LD HL,(strend) ;see if it points into string space
	CALL dcompr ;if not don'T COPY
	POP DE ;get back the pointer at the descriptor
	JP NC,dntcpy ;don'T COPY LITERALS
	LD HL,dsctmp ;now, see if its a variable
	CALL dcompr ;by seeing if the descriptor
					;is in the temporary storage area (below dsctmp)
	JP NC,dntcpy ;don'T COPY IF ITS NOT A VARIABLE
	db	76q ;skip the next byte with a "MVI A,"
inbufc:	POP DE ;get the pointer to the descriptor
					;in [d,e]
	CALL fretms ;free up a temorary pointing into buf
	EX DE,HL ;strcpy copies [h,l]
	CALL strcpy ;copy variables in string space or
					;strings with data in buf
dntcpy:	CALL fretms ;free up the temporary without
					;freeing up any string space
	EX (SP),HL ;[h,l]=place to store the descriptor
					;leave a nonsense entry on the stack,
					;since the "POP	D" doesn'T EVER
					;matter in this case
copnum:	CALL vmove ;copy a descriptor or a value
	POP DE ;for "FOR" pop off a pointer
					;at the loop variable into [d,e]
	POP HL ;get the text pointer back
	RET
	page
	subttl	on..goto, on error goto code

ongoto:
	CP $error ;"ON...ERROR"?
	JP NZ,ntoerr ;no.
	CALL chrgtr ;get next thing
	CALL synchr
	db	$goto ;must have ...goto
	CALL linget ;get following line #
	LD A,D ;is line number zero?
	OR E ;see
	JP Z,restrp ;if on error goto 0, reset trap
	CALL fndln1 ;see if line exists (save [h,l] on stack)
	LD D,B ;get pointer to line in [d,e]
	LD E,C ;(link field of line)
	POP HL ;restore [h,l]
	JP NC,userr ;error if line not found
restrp:	EX DE,HL ;get line pointer in [h,l]
	LD (onelin),HL ;save pointer to line or zero if 0.
	EX DE,HL ;back to normal
	RET C ;you wouldn'T BELIEVE IT IF I TOLD YOU
	LD A,(oneflg) ;are we in an "ON...ERROR" routine?
	OR A ;set condition codes
	LD A,E ;want an even stack ptr. for 8086
	RET Z ;if not, have already disabled trapping.
	LD A,(errflg) ;get error code
	LD E,A ;into e.
	JP erresm ;force the error to happen
ntoerr:

	CALL getbyt ;get value into [e]
	LD A,(HL) ;get the terminator back
	LD B,A ;save this character for later
	CP $gosub ;an "ON ... GOSUB" perhaps?
	JP Z,isgosu ;yes, some feature use
	CALL synchr
	db	$goto ;otherwise must be "GOTO"
	DEC HL ;back up character pointer
isgosu:	LD C,E ;get count into  [c]
loopon:	DEC C ;see if enough skips
	LD A,B ;put dispatch character in place
	JP Z,gone2 ;if done, go off
	CALL lingt2 ;skip over a line #
	CP 44 ;a comma
	RET NZ ;if a comma doesn'T DELIMIT THE END OF
					;the current line # we must be the end of the line
	JP loopon ;continue gobbling line #s

	page
	subttl	resume, error statement code
resume:	LD DE,oneflg ;point to flag
	LD A,(DE) ;get flag
	OR A ;trap routine.
	JP Z,reerr ;give resume without error error	
	INC A ;make a=0
	LD (errflg),A ;clear error flag so ^c doesn'T GIVE ERROR
	LD (DE),A ;reset flag
	LD A,(HL) ;get current char back
	CP $next ;resume next?
	JP Z,resnxt ;yup.
	CALL linget ;get following line #
	RET NZ ;should terminate
	LD A,D ;is line number zero?
	OR E ;test
	JP NZ,goto2 ;do a goto that line.
	INC A ;set non zero condition codes
	JP restxt ;go to it
resnxt:	CALL chrgtr ;must terminate
	RET NZ ;blow him up
restxt:	LD HL,(errtxt) ;get pointer into line.
	EX DE,HL ;save errtxt in [d,e]
	LD HL,(errlin) ;get line #
	LD (curlin),HL ;save in current line #
	EX DE,HL
	RET NZ ;go to newstt if just "RESUME"
	LD A,(HL) ;get ":" or line header
	OR A ;set cc
	JP NZ,notbgl ;#0 means must be ":"
	INC HL ;skip header
	INC HL
	INC HL
	INC HL
notbgl:	INC HL ;point to start of this statement
	JP data ;get next stmt

; this is the error <code> statement which forces
; an error of type <code> to occur
; <code> must be .ge. 0 and .le. 255
errors:	CALL getbyt ;get the param
	RET NZ ;should have terminated
	OR A ;error code 0?
	JP Z,fcerr ;yes, error in itself
goerr:	JP error ;force an error
	page
	subttl	auto command
; the auto [begginning line[,[increment]]]
; command is used to automatically generate line numbers
; for lines to be inserted. beginning line is
; used to specify the inital line (10 is assumed if ommited)
; and the increment is used to specify the increment used
; to generate the next line #. if only a comma is used after the
; beggining line, the old increment is used.
auto:	LD DE,0+10 ;assume initial line # of 10
	PUSH DE ;save it
	JP Z,sngaut ;if end of command use 10,10
	CALL linspc ;get line #, allow use of . for current line
	EX DE,HL ;get txt ptr in [d,e]
	EX (SP),HL ;put init on stack, get 10 in [h,l]
	JP Z,sngau1 ;if terminator, use inc of 10
	EX DE,HL ;get text ptr back in [h,l]
	CALL synchr
	db	54o ;comma must follow
	EX DE,HL ;save text ptr in [d,e]
	LD HL,(autinc) ;get previous inc
	EX DE,HL ;get back text ptr; get in in[d,e]
	JP Z,sngaut ;use previous inc if terminator
	CALL linget ;get inc
	JP NZ,snerr ;should have finished.
sngaut:	EX DE,HL ;get inc in [h,l]
sngau1:	LD A,H ;see if zero
	OR L
	JP Z,fcerr ;zero inc gives fcerr
	LD (autinc),HL ;save increment
	LD (autflg),A ;set flag to use auto in main code.
	POP HL ;get initial line #
	LD (autlin),HL ;save in intial line
	POP BC ;get rid of newstt addr
	JP main ;jump into main code (for rest see after main:)
	page
	subttl	if ... then code
ifs:	CALL frmevl ;evaluate a formula
	LD A,(HL) ;get terminating character of formula

	CP 44
	CALL Z,chrgtr ;if so skip it
	CP $goto ;allow "GOTO" as well
	JP Z,okgoto
	CALL synchr
	db	thentk ;must have a then
	DEC HL
okgoto:
	PUSH HL ;save the text pointer
	CALL vsign
	POP HL ;get back the text pointer
	JP Z,falsif ;handle possible "ELSE"
docond:	CALL chrgtr ;pick up the first line # character
	RET Z ;return for "THEN :" or "ELSE :"
	CP lincon ;line number constant?
	JP Z,goto ;do a "GOTO"
	CP ptrcon ;pointer constant
	JP NZ,gone2 ;execute statement, not goto
	LD HL,(conlo) ;get text pointer
	RET ;fetch new statment
;
; "ELSE" handler. here on false "IF" condition
;
falsif:	LD D,1 ;number of "ELSE"s that must
					;be seen. "DATA" increments this
					;count every time an "IF" is seen
skpmrf:	CALL data ;skip a statement
					;":" is stuck in front of "ELSE"s
					;so that "DATA" will stop before "ELSE" clauses
	OR A ;end of line?
	RET Z ;if so, no "ELSE" clause
	CALL chrgtr ;see if we hit an "ELSE"
	CP $else
	JP NZ,skpmrf ;no, still in the "THEN" clause
	DEC D ;decrement the number of "ELSE"s that
					;must be seen
	JP NZ,skpmrf ;skip more if haven'T SEEN
					;enough
	JP docond ;found the right "ELSE" -- go execute

	page
	subttl	print code

lprint:	LD A,1 ;say non zero
	LD (prtflg),A ;save away
	JP newchr
print:
	LD C,md.sqo ;setup output file
	CALL filget
newchr:	DEC HL
	CALL chrgtr ;get another character
	CALL Z,crdo ;print crlf if end without punctuation
printc:	JP Z,finprt ;finish by resetting flags
					;finish by resetting flags
					;in which case a terminator does not
					;mean we should type a crlf
					;but just return
	CP usintk ;is it "PRINT USING" ?
	JP Z,prinus ;if so, use a special handler
	CP tabtk
	JP Z,taber ;the tab function?
	CP spctk
	JP Z,taber ;the spc function?
	PUSH HL ;save the text pointer
	CP 44
	JP Z,comprt ;is it a comma?
	CP 59 ;is it a ";"
	JP Z,notabr
	POP BC ;get rid of old text pointer
	CALL frmevl ;evaluate the formula
	PUSH HL ;save text pointer
	CALL getypr ;see if we have a string
	JP Z,strdon ;if so, print specialy
	CALL fout ;make a number into a string
	CALL strlit ;make it  a string
	LD (HL),' ' ;put a space at the end
	LD HL,(faclo) ;and increase size by 1
	INC (HL) ;size byte is first in descriptor

strdon:;use folding for strings and #s
	CALL ptrchk ;5.21: disk output?
	JP NZ,linch2 ;to be sent out
	LD HL,(faclo) ;get the pointer
	LD A,(prtflg)
	OR A
	JP Z,istty ;lpt or tty?
	LD A,(lptsiz) ;get width of printer
	LD B,A ;save in [b]
	INC A ;is it infinite?
	JP Z,linch2 ;then just print
	LD A,(lptpos)
	OR A ;don'T DO A CRLF IF STRING LONGER THAN LINE
	JP Z,linch2 ;length if position is 0
	ADD (HL)
	CCF ;set nc if overflow on check
	JP NC,linchk ;start on a new line
	DEC A ;5.21: actually equal to line length is ok
	CP B ;check for overlap
	JP linchk
istty:
	LD A,(linlen)
	LD B,A
	INC A ;no overflow line width?
	JP Z,linch2 ;yes
	LD A,(ttypos) ;see where we are
					;see where we are
	OR A ;don'T DO CRLF
	JP Z,linch2 ;if already at 0 even if string is longer that line length
	ADD (HL) ;add this length
	CCF ;set nc if overflow on check
	JP NC,linchk ;(possible since strings can be big..)
	DEC A ;actually equal to line length is ok
	CP B
linpt3	set	$-1
linchk:	CALL NC,crdo ;if so crlf
linch2:	CALL strprt ;print the number
	POP HL
	JP newchr ;print some more
comprt:
	LD BC,nmlo.c ;5.21: load offset first
	LD HL,(ptrfil) ;5.21: then load file pointer
	ADD HL,BC ;[h,l] point at position
	CALL ptrchk ;5.21: check if file active (preserves h)
	LD A,(HL) ;get position if file is active
	JP NZ,morcom
	LD A,(prtflg) ;output to the line printer?
	OR A ;non-zero means yes
	JP Z,isctty ;no, do teletype comma
	LD A,(nlppos) ;are we using infinite width?
	LD B,A ;also put in [b]
	INC A ;test
	LD A,(lptpos) ;get line printer position
	JP Z,morcom ;always do modulus if width=255
	CP B ;check if no more comma fields
	JP chkcom ;use teletype check
isctty:
	LD A,(clmlst)
	LD B,A
	LD A,(ttypos) ;get teletype position
ncmpos	set	(((linln/clmwid)-1)*clmwid) ;position beyond which there are
	CP 255 ;infinite width?
	JP Z,morcom ;do modulus

	CP B
linpt4	set	$-1 ;fixed up by "TERMINAL WIDTH" question
chkcom:	CALL NC,crdo ;type crlf
	JP NC,notabr ;and quit if beyond the last comma field
morcom:	SUB clmwid ;get [a] modulus clmwid
	JP NC,morcom
	CPL ;we want to  fill
					;the print position out
					;to an even clmwid, so
					;we print clmwid-[a] mod clmwid spaces
	JP aspa2 ;go print [a]+1 spaces
taber:
	PUSH AF ;remember if [a]=spctk or tabtk
	CALL chrgtr
	CALL getin2 ;evaluate the argument
	POP AF ;see if its spc or tab
	PUSH AF
	CP spctk ;if space leave alone
	JP Z,spcndc
	DEC DE ;offset by 1
spcndc:	LD A,D
	OR A ;make sure its not negative
	JP P,tbnong
	LD DE,0
tbnong:	PUSH HL ;save the text pointer
	CALL ptrchk ;5.21: see if going to disk file
	JP NZ,lnomod ;dont mod
	LD A,(prtflg) ;going to printer?
	OR A ;set flags
	LD A,(lptsiz) ;get size
	JP NZ,lptmdf ;was lpt, mod by its size
	LD A,(linlen) ;get the line length
lptmdf:	LD L,A
	INC A ;test for width of 255 (no folding)
	JP Z,lnomod ;if so, dont mod
	LD H,0 ;mod out by line length
	CALL imod
	EX DE,HL ;set [e] = position to go to 
lnomod:	POP HL ;get back the text pointer
	CALL synchr
	db	')'
	DEC HL
	POP AF ;get back spctk or tabtk
	SUB spctk ;was it spctk?
	PUSH HL ;save the text pointer
	JP Z,dosizt ;value in [a]
	LD BC,nmlo.c ;5.21: load offset first
	LD HL,(ptrfil) ;5.21: then load file pointer
	ADD HL,BC ;[h,l] point at position
	CALL ptrchk ;5.21: check if file active (preserves h)
	LD A,(HL) ;if file is active
	JP NZ,dosizt ;do tab calculation now
	LD A,(prtflg) ;line printer or tty?
	OR A ;non-zero means lpt
	JP Z,ttyist
	LD A,(lptpos) ;get line printer position
	JP dosizt
ttyist:
	LD A,(ttypos) ;get teletype print position
					;see where we are
dosizt:	CPL ;print [e]-[a] spaces
	ADD E
	JP C,aspa2 ;print if past current
	INC A
	JP Z,notabr ;do nothing if at current
	CALL crdo ;go to a new line
	LD A,E ;get the position to go to
	DEC A
	JP M,notabr
					;spaces
aspa2:	INC A
aspac:	LD B,A ;[b]=number of spaces to print
	LD A,' ' ;[a]=space
repout:	CALL outdo ;print [a]
					;decrement the count
	DEC B
	JP NZ,repout
notabr:	POP HL ;pick up text pointer
	CALL chrgtr ;and the next character
	JP printc ;and since we just printed
					;spaces, don'T CALL CRDO
					;if it'S THE END OF THE LINE
finprt:
	XOR A

	LD (prtflg),A
	PUSH HL ;save the text pointer
	LD H,A ;[h,l]=0
	LD L,A
	LD (ptrfil),HL ;zero out ptrfil
	POP HL ;get back the text pointer
	RET
	page
	subttl	line input, input and read code
line:
	CALL synchr
	db	$input
	CP '#' ;see if there is a file number
	JP Z,dline ;do disk input line
	CALL scnsem ;scan semicolon for no-cr
	CALL qtinp ;print quoted string if one
	CALL ptrget ;read string to store into
	CALL chkstr ;make sure its a string
	PUSH DE ;save pointer at variable
	PUSH HL ;save text pointer
	CALL sinlin ;read a line of input
	POP DE ;get text pointer
	POP BC ;get pointer at variable
	JP C,stpend ;if control-c, stop
reline:	PUSH BC ;save back variable pointer
	PUSH DE ;save text pointer
	LD B,0 ;setup zero as only terminator
	CALL strlt3 ;literalize the input
	POP HL ;restore [h,l]=text pointer
	LD A,3 ;set three for string
	JP letcn2 ;do the assignment
tryagn:
	dc	'?Redo from start'
	db	13
	db	10
	db	0
;
; here when passing over string literal in subscript of variable in input list
; on the first pass of input checking for type match and number
;
scnstr:	INC HL ;look at the next character
	LD A,(HL) ;fetch it
	OR A ;end of line?
	JP Z,snerr ;ending in string in subscript is bad syntax
	CP 34 ;only other terminator is quote
	JP NZ,scnstr ;continue until quote or 0 is found
	JP scncon ;continue matching parens since string ended

inpbak:	POP HL ;get rid of pass1 data pointer
	POP HL ;get rid of pass2 data pointer
	JP rdoin2 ;get rid of pass2 varlst pointer and retry
;
; here when the data that was typed in or in "DATA" statements
; is improperly formatted. for "INPUT" we start again.
; for "READ" we give a syntax error at the data line
;
trmnok:	LD A,(flginp) ;was it read or input?
	OR A ;zero=input
	JP NZ,datsne ;give error at data line
rdoin2:	POP BC ;get rid of the pointer into the variable list
rdoinp:
	LD HL,tryagn
	CALL strout ;print "?REDO FROM START"
					;to newstt pointing at the start of

					;start all over
	LD HL,(savtxt) ;get saved text pointer
	RET ;go back to newstt
					;of the "INPUT" statement
filsti:	CALL filinp
	PUSH HL ;put the text pointer on the stack
	LD HL,bufmin ;point at a comma
	JP inpcn3
input:

	CP '#'
	JP Z,filsti
	CALL scnsem ;scan semicolon for no-cr
	LD BC,notqti ;where to go
	PUSH BC ;when done with quoted string
qtinp:	CP 34 ;is it a quote?
	LD A,0 ;be talkative
	LD (cntofl),A ;force output
	LD A,255 ;make non-zero value
	LD (tempa+1),A ;flag to do "? "
	RET NZ ;just return
	CALL strlti ;make the message a string
	LD A,(HL) ;get char
	CP 54o ;comma?
	JP NZ,nticma ;no
	XOR A ;flag not to do it
	LD (tempa+1),A
	CALL chrgtr ;fetch next char
	JP inpcma ;continue
nticma:
	CALL synchr
	db	59 ;must end with semi-colon
inpcma:
	PUSH HL ;remember where it ended
	CALL strprt ;print it out
	POP HL ;get back saved text ptr
	RET ;all done
notqti:
	PUSH HL
getagn:
	LD A,(tempa+1) ;do "? "
	OR A
	JP Z,supprs ;then suppress "?"
	LD A,'?' ;type "?" and input a line of text
	CALL outdo
	LD A,' '
	CALL outdo
supprs:	CALL sinlin
	POP BC ;take off since maybe leaving
	JP C,stpend ;if empty leave
	PUSH BC ;put back  since didn'T LEAVE
;
; this is the first pass dictated by ansi requirment than no values be assigned 
; before checking type and number. the variable list is scanned without evaluating
; subscripts and the input is scanned to get its type. no assignment
; is done
;
	XOR A ;5.21: clear usflg
	LD (usflg),A ;reset print flag
	LD (HL),44 ;put a comma in front of buf
	EX DE,HL ;save data pointer in [d,e]
	POP HL ;get the varlst pointer into [h,l]
	PUSH HL ;resave the varlst pointer
	PUSH DE ;save a copy of the data pointer for pass2
	PUSH DE ;save the data pointer for pass1
	DEC HL ;read the first variable name
varlop:	LD A,128 ;don'T ALLOW SUBSCRIPTS -- RETURN POINTING TO "("
	LD (subflg),A
	CALL chrgtr ;advance text pointer
	CALL ptrglb ;5.21: scan name via stub
	LD A,(HL) ;see if it ended on "("
	DEC HL ;rescan the terminator
	CP '[' ;5.21: array subscript can use brackets
	JP Z,scnarr ;treat '[' same as '('
	CP '(' ;array or not?
	JP NZ,endscn ;if not, variable name is done
scnarr:	INC HL ;now scan the subscript expression
	LD B,0 ;initialize the paren count
scnopn:	INC B ;up the count for every "("
scncon:	CALL chrgtr ;get the next character
	JP Z,snerr ;shouldn'T END STATEMENT IN EXPRESSION
	CP 34 ;is there a quoted string constant
	JP Z,scnstr ;go scan the endtire constant (may contain parens)
	CP '(' ;another level of nesting?
	JP Z,scnopn ;increment coutn and keep scanning
	CP '[' ;5.21: open bracket (no count)
	JP Z,scncon ;continue without incrementing count
	CP ']' ;5.21: close bracket
	JP Z,scncls ;decrement count
	CP ')' ;one less level of parens?
	JP NZ,scncon ;no, keep scanning
scncls:;5.21: decrement paren/bracket count
	DEC B
	JP NZ,scncon ;if not at zero level, keep scanning
endscn:	CALL chrgtr ;get terminating character
	JP Z,okvlst ;last variable in input list
	CP 44 ;otherwise it must be a comma
	JP NZ,snerr ;badly formed input -- syntax error
okvlst:	EX (SP),HL ;save the varlst pointer 
					;get the data pointer into [h,l]
	LD A,(HL) ;data should always have a leading comma
	CP 44 ;is it properly formed?
	JP NZ,inpbak ;no, ask for complete reinput
	LD A,1 ;set ovcstr=1
	LD (ovcstr),A
	CALL scnval ;go into pass2 code and scan a value
	LD A,(ovcstr) ;see if it was too big
	DEC A
	JP NZ,inpbak
	PUSH HL ;save the returned data pointer
	CALL getypr ;release string
	CALL Z,frefac
	POP HL
	DEC HL ;skip over spaces left after value scan
	CALL chrgtr
;
; note check for overflow of input value here
;
	EX (SP),HL ;save the data pointer
					;[h,l]=data list pointer
	LD A,(HL) ;did variable list continue?
	CP 44 ;must have had a comma
	JP Z,varlop ;go check another
	POP HL ;get final data pointer
	DEC HL ;skip over any trailing spaces
	CALL chrgtr
	OR A ;is it a true end?
	POP HL ;get the start of data pointer for pass2
	JP NZ,rdoin2 ;if data ended badly ask for reinput
inpcn3:
	LD (HL),44 ;setup comma at bufmin
	JP inpcon
read:
	PUSH HL ;save the text pointer
	LD HL,(datptr) ;get last data location
	db	366q ;"ORI" to set [a] non-zero
inpcon:	XOR A ;set flag that this is an input
	LD (flginp),A ;store the flag
;
; in the processing of data and read statements:
; one pointer points to the data (ie the numbers being fetched)
; and another points to the list of variables
;
; the pointer into the data always starts pointing to a
; terminator -- a , : or end-of-line
;
	EX (SP),HL ;[h,l]=variable list pointer
					;data pointer goes on the stack
	JP lopdat
lopdt2:	CALL synchr
	db	44 ;make sure there is a ","
lopdat:	CALL ptrget ;read the variable list
					;and get the pointer to a variable into [d,e]
	EX (SP),HL ;put the variable list pointer onto the
					;stack and take the
					;data list pointer off
;
; note at this point we have a variable which wants data
; and so we must get data or complain
;
	PUSH DE ;save the pointer to the variable we
					;are about to set up with a value
	LD A,(HL) ;since the data list pointer always points
					;at a terminator lets read the
					;terminator into [a] and see what
					;it is
	CP 44
	JP Z,datbk ;a comma so a value must follow
	LD A,(flginp) ;see what type of statement this was
	OR A
					;search for another data statement
	JP NZ,datlop
					;the data now starts at the beginning
					;of the buffer
					;and qinlin leaves [h,l]=buf
datbk:
	db	366q ;set a non-zero
scnval:	XOR A ;set zero flag in [a]
	LD (inppas),A ;store so early return check works
	CALL ptrchk ;5.21: see if a file read (preserves h)
	JP NZ,filind ;if so, special handling
	CALL getypr ;is it a string?
	PUSH AF ;save the type information
	JP NZ,numins ;if numeric, use fin to get it
					;only the varaible type is
					;checked so an unquoted string
					;can be all digits
	CALL chrgtr
	LD D,A ;assume quoted string
	LD B,A ;setup terminators
	CP 34 ;quote ?
	JP Z,nowget ;terminators ok
	LD A,(flginp) ;input shouldn'T TERMINATE ON ":"
	OR A ;see if read or input
	LD D,A ;set d to zero for input
	JP Z,ncolst
	LD D,':' ;unquoted string terminators
ncolst:	LD B,44 ;are colon and comma
					;note: ansi uses [b]=44 as a flag to 
					;trigger trailing space suppression
	DEC HL ;backup since start character must be included
					;in the quoted string case we don'T WANT TO
					;include the starting or ending quote
nowget:	CALL strlt2 ;make a string descriptor for the value
					;and copy if necessary
doasig:	POP AF ;pop off the type information
	ADD 3 ;make valtype correct
	LD C,A ;save value type in [c]
	LD A,(inppas) ;see if scanning values for pass1
	OR A ;zero for pass1
	RET Z ;go back to pass1
	LD A,C ;recover valtyp
	EX DE,HL ;[d,e]=text pointer
	LD HL,strdn2 ;return loc
	EX (SP),HL ;[h,l]=place to store variable value
	PUSH DE ;text pointer goes on
	JP inpcom ;do assignment
numins:	CALL chrgtr
	POP AF ;get back valtype of source
	PUSH AF ;save back
	LD BC,doasig ;assignment is complicated
					;even for numerics so use the "LET" code
	PUSH BC ;save on stack
	JP C,fin ;if not double, call usual # inputter
	JP findbl ;else call special routine which expects doubles
strdn2:
	DEC HL
	CALL chrgtr
	JP Z,trmok
	CP 44
	JP NZ,trmnok ;ended properly?
trmok:
	EX (SP),HL
	DEC HL ;look at terminator
	CALL chrgtr ;and set up condition codes
	JP NZ,lopdt2 ;not ending, check for comma
					;and get another variable
					;to fill with data

	POP DE ;pop off the pointer into data
	LD A,(flginp) ;fetch the statement type flag
	OR A
					;input statement
	EX DE,HL
	JP NZ,resfin ;update datptr
	PUSH DE ;save the text pointer
finprg:	POP HL ;get back the text pointer
	JP finprt
;
; the search for data statments is made by using the execution code
; for data to skip over statements. the start word of each statement
; is compared with $data. each new line number
; is stored in datlin so that if an error occurs while reading
; data the error message will give the line number of the 
; ill-formatted data
;
datlop:	CALL data
datfnd:	OR A
	JP NZ,nowlin
	INC HL
	LD A,(HL)
	INC HL
	OR (HL)
	LD E,errod ;no data is error errod
	JP Z,error ;if so complain
	INC HL ;skip past line #
	LD E,(HL) ;get data line #
	INC HL
	LD D,(HL)
	EX DE,HL
	LD (datlin),HL
	EX DE,HL ;restore text pointer
nowlin:	CALL chrgtr ;get the statement type
	CP $data ;is is "DATA"?
	JP NZ,datlop ;not data so look some more
	JP datbk ;continue reading



	page

	subttl	formula evaluation code

;
; the formula evaluator starts with
; [h,l] pointing to the first character of the formula.
; at the end [h,l] points to the terminator.
; the result is left in the fac.
; on return [a] does not reflect the terminating character
;
; the formula evaluator uses the operator table (optab)
; to determine precedence and dispatch addresses for
; each operator.
; a temporary result on the stack has the following format
;
; the address of 'RETAOP' -- the place to return on completion
; of operator application
;
; the floating point temporary result
;
; the address of the operator rountine
;
; the precedence of the operator
;
; total 10 bytes
;
frmeql:	CALL synchr
	db	equltk ;check for equal sign
	JP frmevl ;evaluate formula and return
frmprn:	CALL synchr
	db	'(' ;get paren before formula
frmevl:	DEC HL ;back up character pointer
frmchk:	LD D,0 ;initial dummy precedence is 0
lpoper:	PUSH DE ;save precedence
	LD C,1 ;extra space needed for return address
	CALL getstk ;make sure there is room for recursive calls
	CALL eval ;evaluate something
					;reset overflow printing back to normal
	XOR A ;(set to 1 at fundsp to suppress
	LD (flgovc),A ;multiple overflow messages)
tstop:	LD (temp2),HL ;save text pointer
retaop:	LD HL,(temp2) ;restore text ptr
	POP BC ;pop off the precedence of oldop
notstv:	LD A,(HL) ;get next character
	LD (temp3),HL ;save updated character pointer
	CP greatk ;is it an operator?
	RET C ;no, all done (this can result in operator
					;application or actual return)
	CP lesstk+1 ;some kind of relational?
	JP C,dorels ;yes, do it
	SUB plustk ;subtraxdct offset for first arithmetic
	LD E,A ;must multiply by 3 since
					;optab entries are 3 long
	JP NZ,ntplus ;not addition op
	LD A,(valtyp) ;see if left part is string
	CP 3 ;see if its a string
	LD A,E ;refetch op-value
	JP Z,cat ;must be cat
ntplus:
	CP lstopk ;higher than the last op?
	RET NC ;yes, must be terminator
	LD HL,optab ;create index into optab
	LD D,0 ;make high byte of offset=0
	ADD HL,DE ;add in calculated offset
	LD A,B ;[a] gets old precedence
	LD D,(HL) ;remember new precedence
	CP D ;old-new
	RET NC ;must apply old op
					;if has greater or = precedence
					;new operator

	PUSH BC ;save the old precedence
	LD BC,retaop ;put on the address of the
	PUSH BC ;place to return to after operator application
	LD A,D ;see if the operator is exponentiation
	CP 127 ;which has precedence 127
	JP Z,expstk ;if so, "FRCSNG" and make a special stack entry
	CP 81 ;see if the operator is "AND" or "OR"
	JP C,andord ;and if so "FRCINT" and
					;make a special stack entry
	AND 254 ;make 123 and 122 both map to 122
	CP 122 ;make a special check for "MOD" and "IDIV"
	JP Z,andord ;if so, coerce arguments to integer
; this code pushes the current value in the fac
; onto the stack, except in the case of strings in which it calls
; type mismatch error. [d] and [e] are preserved.
;
numrel:	LD HL,faclo ;save the value of the fac
pusval:	LD A,(valtyp) ;find out what type of value we are saving
	SUB 3 ;setup the condition codes
					;set zero for strings
	JP Z,tmerr
	OR A ;set parity -- carry unaffected since off
	LD C,(HL)
	INC HL
	LD B,(HL)
	PUSH BC ;push faclo+0,1 on the stack
	JP M,vpushd ;all done if the data was an integer
	INC HL
	LD C,(HL)
	INC HL
	LD B,(HL)
	PUSH BC ;push fac-1,0 on the stack
	JP PO,vpushd ;all done if we had a sng
	LD HL,dfaclo ;5.21: no inx h - we have a double precison number
	LD C,(HL) ;push its 4 lo bytes on the stack
	INC HL
	LD B,(HL)
	INC HL
	PUSH BC
	LD C,(HL)
	INC HL
	LD B,(HL)
	PUSH BC ;user-defined functions require that the
					;[h,l] returned points at the last value
					;byte and not beyond it
vpushd:
	ADD 3 ;fix [a] to be the valtyp of the number
					;just pushed on the stack
	LD C,E ;[c]=operator number
	LD B,A ;[b]=type of value on the stack
	PUSH BC ;save these things for applop
	LD BC,applop ;general operator application
					;routine -- does type conversions
fintmp:	PUSH BC ;save place to go
	LD HL,(temp3) ;reget the text pointer
	JP lpoper ;push on the precedence and read more formula
dorels:	LD D,0 ;assume no relation ops
					;also setup the high order of the index into optab
loprel:	SUB greatk ;is this one relation?
	JP C,finrel ;relations all through
nmrel	set	lesstk-greatk+1
	CP nmrel ;is it really relational?
	JP NC,finrel ;no just big
	CP 1 ;set up bits by mapping
	RLA ;0 to 1 1 to 2 and 2 to 4
	XOR D ;bring in the old bits
	CP D ;make sure result is bigger
	LD D,A ;save the mask
	JP C,snerr ;don'T ALLOW TWO OF THE SAME
	LD (temp3),HL ;save character pointer
	CALL chrgtr ;get the next candidate
	JP loprel
;
; for exponentiation we want to force the current value in the fac
; to be single precision. when application time comes we force
; the right hand operand to single precision as well
;
expstk:	CALL frcsng ;coerce left hand operand
	CALL pushf ;put it on the stack
	LD BC,fpwrq ;place to coerce right hand
					;operand and do exponentiation
	LD D,127 ;restore the precedence
	JP fintmp ;finish entry and evaluate more formula
;
; for "AND" and "OR" and "\" and "MOD" we want to force the current value
; in the fac to be an integer, and at application time force the right
; hand operand to be an integer
;
andord:	PUSH DE ;save the precedence
	CALL frcint
	POP DE ;[d]=precedence
	PUSH HL ;push the left hand operand
	LD BC,dandor ;"AND" and "OR" doer
	JP fintmp ;push on this address,precedence
					;and continue evaluation
;
; here to build an entry for a relational operator
; strings are treated specially. numeric compares are different
; from most operator entries only in the fact that at the
; bottom instead of having retaop, docmp and the relational
; bits are stored. strings have strcmp,the pointer at the string descriptor,
; docmp and the relational bits.
;
finrel:	LD A,B ;[a]=old precedence
	CP 100 ;relationals have precedence 100
	RET NC ;apply earlier operator if it has
					;higher precedence
	PUSH BC ;save the old precedence
	PUSH DE ;save [d]=relational bits
	LD DE,0+256*100+opcnt ;[d]=precedence=100
					;[e]=dispatch offset for
					;compares in applop=4
					;in case this is a numeric compare
	LD HL,docmp ;routine to take compare routine result
					;and relational bits and return the answer
	PUSH HL ;does a jmp to retaop when done
	CALL getypr ;see if we have a numeric compare
	JP NZ,numrel ;yes, build an applop entry
	LD HL,(faclo) ;get the pointer at the string descriptor
	PUSH HL ;save it for strcmp
	LD BC,strcmp ;string compare routine
	JP fintmp ;push the address, reget the text pointer
					;save the precedence and scan
					;more of the formula
;
; applop is returned to when it is time to apply an arithmetic
; or numeric comparison operation.
; the stack has a double byte entry with the operator
; number and the valtyp of the value on the stack.
; applop decides what value level the operation
; will occur at, and converts the arguments. applop
; uses different calling conventions for each value type.
; integers: left in [d,e] right in [h,l]
; singles:  left in [b,c,d,e] right in the fac
; doubles:  left in fac   right in arg
;
applop:	POP BC ;[b]=stack operand value type
					;[c]=operator offset
	LD A,C ;save in memory since the stack will be busy
	LD (oprtyp),A ;a ram location
	LD A,(valtyp) ;get valtyp of fac
	CP B ;are valtypes the same?
	JP NZ,valnsm ;no
	CP 2 ;integer?
	JP Z,intdpc ;yes, dispatch!!
	CP 4 ;single?
	JP Z,sngdpc ;yes, dispatch!!
	JP NC,dbldpc ;must be double, dispatch!!
valnsm:	LD D,A ;save in [d]
	LD A,B ;check for double
	CP 8 ;precision entry on the stack
	JP Z,stkdbl ;force fac to double
	LD A,D ;get valtype of fac
	CP 8 ;and if so, convert the stack operand
	JP Z,facdbl ;to double precision
	LD A,B ;see if the stack entry is single
	CP 4 ;precision and if so, convert
	JP Z,stksng ;the fac to single precision
	LD A,D ;see if the fac is single precision
	CP 3 ;and if so convert the stack to single
	JP Z,tmerr ;blow up on right hand string operand
	JP NC,facsng ;precision
					;note: the stack must be integer at this point
intdpc:	LD HL,intdsp ;integer integer case
	LD B,0 ;special dispatch for speed
	ADD HL,BC ;[h,l] points to the address to go to 
	ADD HL,BC
	LD C,(HL) ;[b,c]=routine address
	INC HL
	LD B,(HL)
	POP DE ;[d,e]=left hand operand
	LD HL,(faclo) ;[h,l]=right hand operand
	PUSH BC ;dispatch
	RET
;
; the stack operand is double precision, so
; the fac must be forced to double precision, moved into arg
; and the stack value poped into the fac
;
stkdbl:	CALL frcdbl ;make the fac double precision
dbldpc:	CALL vmovaf ;move the fac into arg
	POP HL ;pop off the stack operand into the fac
	LD (dfaclo+2),HL
	POP HL
	LD (dfaclo),HL ;store low bytes away
sngdbl:	POP BC
	POP DE
					;pop off a four byte value
	CALL movfr ;into the fac
setdbl:	CALL frcdbl ;make sure the left operand is
					;double precision
	LD HL,dbldsp ;dispatch to a double precision routine
dodsp:	LD A,(oprtyp) ;recall which operand it was
	RLCA ;create a dispatch offset, since
					;table addresses are two bytes
	ADD L ;add low byte of address
	LD L,A ;save back
	ADC H ;add high byte
	SUB L ;subtract low
	LD H,A ;result back
	LD A,(HL) ;get the address
	INC HL
	LD H,(HL)
	LD L,A
	JP (HL) ;and perform the operation, returning
					;to retaop, except for compares which
					;return to docmp
;
; the fac is double precision and the stack is either
; integer or single precision and must be converted
; 
facdbl:	LD A,B ;5.21: get stack value type into A
	PUSH AF ;save the stack value type
	CALL vmovaf ;move the fac into arg
	POP AF ;pop the stack value type into [a]
	LD (valtyp),A ;put it in valtyp for the force
					;routine
	CP 4 ;see if its single, so we know
					;how to pop the value off
	JP Z,sngdbl ;it'S SINGLE PRECISION
					;so do a popr / call movfr
	POP HL ;pop off the integer value
	LD (faclo),HL ;save it for conversion
	JP setdbl ;set it up
;
; this is the case where the stack is single precision
; and the fac is either single precision or integer
;
stksng:	CALL frcsng ;convert the fac if necessary
sngdpc:	POP BC
	POP DE
					;put the left hand operand in the registers
sngdo:	LD HL,sngdsp ;setup the dispatch address
					;for the single precision operator routines
	JP dodsp ;dispatch
;
; this is the case where the fac is single precision and the stack
; is an integer. 
;
facsng:	POP HL ;pop off the integer on the stack
	CALL pushf ;save the fac on the stack
	CALL consih ;convert [h,l] to a single precision
					;number in the fac
	CALL movrf ;put the left hand operand in the registers
	POP HL ;restore the fac
	LD (fac-1),HL ;from the stack
	POP HL
	LD (faclo),HL
	JP sngdo ;perform the operation
;
; here to do integer division. since we want 1/3 to be
; .333333 and not zero we have to force both arguments
; to be single-precision floating point numbers
; and use fdiv
;
intdiv:	PUSH HL ;save the right hand argument
	EX DE,HL ;[h,l]=left hand argument
	CALL consih ;convert [h,l] to a single-precision
					;number in the fac
	POP HL ;get back the right hand argument
	CALL pushf ;push the converted left hand argument
					;onto the stack
	CALL consih ;convert the right hand argument to a
					;single precision number in the fac
	JP fdivt ;do the division after poping into the
					;registers the left hand argument

	page
	subttl	eval - evaluate variable, constant, function call
eval:
	CALL chrgtr
	JP Z,moerr ;test for missing operand - if none give error
	JP C,fin ;if numeric, interpret constant
	CALL islet2 ;variable name?
	JP NC,isvar ;an alphabetic character means yes
	CP dblcon+1 ;is it an embeded constant
	JP C,jfccsc ;5.21: go to trampoline (call confac, then conscn)
	INC A ;is it a function call (preceded by 377)
	JP Z,isfun ;yes, do it
	DEC A ;fix a back
	CP plustk ;ignore "+"
	JP Z,eval
	CP minutk ;negation?
	JP Z,domin
	CP 34 ;string constant?
	JP Z,strlti ;if so build a descriptor in a temporary
					;descriptor location and put a pointer to the
					;descriptor in faclo.
	CP nottk ;check for "NOT" operator
	JP Z,noter
	CP '&' ;octal constant?
	JP Z,octcns
	CP erctk
	JP NZ,nterc ;no, try other possibilities
	CALL chrgtr ;grab following char
					;is it a disk error call?
	LD A,(errflg) ;get the error code.
					;"CPI OVER NEXT BYTE
ntderc:	PUSH HL ;save text pointer
	CALL sngflt ;return the value
	POP HL ;restore text pointer
	RET ;all done.

nterc:	CP erltk ;error line number variable.
	JP NZ,nterl ;no, try more things.
	CALL chrgtr ;get following character
	PUSH HL ;save text pointer
	LD HL,(errlin) ;get the offending line #
	CALL ineg2 ;float 2 byte unsinged int
	POP HL ;restore text pointer
	RET ;return
nterl:
	CP $varpt ;varptr call?
	JP NZ,ntvarp ;no
	CALL chrgtr ;eat char after
	CALL synchr
	db	'(' ;eat left paren
	CP '#' ;want pointer to file?
	JP NZ,nvrfil ;no, must be variable
	CALL gtbytc ;read file #
	PUSH HL ;save text ptr
	CALL getptr ;get ptr to file
	POP HL ;restore text ptr
	JP varret
nvrfil:
	CALL ptrglb ;5.21: call via stub for return addr
varret:	CALL synchr
	db	')' ;eat right paren
	PUSH HL ;save text pointer
	EX DE,HL ;get value to return in [h,l]
	LD A,H ;make sure not undefined var
	OR L ;set cc'S. ZERO IF UNDEF
	JP Z,fcerr ;all over if undef (dont want
					;user poking into zero if he'S
					;too lazy to check
	CALL makint ;make it an int
	POP HL ;restore text pointer
	RET
ntvarp:
	CP usrtk ;user assembly language routine??
	JP Z,usrfn ;go handle it
	CP insrtk ;is it the instr function??
	JP Z,instr ;dispatch
	CP $inkey ;inkey$ function?
	JP Z,inkey ;go do it
	CP $strin ;string function?
	JP Z,strng$ ;yes, go do it
	CP $input ;fixed length input?
	JP Z,fixinp ;yes
	CP fntk ;user-defined function?
	JP Z,fndoer
					;numbered characters allowed
					;so there is no need to check
					;the upper bound
; only possibility left is a formula in parentheses
parchk:	CALL frmprn ;recursively evaluate the formula
	CALL synchr
	db	')'
	RET
domin:
	LD D,125 ;a precedence below ^
					;but above all else
	CALL lpoper ;so ^ greater than unary minus
	LD HL,(temp2) ;get text pointer
	PUSH HL
	CALL vneg
labbck:;functions that don'T RETURN
					;string values come back here
	POP HL
	RET
isvar:	CALL ptrget ;get a pointer to the
					;variable in [d,e]
retvar:	PUSH HL ;save the text pointer
	EX DE,HL ;put the pointer to the variable value
					;into [h,l]. in the case of a string
					;this is a pointer to a descriptor and not
					;an actual value
	LD (faclo),HL ;in case it'S STRING STORE THE POINTER
					;to the descriptor in faclo.
	CALL getypr ;for strings we just leave
	CALL NZ,vmovfm ;a pointer in the fac
					;the fac using [h,l] as the pointer.
	POP HL ;restore the text pointer
	RET
makupl:	LD A,(HL) ;get char from memory
makups:	CP 'A'+40o ;is it lower case range
	RET C ;less
	CP 'Z'+41o ;greater
	RET NC ;test
	AND 137o ;make upper case
	RET ;done
cnsget:
	CP '&' ;octal perhaps?
	JP NZ,linget
octcns:	LD DE,0 ;initialize to zero and ignore overflow
	CALL chrgtr ;get first char
	CALL makups ;make upper if nesc.
	CP 'O' ;octal?
	JP Z,lopoct ;if so, do it
	CP 'H' ;hex?
	JP NZ,lopoc2 ;then do it
	LD B,5 ;init digit count
lophex:	INC HL ;bump pointer
	LD A,(HL) ;get char
	CALL makups ;make upper case
	CALL islet2 ;fetch char, see if alpha
	EX DE,HL ;save [h,l]
	JP NC,alptst ;yes, make sure legal hec
	CP '9'+1 ;is it bigger than largest digit?
	JP NC,octfin ;yes, be forgiving & return
	SUB '0' ;convert digit, make binary
	JP C,octfin ;be forgiving if not hex digit
	JP nxthex ;add in offset
alptst:	CP 'F'+1 ;is it legal hex?
	JP NC,hexfin ;yes, terminate
	SUB 'A'-10 ;make binary value
nxthex:	ADD HL,HL ;shift right four bits
	ADD HL,HL
	ADD HL,HL
	ADD HL,HL
	OR L ;or on new digit
	LD L,A ;save back
	EX DE,HL ;5.21: get text pointer back first
	DEC B ;too many digits?
	JP NZ,lophex ;keep eating
	JP overr ;yup.


lopoc2:	DEC HL ;reget last character
lopoct:	CALL chrgtr ;read a digit
	EX DE,HL ;result into [h,l]
	JP NC,octfin ;out of digits means done
	CP '8' ;is this an octal digit
	JP NC,snerr ;no, too bad you will lose
	LD BC,overr ;where to go on overflow error
	PUSH BC ;save addr on stack
	ADD HL,HL ;multiply by eight
	RET C ;overflow error
	ADD HL,HL
	RET C ;overflow error
	ADD HL,HL
	RET C ;overflow error
	POP BC ;get rid of overr addr
	LD B,0 ;setup to add [b,c]
	SUB '0'
	LD C,A
	ADD HL,BC ;add in the digit
	EX DE,HL ;put text pointer back in [h,l]
	JP lopoct ;scan more digits
hexfin:
octfin:
hocfin:
	CALL makint ;save as an integer
	EX DE,HL ;[h,l]-text pointer
	RET
isfun:
	INC HL ;bump source text pointer
	LD A,(HL) ;get the actual token for fn
	SUB onefun ;make into offset
	CP $rnd-onefun ;is it rnd?
	JP NZ,ntmrnd ;if not no need to check monadic
	PUSH HL ;save text pointer
	CALL chrgtr ;see if next char is "("
	CP '('
	POP HL ;get back the old text pointer
	JP NZ,rndmon ;handle monadic case
	LD A,$rnd-onefun
ntmrnd:
	LD B,0
	RLCA ;multiply by 2
	LD C,A
	PUSH BC ;save the function # on the stack
	CALL chrgtr
	LD A,C ;look at function #
numgfn	set	2*midtk-2*onefun+1
	CP numgfn ;is it past lasnum?
	JP NC,oknorm ;no, must be a normal function
;
; most functions take a single argument.
; the return address of these functions is a small routine
; that checks to make sure valtyp is 0 (numeric) and pops off
; the text pointer. so normal functions that return string results (i.e. chr$)
; must pop off the return address of labbck, and pop off the
; text pointer and then return to frmevl.
;
; the so called "FUNNY" functions can take more than one argument.
; the first of which must be string and the second of which
; must be a number between 0 and 256. the text pointer is
; passed to these functions so additional arguments
; can be read. the text pointer is passed in [d,e].
; the close parenthesis must be checked and return is directly
; to frmevl with [h,l] setup as the text pointer pointing beyond the ")".
; the pointer to the descriptor of the string argument
; is stored on the stack underneath the value of the integer
; argument (2 bytes)
;
; first argument always string -- second integer
	CALL frmprn ;eat open paren and first arg
	CALL synchr
	db	44 ;two args so comma must delimit
	CALL chkstr ;make sure the first one was string
	EX DE,HL ;[d,e]=txtptr
	LD HL,(faclo) ;get ptr at string descriptor
	EX (SP),HL ;get function #
					;save the string ptr
	PUSH HL ;put the function # on
	EX DE,HL ;[h,l]=txtptr
	CALL getbyt ;[e]=value of formula
	EX DE,HL ;text pointer into [d,e]
					;[h,l]=int value of second argument
	EX (SP),HL ;save int value of second arg
					;[h,l]=function number
	JP fingo ;dispatch to function
oknorm:
	CALL parchk ;check out the argument
					;and make sure its followed by ")"
	EX (SP),HL ;[h,l]=function # and save text pointer
;
; check if special coercion must be done for one of the transcendental
; functions (rnd, sqr, cos, sin, tan, atn, log, and exp)
; these functions do not look at valtyp, but rather assume the
; argument passed in the fac is single precision, so frcsng
; must be called before dispatching to them.
;
	LD A,L ;[a]=function number
botcon	set	(sqrtk-onefun)*2
	CP botcon ;less than square root?
	JP C,notfrf ;don'T FORCE THE ARGUMENT
topcon	set	(atntk-onefun)*2+1
	CP topcon ;bigger than arc-tangent?
	PUSH HL ;save the function number
	CALL C,frcsng ;if not, force fac to single-precision
	POP HL ;restore the function number
notfrf:
	LD DE,labbck ;return address
	PUSH DE ;make them really come back
	LD A,1 ;function should only print overflow once
	LD (flgovc),A
fingo:	LD BC,fundsp ;function dispatch table
dispat:	ADD HL,BC ;add on the offset
	LD C,(HL) ;faster than pushm
	INC HL
	LD H,(HL)
	LD L,C
	JP (HL) ;go perform the function


; the folowing routine is called from fin in f4
; to scan leading signs for numbers. it was moved
; to f3 to eliminate byte externals
minpls:
	DEC D ;set sign of exponent flag
	CP minutk ;negative exponent?
	RET Z
	CP '-'
	RET Z
	INC D ;no, reset flag
	CP '+'
	RET Z
	CP plustk ;ignore "+"
	RET Z
	DEC HL ;check if last character was a digit
	RET ;return with non-zero set
	page
	subttl	more formula evaluation - logical, relational ops
docmp:	INC A ;setup bits
	ADC A ;4=less 2=equal 1=greater
	POP BC ;what did he want?
	AND B ;any bits match?
	ADD 255 ;map 0 to 0
	SBC A ;and all others to 377
	CALL conia ;convert [a] to an integer signed
	JP retapg ;return from operator application
					;place so the text pointer
					;will get set up to what it was
					;when lpoper returned.
noter:	LD D,90 ;"NOT" has precedence 90, so
	CALL lpoper ;formula evaluation is entered with a dummy
					;entry of 90 on the stack
	CALL frcint ;coerce the argument to integer
	LD A,L ;complement [h,l]
	CPL
	LD L,A
	LD A,H
	CPL
	LD H,A
	LD (faclo),HL ;update the fac
	POP BC ;frmevl, after seeing the precedence
					;of 90 thinks it is applying an operator
					;so it has the text pointer in temp2 so

retapg:	JP retaop ;return to refetch it
getypr:	LD A,(valtyp) ;replacement for "GETYPE" rst
	CP 8
;
; continuation of getype rst
;

cgetyp:	JP NC,ncase ;split off no carry case
	SUB 3 ;set a correctly
	OR A ;now set logical'S OK
	SCF ;carry must be set
	RET ;all done

ncase:	SUB 3 ;subtract correctly
	OR A ;set cc'S PROPERLY
	RET ;return

;
; dandor applies the "AND" and "OR" operators
; and should be used to implement all logical operators.
; whenever an operator is applied, its precedence is in [b].
; this fact is used to distinguish between "AND" and "OR".
; the right hand argument is coerced to integer, just as
; the left hand one was when it was pushed on the stack.
;
dandor:	LD A,B ;5.21: get precedence into A
	PUSH AF ;save the precedence "OR"=70
	CALL frcint ;coerce right hand argument to integer
	POP AF ;get back the precedence to distinguish
					;"AND" and "OR"
	POP DE ;pop off the left hand argument
	CP 122 ;is the operator "MOD"?
	JP Z,imod ;if so, use monte'S SPECIAL ROUTINE
	CP 123 ;is the operator "IDIV"?
	JP Z,idiv ;let monte handle it
	LD BC,givint ;place to return when done
	PUSH BC ;save on stack
	CP 70 ;set zero for "OR"
	JP NZ,notor
	LD A,E ;setup low in [a]
	OR L
	LD L,A
	LD A,H
	OR D
	RET ;return the integer [a,l]
notor:
	CP 80 ;and?
	JP NZ,notand
	LD A,E
	AND L
	LD L,A
	LD A,H
	AND D
	RET ;return the integer [a,l]

notand:	CP 60 ;xor?
	JP NZ,notxor ;no
	LD A,E
	XOR L
	LD L,A
	LD A,H
	XOR D
	RET

notxor:	CP 50 ;eqv?
	JP NZ,noteqv ;no
	LD A,E ;low part
	XOR L
	CPL
	LD L,A
	LD A,H
	XOR D
	CPL
	RET
;for "IMP" use a imp b = not(a and not(b))
noteqv:	LD A,L ;must be "IMP"
	CPL
	AND E
	CPL
	LD L,A
	LD A,H
	CPL
	AND D
	CPL
	RET
	page
;
; this routine subtracts [d,e] from [h,l]
; and floats the result leaving it in fac.
;
givdbl:	LD A,L ;[h,l]=[h,l]-[d,e]
	SUB E
	LD L,A
	LD A,H
	SBC D
	LD H,A ;save high byte in [h]
	JP ineg2 ;float 2 byte unsigned int
lpos:	LD A,(lptpos)
	JP sngfli
pos:
	LD A,(ttypos) ;get teletype position
					;see where we are
sngfli:

					;in adds version tab positions start at column 1.
	INC A
sngflt:	LD L,A ;make [a] an unsigned integer
	XOR A
givint:	LD H,A
	JP makint
	page
	subttl	user defined (usr) assembly language function code
usrfn:	CALL scnusr ;scan the usr#
	PUSH DE ;save pointer
	CALL parchk ;eat left paren and formula
	EX (SP),HL ;save text pointer & get index into usrtab
	LD E,(HL) ;5.21: get dispatch adress into DE
	INC HL ;bump pointer
	LD D,(HL) ;pick up 2nd byte of address
	LD HL,pophrt ;get address of pop h ret
	PUSH HL ;push it on
	PUSH DE ;save address of usr routine
	LD A,(valtyp) ;get argument type in [a]
	PUSH AF ;save valtyp
	CP 3 ;string??
	CALL Z,frefac ;free it up
	POP AF ;get back valtyp
	EX DE,HL ;move possible desc. pointer to [d,e]
	LD HL,faclo ;pointer to fac in [h,l]
	RET ;call usr routine
scnusr:	CALL chrgtr ;get a char
	LD BC,0 ;assume usr0
	CP onecon+10 ;single byte int expected
	JP NC,noargu ;no, must be defaulting to usr0
	CP onecon ;is it smaller than onecon
	JP C,noargu ;yes, assume trying to default to usr0
usercn:	CALL chrgtr ;scan past next char
	LD A,(conlo) ;get value of 1 byter
					;yup
	OR A ;make sure carry is off
	RLA ;multiply by 2
	LD C,A ;save offset in [c]
noargu:	EX DE,HL ;save text pointer in [d,e]
	LD HL,usrtab ;get start of table
	ADD HL,BC ;add on offset
	EX DE,HL ;restore text pointer, address to [d,e]
	RET ;return from scan routine

defusr:	CALL scnusr ;scan the usr name
	PUSH DE ;save pointer to usrtab entry
	CALL synchr
	db	equltk ;must have equal sign
	CALL frmhqi ;5.21: get the address (full 16-bit range)
	EX (SP),HL ;text pointer to stack, get address
	LD (HL),E ;save usr call address
	INC HL ;bump pointer
	LD (HL),D ;save high byte of address
	POP HL ;restore text pointer
	RET ;return to newstt

	page
	subttl	simple-user-defined-function code
;
; in the 8k version (see later comment for extended)
; note only single arguments are allowed to functions
; and functions must be of the single line form:
; def fna(x)=x^2+x-2
; no strings can be involved with these functions
;
; idea: create a funny simple variable entry
; whose first character (second word in memory)
; has the 200 bit set.
; the value will be:
;
; 	a txtptr to the formula
;	the name of the parameter variable
;
; function names can be like "FNA4"
;

def:
	CP usrtk ;defining the call address of usr routine?
	JP Z,defusr ;yes, do it
	CALL getfnm ;get a pointer to the function name
	CALL errdir ;def is "ILLEGAL DIRECT"
					;memory, restore the txtptr
					;and go to "DATA" skipping the
					;rest of the formula
	EX DE,HL ;[d,e] = the text pointer after the function
					;name and [h,l] = pointer at place to store
					;value of the function variable
	LD (HL),E ;save the text pointer as the value
	INC HL
	LD (HL),D
	EX DE,HL ;restore the text pointer to [h,l]
	LD A,(HL) ;get next char
	CP '(' ;does this function have args?
	JP NZ,data ;no
	CALL chrgtr
scnlis:	CALL ptrget ;get pointer to dummy var(create var)
	LD A,(HL) ;get terminator
	CP ')' ;end of arg list?
	JP Z,data ;yes
	CALL synchr
	db	44 ;"," must follow then
	JP scnlis

fndoer:	CALL getfnm ;get a pointer to
	LD A,(valtyp) ;find out what kind of function it is
	OR A ;push this [a] on with a psw with carry off
					;so that when values are being popped off
					;and restored to parameters we will know
					;when to stop
					;when a valtyp is popped off with
					;carry off
	PUSH AF ;save so that the final result will
					;be coerced to the function type
	LD (temp2),HL ;save the text pointer that points past
					;the function name in the call
	EX DE,HL ;[h,l]=a pointer to the value of function
	LD A,(HL) ;[h,l]=value of the function
	INC HL ;which is a text pointer at the formal
	LD H,(HL) ;parameter list in the definition
	LD L,A
	LD A,H ;5.21: test for zero text pointer
	OR L ;a zero text pointer means the function
					;was never defined
	JP Z,uferr ;if so, given an "UNDEFINED FUNCTION" error
	LD A,(HL) ;see if there are any parameters
	CP '(' ;parameter list starts with "(""
	JP NZ,finvls ;skip over parameter setup
	CALL chrgtr ;go past the "("
	LD (temp3),HL ;save the text pointer to the start of the
	EX DE,HL ;parameter list.
	LD HL,(temp2) ;now get the text-pointer from the call
					;which is pointing just past the
					;function name at the argument list
	CALL synchr
	db	'(' ;make sure the argument list is there
	XOR A ;indicate end of values to assign
	PUSH AF
	PUSH HL ;save the callers text pointer
	EX DE,HL ;get the pointer to the beginning of the
					;parameter list
asgmor:	LD A,128 ;outlaw arrays when scanning
	LD (subflg),A ;parameters
	CALL ptrget ;read a parameter
	EX DE,HL ;[d,e]=parameter list text,[h,l]=variable pointer
	EX (SP),HL ;save the variables position and
					;get the pointer at the arg list
	LD A,(valtyp) ;and its type (for coercion)
	PUSH AF
	PUSH DE ;save the text pointer into the parameter
	CALL frmevl ;evaluate the argument
	LD (temp2),HL ;save the argument list pointer
	POP HL ;and the parameter list pointer
	LD (temp3),HL
	POP AF ;get the value type
	CALL docnvf ;coerce the argument
	LD C,4 ;make sure there is room for the value
	CALL getstk
	LD HL,0-8 ;save eight places
	ADD HL,SP
	LD SP,HL
	CALL vmovmf ;put value into reserved place in stack
	LD A,(valtyp) ;save type for assignment
	PUSH AF
	LD HL,(temp2) ;reget the argument list pointer
	LD A,(HL) ;see what comes after the argument formula
	CP ')' ;is the argument list ending?
	JP Z,popasg ;make sure the argument list also ended
	CALL synchr
	db	54o ;skip over argument comma
	PUSH HL ;save the argument list text pointer
	LD HL,(temp3) ;get the text pointer into the defintion'S
					;parameter list
	CALL synchr
	db	54o ;skip over the parameter list comma
	JP asgmor ;and bind the rest of the parameters
popas2:	POP AF ;if assignment is sucessful update prmln2
	LD (prmln2),A ;indicate new variable is in place
popasg:	POP AF ;get the value type
	OR A
	JP Z,finasg ;zero means no more left to pop and assign
	LD (valtyp),A
	LD HL,0 ;point into stack
	ADD HL,SP ;to get saved value
	CALL vmovfm ;put value into fac
	LD HL,0+8 ;free up stack area
	ADD HL,SP
	LD SP,HL
	POP DE ;get place to store to
	LD L,3 ;calculate the size of the looks (name)
lpsizl:	INC L ;increment size
	DEC DE ;point at previous character
	LD A,(DE) ;see if it is the length or another character
	OR A
	JP M,lpsizl ;high bit indicates still part of name
	DEC DE ;back up over looks
	DEC DE
	DEC DE
	LD A,(valtyp) ;get size of value
	ADD L ;add on size of name
	LD B,A ;save total length in [b]
	LD A,(prmln2) ;get current size of block
	LD C,A ;save in [c]
	ADD B ;get potential new size
	CP prmsiz ;can'T EXCEED ALLOCATED STORAGE
	JP NC,fcerr
	PUSH AF ;save new size
	LD A,L ;[a]=size of name
	LD B,0 ;[b,c]=size of parm2
	LD HL,parm2 ;base of place to store into
	ADD HL,BC ;[h,l]=place to start the new variable
	LD C,A ;[b,c]=length of name of variable
	CALL bctran ;put in the new name
	LD BC,popas2 ;place to return after assignment
	PUSH BC
	PUSH BC ;save extra entry on stack
	JP letcn4 ;perform assignment on [h,l] (extra pop d)
finasg:	LD HL,(temp2) ;get argument list pointer
	CALL chrgtr ;skip over the closing parenthesis
	PUSH HL ;save the argument text pointer
	LD HL,(temp3) ;get the parameter list text pointer
	CALL synchr
	db	')' ;make sure the parameter list
					;ended at the same time
	db	76q ;skip the next byte with "MVI AL,"
finvls:	PUSH DE ;here when there were no arguments
					;or parameters
					;save the text pointer of the caller
	LD (temp3),HL ;save the text pointer of the function
	LD A,(prmlen) ;push parm1 stuff onto the stack
	ADD 4 ;with prmlen and prmstk (4 bytes extra)
	PUSH AF ;save the number of bytes
	RRCA ;number of two byte entries in [a]
	LD C,A
	CALL getstk ;is there room on the stack?
	POP AF ;[a]=amount to put onto stack
	LD C,A
	CPL ;complement [a]
	INC A
	LD L,A
	LD H,255
	ADD HL,SP
	LD SP,HL ;set up new stack
	PUSH HL ;save the new value for prmstk
	LD DE,prmstk ;fetch data from here
	CALL bctran
	POP HL
	LD (prmstk),HL ;link parameter block for garbage collection
	LD HL,(prmln2) ;now put parm2 into parm1
	LD (prmlen),HL ;set up length
	LD B,H
	LD C,L ;[b,c]=transfer count
	LD HL,parm1
	LD DE,parm2
	CALL bctran
	LD H,A ;clear out parm2
	LD L,A
	LD (prmln2),HL
	LD HL,(funact) ;increment function count
	INC HL
	LD (funact),HL
	LD A,H
	OR L ;set up active flag non-zero
	LD (nofuns),A
	LD HL,(temp3) ;get back the function definition text pointer
;	dcx	h		;detect a multi-line function
;	chrget			;if the definition ends now
;	jz	mulfun		;if ends, its a multi-line function
					;skip over the "=" in the definition
	CALL frmeql ;and evaluate the definition formula
					;can have recursion at this point
	DEC HL
	CALL chrgtr ;see if the statement ended right
	JP NZ,snerr ;this is a cheat, since the line
					;number of the error will be the callers
					;line # instead of the definitions line #
	CALL getypr ;see it the result is a string
	JP NZ,nocprs ;whose descriptor is about to be wiped out
					;because it is sitting in parm1 (this
					; happens it the function is a projection
					; function on a string argument)
	LD DE,dsctmp ;dsctmp is past all the temp area
	LD HL,(faclo) ;get the address of the descriptor
	CALL dcompr
	JP C,nocprs ;result is a temp - no copy nesc
	CALL strcpy ;make a copy in dsctmp
	CALL puttmp ;put result in a temp and make faclo point at it
nocprs:	LD HL,(prmstk) ;get place to restore parm1 from stack
	LD D,H
	LD E,L
	INC HL ;point at length
	INC HL
	LD C,(HL) ;[b,c]=length
	INC HL
	LD B,(HL)
	INC BC ;include extra bytes
	INC BC
	INC BC
	INC BC
	LD HL,prmstk ;place to store into
	CALL bctran
	EX DE,HL ;[d,e]=place to restore stack to
	LD SP,HL
	LD HL,(funact) ;decrease active function count
	DEC HL
	LD (funact),HL
	LD A,H
	OR L ;set up function flag
	LD (nofuns),A
	POP HL ;get back the callers text pointer
	POP AF ;get back the type of the function
docnvf:	PUSH HL ;save the text pointer
	AND 7 ;setup dispatch to force
					;formula type to conform
					;to the variable its being assigned to
	LD HL,frctbl ;table of force routines
	LD C,A ;[b,c]=two byte offset
	LD B,0
	ADD HL,BC
	CALL dispat ;dispatch
	POP HL ;get back the text pointer
	RET
;
; block transfer routine with source in [d,e] destination in [h,l]
; and count in [b,c]. transfer is forward.
;
bctral:	LD A,(DE)
	LD (HL),A
	INC HL
	INC DE
	DEC BC
bctran:	LD A,B
	OR C
	JP NZ,bctral
	RET
;
; subroutine to see if we are in direct mode and
; complain if so
;
errdir:	PUSH HL ;save their [h,l]
	LD HL,(curlin) ;see what the current line is
	INC HL ;direct is 65,535 so now 0
	LD A,H
	OR L ;is it zero now?
	POP HL
	RET NZ ;return if not
	LD E,errid ;"ILLEGAL DIRECT" error
	JP error
;
; subroutine to get a pointer to a function name
;
getfnm:	CALL synchr
	db	fntk ;must start with "FN"
	LD A,128 ;dont allow an array
	LD (subflg),A ;don'T RECOGNIZE THE "(" AS
					;the start of an array refereence
	OR (HL) ;put function bit on
	LD C,A ;get first character into [c]

	JP ptrgt2
	page
	subttl	string functions - left hand side mid$
ismid$:	CP 377o-$end ;lhs mid$?
	JP NZ,snerr ;no, error.
	INC HL ;point to next char
	LD A,(HL) ;get fn descriptor
	INC HL ;5.21: bump pointer first
	CP midtk ;is it mid?
	JP Z,lhsmid ;5.21: yes, go to lhsmid
	JP snerr ;no, error
	page
	subttl	inp, out, wait, console, width
;
; the following functions allow the 
; user full access to the altair i/o ports
; inp(channel#) returns an integer which is the status
; of the channel. out channel#,value puts out the integer
; value on channel #. it is a statement, not a function.
;
fninp:	CALL conint ;get integer channel #
	LD (inpwrd+1),A ;gen inp instr
inpwrd:	IN A,(0) ;the inp instr
	JP sngflt ;sngflt result

fnout:	CALL setio ;get ready
					;do the "OUT" and return
outwrd:	OUT (0),A ;do it
	RET
;
; the wait channel#,mask,mask2 waits until the status
; returned by channel# is non zero when xored with mask2
; and then anded with mask. if mask2 is not present it is assumed
; to be zero.
;
fnwait:	CALL setio ;set up for wait
	PUSH AF ;save the mask
	LD E,0 ;default mask2 to zero
	DEC HL
	CALL chrgtr ;see if the statement ended
	JP Z,notthr ;if no third argument skip this
	CALL synchr
	db	44 ;make sure there is a ","
	CALL getbyt
notthr:	POP AF ;5.21: reget the "AND" mask
	LD D,A ;save mask in D
lopinp:
stainp:	IN A,(0) ;the input instr
	XOR E ;xor with mask2
	AND D ;5.21: and with mask in D
	JP Z,lopinp ;loop until result is non-zero
					;note: this loop cannot be control-c'ED
					;unless the wait is being done on channel
					;zero. however a restart at 0 is ok.
	RET
consol:	JP snerr
; this is the width (terminal width) command command
; arg must be .gt. 15 and .lt. 255

width:
	CP $lprin ;width lprint?
	JP NZ,notwlp ;no
	CALL chrgtr ;fetch next char
	CALL getbyt ;get width
	LD (lptsiz),A ;save it
	LD E,A ;5.21: setup E for morcp3
	CALL morcp3 ;compute last comma column
	LD (nlppos),A ;save it
	RET
notwlp:
	CALL getbyt ;get the channel #
	LD (linlen),A ;setup the line length
morcp2:	LD E,A ;5.21: setup E for morcp3
	CALL morcp3
	LD (clmlst),A ;set last comma posit
	RET ;done
morcp3:	SUB clmwid
	JP NC,morcp3
	ADD 2*clmwid
	CPL
	INC A
	ADD E
	RET ;back to newstt
getint:	CALL chrgtr
getin2:	CALL frmevl ;evaluate a formula
intfr2:	PUSH HL ;save the text pointer
	CALL frcint ;convert the formula to an integer in [h,l]
	EX DE,HL ;put the integer into [d,e]
	POP HL ;retsore the text pointer
	LD A,D ;set the condition codes on the high order
	OR A
	RET
setio:	CALL getbyt ;get integer channel number in [a]
	LD (stainp+1),A ;setup "WAIT"
	LD (outwrd+1),A ;setup "OUT"
	CALL synchr
	db	44 ;make sure there is a comma
	JP getbyt
					;"MVI B," around the chrget (mvi ah,)
gtbytc:	CALL chrgtr
getbyt:	CALL frmevl ;evaluate a formula
conint:	CALL intfr2 ;convert the fac to an integer in [d,e]
					;and set the condition codes based
					;on the high order
	JP NZ,fcerr ;wasn'T ERROR
	DEC HL ;actually functions can get here
					;with bad [h,l] but not serious
					;set condition codes on terminator
	CALL chrgtr
	LD A,E ;return the result in [a] and [e]
	RET

	page
	subttl	execute basic program on prom
					;go run it

	page
	subttl	extended list, delete, llist
llist:

					;prtflg=1 for regular list
	LD A,1 ;get non zero value
	LD (prtflg),A ;save in i/o flag (end of lpt)
list:
	POP BC ;get rid of newstt return addr
	CALL scnlin ;scan line range
	PUSH BC ;save pointer to 1st line
	CALL prochk ;dont even list line #
list4:	LD HL,0+65535 ;dont allow ^c to change
	LD (curlin),HL ;continue parameters
	POP HL ;get pointer to line
	POP DE ;get max line # off stack
	LD C,(HL) ;[b,c]=the link pointing to the next line
	INC HL
	LD B,(HL)
	INC HL
	LD A,B ;see if end of chain
	OR C
	JP Z,ready ;last line, stop.
	CALL ptrchk ;5.21: check ptrfil (preserves h)
	CALL Z,iscntc
					;check for control-c
	PUSH BC ;save link
	LD C,(HL) ;push the line #
	INC HL
	LD B,(HL)
	INC HL
	PUSH BC
	EX (SP),HL ;get line # into [h,l]
	EX DE,HL ;get max line in [h,l]
	CALL dcompr ;past last line in range?
	POP BC ;text pointer to [b,c]
	JP C,stprdy ;if past, then done listing.
	EX (SP),HL ;save max on bottom of stack
	PUSH HL ;save link on top
	PUSH BC ;save text pointer back
	EX DE,HL ;get line # in [h,l]
	LD (dot),HL ;save for later edit or list
					;and we want [h,l] on the stack
	CALL linprt ;print as int without leading space
	POP HL
	LD A,(HL) ;get byte from line
	CP 9 ;is it a tab?
	JP Z,nospal ;then dont print space
	LD A,' '
	CALL outdo ;print a space after the line #
nospal:	CALL buflin ;unpack the line into buf
	LD HL,buf ;point at the start of the unpacked characters
	CALL lisprt ;print the line
	CALL crdo ;print crlf
	JP list4 ;go back for next line
lisprt:	LD A,(HL)
	OR A ;set cc
	RET Z ;if =0 then end of line
	CALL outch1 ;output char and check for lf
	INC HL ;incr pointer
	JP lisprt ;print next char

buflin:	LD BC,buf ;get start of text buffer
	LD D,buflen ;get its length into [d]
	XOR A ;set on special char for space insertion
	LD (tempa),A
	CALL prochk ;only proceed if ok
	JP ploop2 ;start here

ploop:	INC BC ;increment deposit ptr.
	INC HL ;advance text ptr
	DEC D ;bump down count
	RET Z ;if buffer full, return
ploop2:	LD A,(HL) ;get char from buf
	OR A ;set cc'S
	LD (BC),A ;save this char
	RET Z ;if end of source buffer, all done.
	CP octcon ;is it smaller than smallest embedded constant?
	JP C,ntembl ;yes, dont treat as one
	CP dblcon+1 ;is it embeded constant?
	LD E,A ;save char in [e]
	JP C,prtvar ;print leading space if nesc.
ntembl:	OR A ;set cc'S
	JP M,ploopr ;reserved word of some kind
	LD E,A ;save char in [e]
	CP '.' ;dot is part of var name
	JP Z,prtvar
	CALL tstanm ;is char alphanumeric
	JP NC,prtvar ;alphanumeric
	XOR A ;make special
	JP plooph
prtvar:	LD A,(tempa) ;what did we do last?
	OR A ;set condition codes
	JP Z,ploopg ;special, never insert space
	INC A ;in reserved word?
	JP NZ,ploopg ;no
	LD A,' ' ;put out space before resword
	LD (BC),A ;store in buffer
	INC BC ;incrment pointer into buffer
	DEC D ;space left?
	RET Z ;no, done
ploopg:	LD A,1 ;store flag saying in var
plooph:	LD (tempa),A
	LD A,E ;get back char we had
	CP octcon ;is it smaller than smallest embedded constant?
	JP C,ploopz ;yes, dont treat as one
	CP dblcon+1 ;is it embeded constant?
	JP C,numlin ;yes, unpack it
ploopz:	LD (BC),A ;make sure byte stored after space
	JP ploop ;store in buffer
ploopr:

	INC A ;set zero if fn token
	LD A,(HL) ;get char back
	JP NZ,ntfntk ;not function just treat normally
	INC HL ;bump pointer
	LD A,(HL) ;get char
	AND 177o ;turn off high bit
ntfntk:	INC HL ;advance to point after
	CP sngqtk ;single quote token?
	JP NZ,ntqttk ;5.21: skip if not sngqtk
	DEC BC ;back up deposit ptr 4 bytes
	DEC BC
	DEC BC
	DEC BC
	INC D ;adjust char count
	INC D
	INC D
	INC D
ntqttk:	CP 0A2h ;5.21: check for token A2
	CALL Z,dcx4bd ;5.21: call dcx4bd if match
	CP 0B4h ;else? (5.21 token value)
	JP NZ,ntqtt1 ;5.21: skip if not else
	LD A,(HL) ;get next byte
	INC HL
	CP 0F2h ;check token
	LD A,0B4h ;restore else value (5.21)
	JP Z,ntqtt1 ;skip if matched
	DEC HL ;back up
ntqtt1:	PUSH HL ;save text ptr.
	PUSH BC ;save deposit ptr.
	PUSH DE ;save char count.
	LD HL,reslst-1 ;get ptr to start of reserved word list
	LD B,A ;save this char in [b]
	LD C,'A'-1 ;init leading char value
ressr3:	INC C ;bump leading char value.
ressr1:	INC HL ;bump pointer into reslst
ressrc:	LD D,H ;save ptr to start of this reswrd
	LD E,L
ressr2:
	LD A,(HL) ;get char from reslst
	OR A ;set cc'S
	JP Z,ressr3 ;if end of this chars table, go back & bump c
	INC HL ;bump source ptr
	JP P,ressr2 ;if not end of this reswrd, then keep looking
	LD A,(HL) ;get ptr to reserved word value
	CP B ;same as the one we search for?
	JP NZ,ressr1 ;no, keep looking.
	EX DE,HL ;save found ptr in [h,l]
	CP $usr ;usr function token?
	JP Z,noispa ;dont insert space
	CP $fn ;is it function token?
noispa:
	LD A,C ;get leading char
	POP DE ;restore line char count
	POP BC ;restore deposit ptr
	LD E,A ;save leading char
	JP NZ,ntfnex ;not "FN" expansion
	LD A,(tempa) ;set cc'S ON TEMPA
	OR A
	LD A,0 ;clear reswrd flag - mark as special
	LD (tempa),A ;set flag
	JP morlnz ;do expansion
ntfnex:
	CP 'Z'+1 ;was it a special char?
	JP NZ,ntspch ;non-special char
	XOR A ;set non-special
	LD (tempa),A
	JP morpur ;print it
ntspch:	LD A,(tempa) ;what did we do last?
	OR A ;special?
	LD A,255 ;flag in reserved word
	LD (tempa),A ;clear flag
morlnz:	JP Z,morln0 ;get char and proceed
	LD A,' ' ;put space in buffer
	LD (BC),A
	INC BC
	DEC D ;any space left in buffer
	JP Z,ppswrt ;no, return
morln0:	LD A,E
	JP morln1 ;continue
morpur:
	LD A,(HL) ;get byte from reswrd
	INC HL ;bump pointer
morlnp:	LD E,A ;save char
morln1:	AND 177o ;and off high order bit for disk & edit
	LD (BC),A ;store this char
	INC BC ;bump ptr
	DEC D ;bump down remaining char count
	JP Z,ppswrt ;if end of line, just return
	OR E ;set cc'S
	JP P,morpur ;end of reswrd?
	CP '('+128 ;spc( or tab( ?
	JP NZ,ntspct ;no
	XOR A ;clear flag
	LD (tempa),A ;to insert space afterwards
ntspct:
	POP HL ;restore source ptr.
	JP ploop2 ;get next char from line

tstanm:	CALL islet2 ;letter?
	RET NC ;yes
	CP '0' ;digit?
	RET C ;too small
	CP '9'+1 ;last digit
	CCF ;make carry right
	RET ;no carry=digit
numlin:	DEC HL ;move pointer back as chrget inx'S
	CALL chrgtr ;scan the constant
	PUSH DE ;save char count
	PUSH BC ;save deposit ptr
	PUSH AF ;save constant type.
	CALL confac ;move constant into fac
	POP AF ;restore constant type
	LD BC,conlin ;put return addr on stack
	PUSH BC ;save it
	CP octcon ;octal constant?
	JP Z,fouto ;print it
	CP hexcon ;hex constant?
	JP Z,fouth ;print in hex
	LD HL,(conlo) ;get line # value if one.
	JP fout ;print remaining possibilities.
conlin:	POP BC ;restore deposit ptr.
	POP DE ;restore char count
	LD A,(consav) ;get saved constant token
	LD E,'O' ;assume octal constant
	CP octcon ;octal constant?
	JP Z,savbas ;yes, print it
	CP hexcon ;hex constant?
	LD E,'H' ;assume so.
	JP NZ,numsln ;not base constant
savbas:
	LD A,'&' ;print leading base indicator
	LD (BC),A ;save it
	INC BC ;bump ptr
	DEC D ;bump down char count
	RET Z ;return if end of buffer
	LD A,E ;get base char
	LD (BC),A ;save it
	INC BC ;bump ptr
	DEC D ;bump down base count
	RET Z ;end of buffer, done
					;[e] set up
numsln:
	LD A,(contyp) ;get type of constant we are
	CP 4 ;is it single or double prec?
	LD E,0 ;no, never print trailing type indicator
	JP C,typset
	LD E,'!' ;assume single prec.
	JP Z,typset ;is contyp=4, was single
	LD E,'#' ;double prec indicator
typset:
	LD A,(HL) ;get leading char
	CP ' ' ;leading space
	CALL Z,inxhrt ;go by it
numsl2:	LD A,(HL) ;get char from number buffer
	INC HL ;bump pointer
	OR A ;set cc'S
	JP Z,numdn ;if zero, all done.
	LD (BC),A ;save char in buf.
	INC BC ;bump ptr
	DEC D ;see if end of buffer
	RET Z ;if end of buffer, return
	LD A,(contyp) ;get type of constant to be printed
	CP 4 ;test for single or double precision
	JP C,numsl2 ;no, was integer
	DEC BC ;pick up saved char
	LD A,(BC) ;easier than pushing on stack
	INC BC ;restore to point where it should
	JP NZ,dblscn ;if double, dont test for embeded "."
	CP '.' ;test for fraction
	JP Z,zere ;if single & embeded ., then dont print !
dblscn:	CP 'D' ;double prec. exponent?
	JP Z,zere ;yes, mark no value type indicator nesc.
	CP 'E' ;single prec. exponent?
	JP NZ,numsl2 ;no, proceed
zere:	LD E,0 ;mark no printing of type indicator
	JP numsl2 ;keep moving number chars into buf

numdn:
	LD A,E ;get flag to indicate whether to insert
	OR A ;a "D" after double prec. #
	JP Z,nod ;no, dont insert it
	LD (BC),A ;save in buffer
	INC BC ;bump pointer
	DEC D ;decrment count of chars left in buffer
	RET Z ;=0, must truncate list of this line.
nod:
	LD HL,(contxt) ;get back text pointer after constant
	JP ploop2 ;get next char
;
; the following code is for the delete range
; command. before the lines are deleted, 'OK'
; is typed.
;
delete:
	CALL scnlin ;scan line range
	PUSH BC
	CALL deptr ;change pointers back to numbers
	POP BC
	POP DE ;pop max line off stack
	PUSH BC ;save pointer to start of deletion
					;for use by chead after fini
	PUSH BC ;save pointer to start of 1st line
	CALL fndlin ;find the last line
	JP NC,fcerrg ;must have a match on the upper bound
	LD D,H ;[d,e] =  pointer at the start of the line
	LD E,L ;beyond the last line in the range
	EX (SP),HL ;save the pointer to the next line
	PUSH HL ;save the pointer to the start of
					;the first line in the range
	CALL dcompr ;make sure the start comes before the end
fcerrg:	JP NC,fcerr ;if not, "ILLEGAL FUNCTION CALL"
	LD HL,reddy ;print "OK" prematurely
	CALL strout
	POP BC ;get pointer to first in [b,c]
	LD HL,fini ;go back to fini when done
	EX (SP),HL ;[h,l]=pointer to the next line
; erase a line from memory
; [b,c]=start of line being deleted
; [d,e]=start of next line
del:
	EX DE,HL ;[d,e] now have the pointer to the line
					;beyond this one
	LD HL,(vartab) ;compactifying to vartab
mloop:	LD A,(DE)
	LD (BC),A ;shoving down to eliminate a line
	INC BC
	INC DE
	CALL dcompr
	JP NZ,mloop ;done compactifying?
	LD H,B
	LD L,C
	LD (vartab),HL
	RET
	page
	subttl	peek and poke
;
; note: in the 8k peek only accepts positive numbers up to 32767
; poke will only take an address up to 32767 , no
; fudging allowed. the value is unsigned.
; in the extended version negative numbers can be
; used to refer to locations higher than 32767.
; the correspondence is given by subtracting 65536 from locations
; higher than 32767 or by specifying a positive number up to 65535.
;
peek:	CALL frqint ;get an integer in [h,l]
	CALL prodir ;dont allow direct if protected file
	LD A,(HL) ;get the value to return
	JP sngflt ;and float it
poke:	CALL frmhqi ;evaluate address, get integer in [d,e]
	PUSH DE ;save address
	CALL prodir ;dont allow direct if protected file
	CALL synchr
	db	',' ;check comma
	CALL getbyt
	POP DE ;get the address back
	LD (DE),A ;store it away
	RET ;scanned everything
;5.21: helper routine for address evaluation
frmhqi:	CALL frmevl
	PUSH HL
	CALL frqint
	EX DE,HL
	POP HL
	RET
frqint:	LD BC,frcint ;return here
	PUSH BC ;save addr
	CALL getypr ;set the cc'S ON VALTYPE
	RET M ;return if already integer.
	LD A,(fac) ;get exponent
	CP 220o ;is magnitude .gt. 32767
	RET NZ ;no, force integer
	CALL sign ;5.21: get sign of FAC
	RET M ;assume thats what it is, else give overflow
	CALL frcsng ;5.21: force single precision
	LD BC,221q*256+200q
	LD DE,0*256+0 ;get -65536.
	JP fadd ;subtract it, and then force integer
					;make the same for radio shack version


	page
	subttl	renumber
; the reseq(uence) command take up to three arguments
; reseq [nn[,mm[,inc]]]
; where nn is the first destination line of the
; lines being resequenced, lines less than mm are
; not resequenced, and inc is the increment.
reseq:
	LD BC,0+10 ;assume inc=10
	PUSH BC ;save on stack
	LD D,B ;reseq all lines by setting [d,e]=0
	LD E,B
	JP Z,resnn ;if just 'RESEQ' reseq 10 by 10
	CP 54o ;comma
	JP Z,eatcom ;dont use starting # of zero
	PUSH DE ;save [d,e]
	CALL linspc ;get new nn
	LD B,D ;get in in [b,c] where it belongs
	LD C,E
	POP DE ;get back [d,e]
	JP Z,resnn ;if eos, done
eatcom:	CALL synchr
	db	54o ;expect comma
	CALL linspc ;get new mm
	JP Z,resnn ;if eos, done
	POP AF ;get rid of old inc
	CALL synchr
	db	54o ;expect comma
	PUSH DE ;save mm
	CALL linget ;get new inc
	JP NZ,snerr ;should have terminated.
	LD A,D ;see if inc=0 (illegal)
	OR E
	JP Z,fcerr ;yes, blow him up now
	EX DE,HL ;flip new inc & [h,l]
	EX (SP),HL ;new inc onto stack
	EX DE,HL ;get [h,l] back, orig [d,e] back
resnn:	PUSH BC ;save nn on stack
	CALL fndlin ;find mm line
	POP DE ;get nn off stack
	PUSH DE ;save nn back
	PUSH BC ;save pointer to mm line
	CALL fndlin ;find first line to reseq.
	LD H,B ;get ptr to this line in [h,l]
	LD L,C
	POP DE ;get line ptd to by mm
	CALL dcompr ;compare to first line reseqed
	EX DE,HL ;get ptr to mm line in [h,l]
	JP C,fcerr ;cant allow program to be resequed
					;on top of itself
	POP DE ;get nn back
	POP BC ;get inc in [b,c]
	POP AF ;get rid of newstt
	PUSH HL ;save ptr to first line to reseq.
	PUSH DE ;save nn on stack
	JP nxtrsl
nxtrsc:	ADD HL,BC ;add increment into
	JP C,fcerr ;uh oh, his inc was too large.
	EX DE,HL ;flip link field, accum.
	PUSH HL ;save link field
	LD HL,0+65529 ;test for too large line
	CALL dcompr ;compare to current #
	POP HL ;restore link field
	JP C,fcerr ;uh oh, his inc was too large.
nxtrsl:	PUSH DE ;save current line accum
	LD E,(HL) ;get link field into [d,e]
	INC HL ;5.21: reorder
	LD D,(HL) ;get high part of link
	LD A,D ;5.21: get high part into [a]
	OR E ;set cc'S ON LINK FIELD
	EX DE,HL ;see if next link zero
	POP DE ;get back accum line #
	JP Z,ressd1 ;zero, done
	LD A,(HL) ;get first byte of link
	INC HL ;inc pointer
	OR (HL) ;set cc'S
	DEC HL ;move pointer back
	EX DE,HL ;back in [d,e]
	JP NZ,nxtrsc ;inc count

ressd1:	PUSH BC ;save inc
	CALL scclin ;scan program converting lines to ptrs.
	POP BC ;get back inc
	POP DE ;get nn
	POP HL ;get ptr to first line to reseq

resnx1:	PUSH DE ;save current line
	LD E,(HL) ;get link field
	INC HL ;5.21: reorder
	LD D,(HL)
	LD A,D
	OR E
	JP Z,sccall ;stop reseqing when see end of pgm
	EX DE,HL ;flip line ptr, link field
	EX (SP),HL ;put link on stack, get new line # off
	EX DE,HL ;put new line # in [d,e], this line
					;ptr in [h,l]
	INC HL ;point to line # field.
	LD (HL),E ;change to new line #
	INC HL
	LD (HL),D
	EX DE,HL ;get this line # in [h,l]
	ADD HL,BC ;add inc
	EX DE,HL ;get new line # back in [d,e]
	POP HL ;get ptr to next line
	JP resnx1 ;keep reseqing
sccall:	LD BC,stprdy ;where to go when done
	PUSH BC ;save on stack
	db	376q ;"CPI AL," call sccptr
; the subroutines scclin and sccptr convert all
; line #'S TO POINTERS AND VICE-VERSA.
; the only special case is "ON ERROR GOTO 0" where the "0"
; is left as a line number token so it wont be changed by resequence.
scclin:	db	366q ;"ORI AX," over next byte
sccptr:	XOR A ;set a=0
	LD (ptrflg),A ;set to say wheter lines or ptrs extant
scnpgm:	LD HL,(txttab) ;get ptr to start of pgm
	DEC HL ;nop next inx.
scnpln:	INC HL ;point to byte after zero at end of line
	LD A,(HL) ;get link field into [d,e]
	INC HL ;bump ptr
	OR (HL) ;set cc'S
	RET Z ;return if all done.
	INC HL ;point past line #
	LD E,(HL) ;get low byte of line #
	INC HL
	LD D,(HL) ;get high byte of line #
scnext:	CALL chrgtr ;get next char from line
scnex2:	OR A ;end of line
	JP Z,scnpln ;scan next line
	LD C,A ;save [a]
	LD A,(ptrflg) ;change line tokens which way?
	OR A ;set cc'S
	LD A,C ;get back current char
	JP Z,scnpt2 ;changing pointers to #'S
	CP $error ;is it error token?
	JP NZ,nterrg ;no.
	CALL chrgtr ;scan next char
	CP $goto ;error goto?
	JP NZ,scnex2 ;get next one
	CALL chrgtr ;get next char
	CP lincon ;line # constant?
	JP NZ,scnex2 ;no, ignore.
	PUSH DE ;save [d,e]
	CALL lingt3 ;get it
	LD A,D ;is it line # zero?
	OR E ;set cc'S
	JP NZ,chgptr ;change it to a pointer
	JP scnex3 ;yes, dont change it
nterrg:	CP lincon ;line # constant?
	JP NZ,scnext ;not, keep scanning
	PUSH DE ;save current line # for possible error msg
	CALL lingt3 ;get line # of line constant into [d,e]
chgptr:
	PUSH HL ;save text pointer just at end of lincon 3 bytes
	CALL fndlin ;try to find line in pgm.
	DEC BC ;point to zero at end of previous line
	LD A,ptrcon ;change line # to ptr
	JP C,makptr ;if line found chane # to ptr
	CALL crdonz ;print crlf if required
	LD HL,linm ;print "UNDEFINED LINE" message
	PUSH DE ;save line #
	CALL strout ;print it
	POP HL ;get line # in [h,l]
	CALL linprt ;print it
	POP BC ;get text ptr off stack
	POP HL ;get current line #
	PUSH HL ;save back
	PUSH BC ;save back text ptr
	CALL inprt ;print it
scnpop:	POP HL ;pop off current text pointer
scnex3:	POP DE ;get back current line #
	DEC HL ;backup pointer
scnex4:	JP scnext ;5.21: label for indirect jump

linm:	dc	'Undefined line '
	db	0

scnpt2:	CP ptrcon ;pointer
	JP NZ,scnex4 ;5.21: jump to jmp instruction, not directly to scnext
	PUSH DE ;save current line #
	CALL lingt3 ;get #
	PUSH HL ;save text pointer
	EX DE,HL ;flip current text ptr & ptr
	INC HL ;bump pointer
	INC HL ;point to line # field
	INC HL
	LD C,(HL) ;pick up line #
	INC HL ;point to high part
	LD B,(HL)
	LD A,lincon ;change to line constant
makptr:	LD HL,scnpop ;place to return to after changing constant
	PUSH HL ;save on stack
conchg:	LD HL,(contxt) ;get txt ptr after constant in [h,l]
conch2:	PUSH HL ;save ptr to end of constant
	DEC HL
	LD (HL),B
	DEC HL
	LD (HL),C ;change to value in [b,c]
	DEC HL ;point to constant token
	LD (HL),A ;change to value in [a]
	POP HL ;restore pointer to after constant
	RET

deptr:	LD A,(ptrflg) ;do line pointers exist in pgm?
	OR A ;set cc'S
	RET Z ;no, just return
	JP sccptr ;convert then to line #'S




	subttl	ansi - the routines to handle ansi features
datas	set	data
option:	CALL synchr
	db	'B'
	CALL synchr
	db	'A'
	CALL synchr
	db	'S'
	CALL synchr
	db	'E'
	LD A,(optflg)
	OR A ;have we seen option base before
	JP NZ,dderr ;if so "DOUBLE DIMENSION ERROR"
	PUSH HL ;save the text pointer
	LD HL,(arytab) ;see if we have any arrays yet
	EX DE,HL
	LD HL,(strend)
	CALL dcompr ;if these are equal we have not
	JP NZ,dderr
	POP HL
	LD A,(HL) ;get the base number
	SUB '0'
	JP C,snerr
	CP 2 ;only 0 and 1 are legal
	JP NC,snerr
	LD (optval),A ;save if for dim and ptrget
	INC A ;make sure [a] is non zero
	LD (optflg),A ;flag that we have seen "OPTION BASE"
	CALL chrgtr ;fetch the terminator
	RET

; this routine is called by the math package
; to print error messages wtout disturbing ptrfil, etc.
strprn:
	LD A,(HL) ;get byte from message
	OR A ;end of message
	RET Z ;yes, done
	CALL caltty ;print char
	INC HL ;increment pointer
	JP strprn ;print next char
caltty:	PUSH AF ;save [a] on stack
	JP ttychr ;put out char
					;print crlf and return
random:	JP Z,inprg ;if no argument ask from terminal
	CALL frmevl ;fetch the formula argument
	PUSH HL
	CALL frcint ;allow normal integers
	JP strnds ;store the new random seed
inprg:	PUSH HL
inprag:
	LD HL,ranmes ;ask for some random input
	CALL strout
	CALL qinlin
	POP DE ;get back text pointer
	JP C,stpend ;go away if control c
	PUSH DE ;resave text pointer
	INC HL ;move past bufmin to buf
	LD A,(HL) ;get first char of typein (fin expects it)
	CALL fin ;read a number
	LD A,(HL) ;get the terminator
	OR A
	JP NZ,inprag ;don'T ALLOW BAD FORMAT
	CALL frcint ;allow normal integers
strnds:	LD (rndx+1),HL
	CALL rndmn2
	POP HL ;get back the text pointer
	RET
ranmes:	dc	'Random number seed (-32768 to 32767)'
	db	0

;
; this code scans ahead to find the "NEXT" that matches a "FOR"
; in order to 1) handle empty loops and 2) make sure loops
; match up properly.
;
wndscn:	LD C,errwh ;scan for matching wend this is error if fail
	JP scncnt
nxtscn:	LD C,errfn
scncnt:
	LD B,0 ;set up the count of "FOR"s seen
	EX DE,HL ;initialize nxtlin for next on same line
	LD HL,(curlin)
	LD (nxtlin),HL
	EX DE,HL ;restore the text pointer to [h,l]
forinc:	INC B ;increment the count whenever "FOR" is seen
fnlop:	DEC HL ;** fix here for 5.03 can'T CALL DATA
scanwf:	CALL chrgtr ;to skip to statement because could
	JP Z,fortrm ;have statement after "THEN"
ntqtsc:
	CP $else ;else statment
	JP Z,fnnwst ;then allow next or wend after it
	CP $then ;so scan using chrget waiting for end
	JP NZ,scanwf ;of statement or $then
fortrm:	OR A ;see how it ended
	JP NZ,fnnwst ;just new statement -- examine it
					;or could be colon in string but no harm
					;in non kanabs (hghbit) version since no reserved
					;words will match the next character
	INC HL
	LD A,(HL) ;scan the link at the start of the next line
	INC HL
	OR (HL) ;to see if its zero (end of program)
	LD E,C ;set up error number
	JP Z,error
	INC HL ;pick up the new line number
	LD E,(HL)
	INC HL
	LD D,(HL)
	EX DE,HL ;[h,l]= new line number
	LD (nxtlin),HL ;save as "NEXT" line number
	EX DE,HL
fnnwst:	CALL chrgtr ;get the type of the next statement
	LD A,C ;get the error number to see what we are
	CP errfn ;scanning for
	LD A,(HL) ;get back the character
	JP Z,nxtlok ;for/next searching
	CP $while ;another while/wend nest?
	JP Z,forinc
	CP $wend
	JP NZ,fnlop
	DEC B
	JP NZ,fnlop
	RET
nxtlok:
	CP $for ;another "FOR"?
	JP Z,forinc ;increment the for count
	CP $next ;end with next?
	JP NZ,fnlop ;skip over this statement
decnxt:	DEC B ;decrement the loop count
	RET Z ;return with [h,l] about to get first character of "NEXT" variable

;
; scan  the variables listed in a "NEXT" statement
;
	CALL chrgtr ;see if there is a name
	JP Z,fortrm ;only one so scan more statements
	EX DE,HL ;save text pointer in [d,e]
	LD HL,(curlin) ;save the current line number
	PUSH HL
	LD HL,(nxtlin) ;make error come from "NEXT"
	LD (curlin),HL
	EX DE,HL ;[h,l]= text pointer
	PUSH BC ;save the "FOR" count
	CALL ptrget ;skip over the variable name
	POP BC ;get back the "FOR" count
	DEC HL ;check terminator
	CALL chrgtr
	LD DE,fortrm ;place to go to
	JP Z,trmnxt ;end of "NEXT"
	CALL synchr
	db	44 ;should have commas in between
	DEC HL ;rescan first character
	LD DE,decnxt ;place to go back to
trmnxt:	EX (SP),HL ;save the text pointer on the stack
	LD (curlin),HL
	POP HL
	PUSH DE ;go off to address in [b,c]
	RET
;
; this routine clears flgovc to reset to normal overflow mode.
; in normal mode, overr always prints overflow because flgovc=0
; function dispatch, fin (&findbl), and exponentiation set up an overflow
; mode where flgovc=1 and after one overflow flgovc=2 and no more
; overflow messages are printed. fin (&findbl) also store flgovc in ovcstr
; before resetting flgovc so a caller can detect overflow occurance.
;
finovc:	PUSH AF
	LD A,(flgovc) ;store overflow flag to indicate
	LD (ovcstr),A ;whether an overflow occured
	POP AF
clrovc:	PUSH AF ;save everything
	XOR A ;normal overflow mode
	LD (flgovc),A
	POP AF
	RET



;======================================================================
; Module: f4.mac
;======================================================================

	page
	title	mathpk for basic mcs 8080  gates/allen/davidoff
	subttl	floating point math package configuration

curncy	set	44o ;use dollar sign as default







;
;	external locations used by the math-package
;	;the floating accumulator
;ifn	length&2,<
;	block	1		;[temporary least significant byte]
;dfaclo:	block	4>		;[four lowest orders for double precision]
;faclo:	block	3		;[low order of mantissa (lo)]
;				;[middle order of mantissa (mo)]
;				;[high order of mantissa (ho)]
;fac:	block	2		;[exponent]
;				;[temporary complement of sign in msb]
;ifn	length&2,<
;	block	1		;[temporary least significant byte]
;arglo:	block	7		;[location of second argument for double
;arg:	block	1>		; precision]
;fbuffr:	block	^d13		;buffer for fout
;ifn	length&2,<block	^d<35-13>>
;
;
;the floating point format is as follows:
;
;the sign is the first bit of the mantissa
;the mantissa is 24 bits long
;the binary point is to the left of the msb
;number = mantissa * 2 ^ exponent
;the mantissa is positive, with a one assumed to be where the sign bit is
;the sign of the exponent is the first bit of the exponent
;the exponent is stored in excess 200 i.e. with a bias of 200
;so, the exponent is a signed 8-bit number with 200 added to it
;an exponent of zero means the number is zero, the other bytes are ignored
;to keep the same number in the fac while shifting:
;	to shift right,	exp:=exp+1
;	to shift left,	exp:=exp-1
;
;so, in memory the number looks like this:
;	[bits 17-24 of the mantissa]
;	[bits 9-16 of the mantissa]
;	[the sign in bit 7, bits 2-8 of the mantissa are in bits 6-0]
;	[the exponent as a signed number + 200]
;(remember that bit 1 of the mantissa is always a one)
;
;arithmetic routine calling conventions:
;
;for one argument functions:
;	the argument is in the fac, the result is left in the fac
;for two argument operations:
;	the first argument is in b,c,d,e i.e. the "REGISTERS"
;	the second argument is in the fac
;	the result is left in the fac
;
;the "S" entry points to the two argument operations have (hl) pointing to
;the first argument instead of the first argument being in the registers.
;movrm is called to get the argument in the registers.
;the "T" entry points assume the first argument is on the stack.
;popr is used to get the argument in the registers.
;note: the "T" entry points should always be jumped to and never called
;because the return address on the stack will be confused with the number.
;
;on the stack, the two lo'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
;this is done so if a number is stored in memory, it can be pushed on the
;stack with two pushm'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
;memory address so when the number is popped into the registers, the higher
;order byte will be in the higher order register of the register pair, i.e.
;the higher order byte will be popped into b, d or h.
;%
	page

	subttl	floating point addition and subtraction
					;entry to fadd with pointer to arg in (hl)

faddh:	LD HL,fhalf ;entry to add 1/2
fadds:	CALL movrm ;get argument into the registers
	JP fadd ;do the addition


					;subtraction	fac:=arg-fac
fsubs:	CALL movrm ;entry if pointer to arg is in (hl)
fsub:	CALL neg ;negate second argument
					;fall into fadd


					;addition	fac:=arg+fac
					;alters a,b,c,d,e,h,l
;*****************************************************************
;if intfsw=1 the format of floating point numbers will be:
;reg b:sign and bits 1-7 of exponent,reg c:bit 8 of exponent
;and bits 2-8 of mantissa,reg d:bits 9-16 of mantissa,
;reg e:bits 17-24 of mantissa, and likewise for the fac format
;furthermore, the exponent for intel will be bias 177 octal
;******************************************************************
fadd:	LD A,B ;check if first argument is zero
	OR A ;get exponent
	RET Z ;it is, result is number in fac
	LD A,(fac) ;get exponent
	OR A ;see if the number is zero
	JP Z,movfr ;it is, answer is in registers

;we want to get the smaller number in the registers so we can shift it right
;and align the binary points of the two numbers.  then we can just add or
;subtract them (depending on their signs) bytewise.
	SUB B ;check relative sizes
	JP NC,fadd1 ;is fac smaller?
	CPL ;yes, negate shift count
	INC A
	EX DE,HL ;switch fac and registers, save (de)
	CALL pushf ;put fac on stack
	EX DE,HL ;get (de) back where it belongs
	CALL movfr ;put registers in the fac
	POP BC
	POP DE
					;get the old fac in the registers
fadd1:
	CP 31o ;are we within 24 bits?
	RET NC
	PUSH AF ;save shift count
	CALL unpack ;unpack the numbers
	LD H,A ;save subtraction flag
	POP AF ;get shift count back
	CALL shiftr ;shift registers right the right amount

;if the numbers have the same sign, then we add them.  if the signs are
;different, then we have to subtract them.  we have to do this because the
;mantissas are positive.  judging by the exponents, the larger number is in
;the fac, so if we subtract, the sign of the result should be the sign of the
;fac; however, if the exponents are the same, the number in the registers
;could be bigger, so after we subtract them, we have to check if the result
;was negative.  if it was, we negate the number in the registers and
;complement the sign of the fac.  (here the fac is unpacked)
;if we have to add the numbers, the sign of the result is the sign of the
;fac.  so, in either case, when we are all done, the sign of the result
;will be the sign of the fac.
	LD A,H ;get subtraction flag
	OR A
	LD HL,faclo ;set pointer to lo'S
	JP P,fadd3 ;subtract if the signs were different
	CALL fadda ;add the numbers
	JP NC,round ;round result if there was no overflow
					;the most it can overflow is one bit
	INC HL ;there was overflow
	INC (HL) ;increment exponent
	JP Z,ovfin4
	LD L,1 ;shift result right one, shift carry in
	CALL shradd
	JP round ;round result and we are done
					;here to subtract c,d,e,b from ((hl)+0,1,2),0
fadd3:	XOR A ;subtract numbers, negate underflow byte
	SUB B
	LD B,A ;save it
	LD A,(HL) ;subtract low orders
	SBC E
	LD E,A
	INC HL ;update pointer to next byte
	LD A,(HL) ;subtract middle orders
	SBC D
	LD D,A
	INC HL ;update pointer to high orders
	LD A,(HL) ;subtract high orders
	SBC C
	LD C,A
					;because we want a positive mantissa, check if we have to negate the
					; number
fadflt:	CALL C,negr ;entry from floatr, int: negate number if it
					; was negative, fall into normalize


					;normalize c,d,e,b
					;alters a,b,c,d,e,h,l
					;here we shift the mantissa left until the msb is a one.
					;except in 4k, the idea is to shift left by 8 as many times as
					;possible.
normal:
	LD L,B ;put lowest 2 bytes in (hl)
	LD H,E
	XOR A ;zero shift count
norm1:	LD B,A ;save shift count
	LD A,C ;do we have 1 byte of zeros
	OR A
	JP NZ,norm3 ;no, shift one place at a time
					;this loop speeds things up by shifting 8 places at one time
	LD C,D ;yes, shift over 1 byte
	LD D,H
	LD H,L
	LD L,A ;shift in 8 zeros for the low order
	LD A,B ;update shift count
	SUB 10o
	CP 340o ;did we shift in 4 bytes of zeros?
	JP NZ,norm1 ;no, try to shift over 8 more
					;yes, number was zero.  fall into zero


					;zero fac
					;alters a only
					;exits with a=0
					;by our floating point format, the number is zero if the exponent is
					; zero
zero:	XOR A ;zero a
zero0:	LD (fac),A ;zero the fac'S EXPONENT, ENTRY IF A=0
	RET ;all done


norm2:
	LD A,H ;check for case of normalizing a small int
	OR L
	OR D
	JP NZ,norm2u ;do usual thing
	LD A,C ;get byte to shift
norm2f:	DEC B ;decrment shift count
	RLA ;shift left
	JP NC,norm2f ;normalize like sob
	INC B ;correct shift count
	RRA ;we did it one too many times
	LD C,A ;result to [c]
	JP norm3a ;all done
norm2u:	DEC B ;decrement shift count
	ADD HL,HL ;rotate (hl) left one, shift in a zero
	LD A,D ;rotate next higher order left one
	RLA
	LD D,A
	LD A,C ;rotate high order left one
	ADC A ;set condition codes
	LD C,A
norm3:	JP P,norm2 ;we have more normalization to do
norm3a:	LD A,B ;all normalized, get shift count
	LD E,H ;put lo'S BACK IN E,B
	LD B,L
	OR A ;check if we did no shifting
	JP Z,round
	LD HL,fac ;look at fac'S EXPONENT
	ADD (HL) ;update exponent
	LD (HL),A
	JP NC,zero ;check for underflow
	JP Z,zero ;number is zero, all done
					;fall into round and we are done


					;round result in c,d,e,b and put number in the fac
					;alters a,b,c,d,e,h,l
					;we round c,d,e up or down depending upon the msb of b
round:	LD A,B ;see if we should round up
roundb:	LD HL,fac ;entry from fdiv, get pointer to exponent

					;intel floating software flag
	OR A
	CALL M,rounda ;do it if necessary
	LD B,(HL) ;put exponent in b
					;here we pack the ho and sign
	INC HL ;point to sign
	LD A,(HL) ;get sign
	AND 200o ;get rid of unwanted bits
	XOR C ;pack sign and ho
	LD C,A ;save it in c
	JP movfr ;save number in fac




					;subroutne for round:  add one to c,d,e
rounda:	INC E ;add one to the low order, entry from qint
	RET NZ ;all done if it is not zero
	INC D ;add one to next higher order
	RET NZ ;all done if no overflow
	INC C ;add one to the highest order
	RET NZ ;return if no oveflow
	LD C,200o ;the number overflowed, set new high order
	INC (HL) ;update exponent
	RET NZ ;return if it did not overflow
	JP ovfin8 ;overflow and continue



					;add (hl)+2,1,0 to c,d,e
					;this code is used by fadd, fout
fadda:	LD A,(HL) ;get lowest order
	ADD E ;add in other lowest order
	LD E,A ;save it
	INC HL ;update pointer to next byte
	LD A,(HL) ;add middle orders
	ADC D
	LD D,A
	INC HL ;update pointer to high order
	LD A,(HL) ;add high orders
	ADC C
	LD C,A
	RET ;all done


					;negate number in c,d,e,b
					;this code is used by fadd, qint
					;alters a,b,c,d,e,l
negr:	LD HL,fac+1 ;negate fac
	LD A,(HL) ;get sign
	CPL ;complement it
	LD (HL),A ;save it again
	XOR A ;zero a
	LD L,A ;save zero in l
	SUB B ;negate lowest order
	LD B,A ;save it
	LD A,L ;get a zero
	SBC E ;negate next highest order
	LD E,A ;save it
	LD A,L ;get a zero
	SBC D ;negate next highest order
	LD D,A ;save it
	LD A,L ;get zero back
	SBC C ;negate highest order
	LD C,A ;save it
	RET ;all done


					;shift c,d,e right
					;a = shift count
					;alters a,b,c,d,e,l
					;the idea (except in 4k) is to shift right 8 places as many times as
					; possible
shiftr:	LD B,0 ;zero overflow byte
shftr1:	SUB 10o ;can we shift it 8 right?
	JP C,shftr2 ;no, shift it one place at a time
					;this loop speeds things up by shifting 8 places at one time
	LD B,E ;shift number 1 byte right
	LD E,D
	LD D,C
	LD C,0 ;put 0 in ho
	JP shftr1 ;try to shift 8 right again
shftr2:	ADD 11o ;correct shift count
	LD L,A ;save shift count
;test for case (very common) where shifting small integer right.
;this happens in for loops, etc.
	LD A,D ;see if three lows are zero.
	OR E
	OR B
	JP NZ,shftr3 ;if so, do usual.
	LD A,C ;get high byte to shift
shftrf:	DEC L ;done shifting?
	RET Z ;yes, done
	RRA ;rotate one right
	LD C,A ;save result
	JP NC,shftrf ;zap back and do next one if none
	JP shftc ;continue shifting
shftr3:	XOR A ;clear carry
	DEC L ;are we done shifting?
	RET Z ;return if we are
	LD A,C ;get ho
shradd:	RRA ;entry from fadd, shift it right
	LD C,A ;save it
shftc:	LD A,D ;shift next byte right
	RRA
	LD D,A
	LD A,E ;shift low order right
	RRA
	LD E,A
	LD A,B ;shift overflow byte right
	RRA
	LD B,A
	JP shftr3 ;see if we are done


	page
	subttl	natural log function
					;calculation is by:
					; ln(f*2^n)=(n+log2(f))*ln(2)
					;an approximation polynomial is used to calculate log2(f)

					;constants used by log
fone:	db	000 ; 1
	db	000
	db	000
	db	201o
logp:	db	004 ;hart 2524 coefficients
	db	232o ;4.8114746
	db	367o
	db	031o
	db	203o
	db	044o ;6.105852
	db	143o
	db	103o
	db	203o
	db	165o ;-8.86266
	db	315o
	db	215o
	db	204o
	db	251o ;-2.054667
	db	177o
	db	203o
	db	202o
logq:	db	004
	db	000 ;1.0
	db	000
	db	000
	db	201o
	db	342o ;6.427842
	db	260o
	db	115o
	db	203o
	db	012o ;4.545171
	db	162o
	db	021o
	db	203o
	db	364o ;.3535534
	db	004
	db	065o
	db	177o

log:	CALL sign ;check for a negative or zero argument
	OR A ;set cc'S PROPERLY
	JP PE,fcerr ;fac .le. 0, blow him out of the water
					;fsign only returns 0,1 or 377 in a
					;the parity will be even if a has 0 or 377

	CALL log2 ;
	LD BC,200q*256+061q
	LD DE,162q*256+030q ;get ln(2)
	JP fmult ;complete log calculation
log2:;use hart 2524 calculation
	CALL movrf ;move fac to registers too
	LD A,200o ;
	LD (fac),A ;zero the exponent
	XOR B ;remove 200 excess from x
	PUSH AF ;save exponent
	CALL pushf ;save the fac (x)
	LD HL,logp ;point to p constants
	CALL poly ;calculate p(x)
	POP BC ;fetch x
	POP HL ;pushf would alter de
	CALL pushf ;push p(x) on the stack
	EX DE,HL ;get low bytes of x to (de)
	CALL movfr ;and move to fac
	LD HL,logq ;point to q coefficients
	CALL poly ;compute q(x)
	POP BC ;fetch p(x) to registers
	POP DE
	CALL fdiv ;calculate p(x)/q(x)
	POP AF ;re-fetch exponent
	CALL pushf ;save evaluation
	CALL float ;float the exponent
	POP BC
	POP DE
					;get eval. back
	JP fadd

	page
;	jmp	fmult		;multiply by ln(2)
	subttl	floating multiplication and division
					;multiplication		fac:=arg*fac
					;alters a,b,c,d,e,h,l
fmult:	CALL sign ;check if fac is zero
	RET Z ;if it is, result is zero
	LD L,0 ;add the two exponents, l is a flag
	CALL muldiv ;fix up the exponents
					;save the number in the registers so we can add it fast
	LD A,C ;get ho
	LD (fmulta+1),A ;store ho of registers
	EX DE,HL ;store the two lo'S OF THE REGISTERS
	LD (fmultb+1),HL
	LD BC,0 ;zero the product registers
	LD D,B
	LD E,B
	LD HL,normal
	PUSH HL ; on the stack
	LD HL,fmult2 ;put fmult2 on the stack twice, so after
	PUSH HL ; we multiply by the lo byte, we will
	PUSH HL ; multiply by the mo and ho
	LD HL,faclo ;get address of lo of fac
fmult2:	LD A,(HL) ;get byte to multiply by
	INC HL ;move pointer to next byte
	OR A
	JP Z,fmult3 ;are we multiplying by zero?
	PUSH HL ;save pointer
	EX DE,HL ;get lo'S IN (HL)
	LD E,10o ;set up a count

;the product will be formed in c,d,e,b. this will be in c,h,l,b part of the
;time in order to use the "DAD" instruction.  at fmult2, we get the next
;byte of the mantissa in the fac to multiply by.  ((hl) points to it)
;(the fmult2 subroutine preserves (hl))  in 8k, if the byte is zero, we just
;shift the product 8 right.  this byte is then shifted right and saved in d
;(h in 4k).  the carry determines if we should add in the second factor
;if we do, we add it to c,h,l.  b is only used to determine which way we
;round.  we then shift c,h,l,b (c,d,e,b) in 4k right one to get ready for the
;next time through the loop.  note that the carry is shifted into the msb of
;c.  e has a count (l in 4k) to determine when we have looked at all the bits
;of d (h in 4k).
fmult4:	RRA ;rotate byte right
	LD D,A ;save it
	LD A,C ;get ho
	JP NC,fmult5 ;don'T ADD IN NUMBER IF BIT WAS ZERO
	PUSH DE ;save counters
fmultb:	LD DE,0 ;get lo'S OF NUMBER TO ADD, THIS IS SET ABOVE
	ADD HL,DE ;add them in
	POP DE ;get counters back
fmulta:	ADC 0 ;add in ho, this is set up above
fmult5:	RRA ;rotate result right one
	LD C,A
	LD A,H ;rotate next byte
	RRA
	LD H,A
	LD A,L ;rotate next lower order
	RRA
	LD L,A
	LD A,B ;rotate lo
	RRA
	LD B,A
	AND 20o ;see if we rotated thru st
	JP Z,fml5b1 ;if not don'T WORRY
	LD A,B ;re fetch lo
	OR 40o ;"OR" in sticky
	LD B,A ;back to lo
fml5b1:
fmlt5b:
	DEC E ;are we done?
	LD A,D ;get number we are multiplying by
	JP NZ,fmult4 ;multiply again if we are not done
	EX DE,HL ;get lo'S IN (DE)
pophrt:	POP HL ;get pointer to number to multiply by
	RET ;all done
fmult3:	LD B,E ;multiply by zero: shift everything 8 right
	LD E,D
	LD D,C
	LD C,A ;shift in 8 zeros on the left
	RET ;all done


					;divide fac by 10
					;alters a,b,c,d,e,h,l
div10:	CALL pushf ;save number
	LD HL,ften ;get pointer to the constant '10'
	CALL movfm ;move ten into the fac
fdivt:	POP BC
	POP DE
					;get number back in registers
					;fall into divide and we are done


					;division	fac:=arg/fac
					;alters a,b,c,d,e,h,l
fdiv:	CALL sign ;check for division by zero
	JP Z,intdv1 ;don'T ALLOW DIVIDE BY ZERO
	LD L,377o ;subtract the two exponents, l is a flag
	CALL muldiv ;fix up the exponents and things
	INC (HL)
	JP Z,ovfin2 ;5.21: overflow with type check
	INC (HL)
	JP Z,ovfin2 ;5.21: overflow with type check
					;here we save the fac in memory so we can subtract it from the number
					;in the registers quickly.
	DEC HL ;point to ho
	LD A,(HL) ;get ho
	LD (fdiva+1),A ;save it
	DEC HL ;save middle order
	LD A,(HL)
	LD (fdivb+1),A ;put it where nothing will hurt it
	DEC HL ;save lo
	LD A,(HL)
	LD (fdivc+1),A

;the numerator will be kept in b,h,l.  the quotient will be formed in c,d,e.
;to get a bit of the quotient, we first save b,h,l on the stack, then
;subtract the denominator that we saved in memory.  the carry indicates
;whether or not b,h,l was bigger than the denominator.  if b,h,l was bigger,
;the next bit of the quotient is a one.  to get the old b,h,l off the stack,
;we pop them into the psw.  if the denominator was bigger, the next bit of
;the quotient is zero, and we get the old b,h,l back by popping it off the
;stack.  we have to keep an extra bit of the quotient in fdivg+1 in case the
;denominator was bigger,  then b,h,l will get shifted left.  if the msb  of
;b was one, it has to be stored somewhere, so we store it in fdivg+1.  then
;the next time through the loop b,h,l will look bigger because it has an
;extra ho bit in fdivg+1. we are done dividing when the msb of c is a one.
;this occurs when we have calculated 24 bits of the quotient.  when we jump
;to round, the 25th bit of the quotient determines whether we round or not.
;it is in the msb of a.  if initially the denominator is bigger than the
;numerator, the first bit of the quotient will be zero.  this means we
;will go through the divide loop 26 times, since it stops on the 25th bit
;after the first non-zero bit of the quotient.  so, this quotient will look
;shifted left one from the quotient of two numbers in which the numerator is
;bigger.  this can only occur on the first time through the loop, so c,d,e
;are all zero.  so, if we finish the loop and c,d,e are all zero, then we
;must decrement the exponent to correct for this.
	LD B,C ;get number in b,h,l
	EX DE,HL
	XOR A ;zero c,d,e and highest order
	LD C,A
	LD D,A
	LD E,A
	LD (fdivg+1),A
fdiv1:	PUSH HL ;save lo'S OF NUMBER
	PUSH BC ;save ho of number
	LD A,L ;subtract number that was in fac
fdivc:	SUB 0 ;subtract lo
	LD L,A ;save it
	LD A,H ;subtract middle order
fdivb:	SBC 0
	LD H,A
	LD A,B ;subtract ho
fdiva:	SBC 0
	LD B,A
fdivg:	LD A,0 ;get highest order
					;we could do this with no code in ram, but
					; it would be much slower.
	SBC 0 ;subtract the carry from it
	CCF ;set carry to corespond to next quotient bit
	JP NC,fdiv2 ;get old number back if we subtracted too much
	LD (fdivg+1),A ;update highest order
	POP AF ;the subtraction was good
	POP AF ;get previous number off stack
	SCF ;next bit in quotient is a one
	db	322o ;"JNC" around next 2 bytes
fdiv2:	POP BC ;we subtracted too much
	POP HL ;get old number back
	LD A,C ;are we done?
	INC A ;set sign flag without affecting carry
	DEC A
	RRA ;put carry in msb
	JP P,div2a ;not ready to round yet
	RLA ;bit back to carry
	LD A,(fdivg+1) ;fetch extra bit
	RRA ;both now in a
	AND 300o ;clear superfluous bits
	PUSH AF ;save for later
	LD A,B ;fetch ho of remainder
	OR H ;fetch ho
	OR L ;see if other remainder bits
					;and if so set st
	JP Z,div2aa ;if not ignore
	LD A,40o ;st bit
div2aa:	POP HL ;and the rest of remainder
	OR H ;"OR" in rest
	JP roundb ;use remainder
div2a:
	RLA ;we aren'T, GET OLD CARRY BACK
	LD A,E ;rotate everything left one
	RLA ;rotate next bit of quotient in
	LD E,A
	LD A,D
	RLA
	LD D,A
	LD A,C
	RLA
	LD C,A
	ADD HL,HL ;rotate a zero into right end of number
	LD A,B ;the ho byte, finally!
fdiv2a:	RLA
	LD B,A
fdiv2b:	LD A,(fdivg+1) ;rotate the highest order
	RLA
	LD (fdivg+1),A
	LD A,C ;add one to exponent if the first subtraction
	OR D ; did not work
	OR E
	JP NZ,fdiv1 ;this isn'T THE CASE
	PUSH HL ;save part of number
	LD HL,fac ;get pointer to fac
	DEC (HL) ;decrement exponent
	POP HL ;get number back
	JP NZ,fdiv1 ;divide more if no overflow occured
	JP zero ;underflow!!


					;check special cases and add exponents for fmult, fdiv
					;alters a,b,h,l
muldvs:	LD A,377o ;entry from ddiv, subtract exponents
	db	056o ;"MVI	L" around next byte
muldva:	XOR A ;entry from dmult, add exponents
	LD HL,args ;5.21: get pointer to sign byte of arg
	LD C,(HL) ;get ho and sign for unpacking
	INC HL ;increment pointer to exponent
	XOR (HL) ;get exponent
	LD B,A ;save it in b for below
	LD L,0 ;set flag to add the exponents below
muldiv:	LD A,B ;is number in registers zero?
	OR A
	JP Z,muldv2 ;it is, zero fac and we are done
	LD A,L ;get add or subtract flag
	LD HL,fac ;get pointer to exponent
	XOR (HL) ;get exponent
	ADD B ;add in register exponent
	LD B,A ;save it
	RRA ;check for overflow
	XOR B ;overflow if sign is the same as carry
	LD A,B ;get sum
	JP P,muldv1 ;we have overflow!!
	ADD 200o ;put exponent in excess 200
	LD (HL),A ;save it in the fac
	JP Z,pophrt ;we have undeflow!! return.
	CALL unpack ;unpack the arguments
	LD (HL),A ;save the new sign
dcxhrt:	DEC HL ;point to exponent
	RET ;all done, leave ho in a
mldvex:	CALL sign ;entry from exp, pick underflow if negative
	CPL ;pick overflow if positive
	POP HL ;don'T SCREW UP STACK
muldv1:	OR A ;is error overflow or undeflow?
muldv2:	POP HL ;get old return address off stack



	JP P,zero
	JP ovfin2


					;multiply fac by 10
					;alters a,b,c,d,e,h,l
mul10:	CALL movrf ;get number in registers
	LD A,B ;get exponent
	OR A ;result is zero if arg is zero
	RET Z ;it is
	ADD 2 ;multiply by 4 by adding 2 to exponent
	JP C,ovfin3
	LD B,A ;restore exponent
	CALL fadd ;add in original number to get 5 times it
	LD HL,fac ;add 1 to exponent to multiply number by
	INC (HL) ; 2 to get 10 times original number
	RET NZ ;all done if no overflow
	JP ovfin3
	page
	subttl	sign, sgn, float, neg and abs
					;put sign of fac in a
					;alters a only
					;leaves fac alone
					;note: to take advantage of the rst instructions to save bytes,
					;fsign is defined to be an rst.  "FSIGN" is equivalent to "CALL	SIGN"
					;the first few instructions of sign (the ones before signc) are done
					;in the 8 bytes at the rst location.

					;intel floating software flag

					;fsign is usually an rst
sign:	LD A,(fac) ;check if the number is zero
	OR A
	RET Z ;it is, a is zero
signc:	LD A,(facs) ;get sign of fac, it is non-zero
	db	376o ;"CPI" around next byte
fcomps:	CPL ;entry from fcomp, complement sign
icomps:	RLA ;entry from icomp, put sign bit in carry
signs:	SBC A ;a=0 if carry was 0, a=377 if carry was 1
	RET NZ ;return if number was negative
inrart:	INC A ;put one in a if number was positive
	RET ;all done


					;sgn function
					;alters a,b,c,d,e,h,l
					;fall into float


					;float the signed integer in a
					;alters a,b,c,d,e,h,l

					;use microsoft format if not intel
float:	LD B,210o ;set exponent correctly
	LD DE,0 ;zero d,e
					;fall into floatr


					;float the signed number in b,a,d,e
					;alters a,b,c,d,e,h,l
floatr:	LD HL,fac ;get pointer to fac
	LD C,A ;put ho in c
	LD (HL),B ;put exponent in the fac
	LD B,0 ;zero overflow byte
	INC HL ;point to sign
	LD (HL),200o ;assume a positive number
	RLA ;put sign in carry
	JP fadflt ;go and float the number


					;fall into neg


;
;	;get the valtyp and set condition codes as follows:
;;condition code		true set	false set
;;sign			int=2		str,sng,dbl
;;zero			str=3		int,sng,dbl
;;odd parity		sng=4		int,str,dbl
;;no carry		dbl=10		int,str,sng
;getype:	lda	valtyp		;get the valtyp
;	cpi	10		;set carry correctly
;	dcr	a		;set the other condition codes correctly
;	dcr	a		; without affecting carry
;	dcr	a
;	ret	*			;all done


					;absolute value of fac
					;alters a,b,c,d,e,h,l
abs:	CALL vsign ;get the sign of the fac in a
	RET P ;if it is positive, we are done


					;negate any type value in the fac
					;alters a,b,c,d,e,h,l
vneg:	CALL getypr ;see what kind of number we have
	JP M,ineg ;we have an integer, negate it that way
	JP Z,tmerr ;blow up on strings
					;fall into neg to negate a sng or dbl


					;negate number in the fac
					;alters a,h,l
					;note: the number must be packed

					;if intfsw=0 do not use intel format
neg:	LD HL,facs ;get pointer to sign
	LD A,(HL) ;get sign
	XOR 200o ;complement sign bit
	LD (HL),A ;save it
	RET ;all done


					;sgn function
					;alters a,h,l
sgn:	CALL vsign ;get the sign of the fac in a
					;entry to convert a signed number in a to an integer
conia:	LD L,A ;put it in the lo position
	RLA ;extend the sign to the ho
	SBC A
	LD H,A
	JP makint ;return the result and set valtyp


					;get the sign of the value in the fac in a
					;alters a,h,l
vsign:	CALL getypr ;see what kind of a number we have
	JP Z,tmerr ;blow up on strings
	JP P,sign ;single and double prec. work the same
	LD HL,(faclo) ;get the integer argument

					;entry to find the sign of (hl)
					;alters a only
isign:	LD A,H ;get its sign
	OR L ;check if the number is zero
	RET Z ;it is, we are done
	LD A,H ;it isn'T, SIGN IS THE SIGN OF H
	JP icomps ;go set a correctly
	page
	subttl	floating point movement routines
					;put fac on stack
					;alters d,e
pushf:	EX DE,HL ;save (hl)
	LD HL,(faclo) ;get lo'S
	EX (SP),HL ;switch lo'S AND RET ADDR
	PUSH HL ;put ret addr back on stack
	LD HL,(facs) ;get ho'S
	EX (SP),HL ;switch ho'S AND RET ADDR
	PUSH HL ;put ret addr back on stack
	EX DE,HL ;get old (hl) back
	RET ;all done


					;move number from memory [(hl)] to fac
					;alters b,c,d,e,h,l
					;at exit number is in b,c,d,e
					;at exit (hl):=(hl)+4
movfm:	CALL movrm ;get number in registers
					;fall into movfr and put it in fac


					;move registers (b,c,d,e) to fac
					;alters d,e
movfr:	EX DE,HL ;get lo'S IN (HL)
	LD (faclo),HL ;put them where they belong
	LD H,B ;get ho'S IN (HL)
	LD L,C
	LD (facs),HL ;put ho'S WHERE THEY BELONG
	EX DE,HL ;get old (hl) back
	RET ;all done


					;move fac to registers (b,c,d,e)
					;alters b,c,d,e,h,l
movrf:	LD HL,faclo ;get pointer to fac
					;fall into movrm


					;get number in registers (b,c,d,e) from memory [(hl)]
					;alters b,c,d,e,h,l
					;at exit (hl):=(hl)+4
movrm:	LD E,(HL) ;get lo
	INC HL ;point to mo
getbcd:	LD D,(HL) ;get mo, entry for bill
	INC HL ;point to ho
	LD C,(HL) ;get ho
	INC HL ;point to exponent
	LD B,(HL) ;get exponent
inxhrt:	INC HL ;inc pointer to beginning of next number
	RET ;all done


					;move number from fac to memory [(hl)]
					;alters a,b,d,e,h,l
movmf:	LD DE,faclo ;get pointer to fac
					;fall into move


					;move number from (de) to (hl)
					;alters a,b,d,e,h,l
					;exits with (de):=(de)+4, (hl):=(hl)+4
move:	LD B,4 ;set counter
	JP move1 ;continue with the move


					;move any type value (as indicated by valtyp) from (de) to (hl)
					;alters a,b,d,e,h,l
movvfm:	EX DE,HL ;entry to switch (de) and (hl)
vmove:	LD A,(valtyp) ;get the length of the number
	LD B,A ;save it away
move1:	LD A,(DE) ;get word, entry from vmovmf
	LD (HL),A ;put it where it belongs
	INC DE ;increment pointers to next word
	INC HL
	DEC B
	JP NZ,move1
	RET


					;unpack the fac and the registers
					;alters a,c,h,l
					;when the number in the fac is unacked, the assumed one in the
					;mantissa is restored, and the complement of the sign is placed
					;in fac+1

					;intel floating software flag
unpack:	LD HL,facs ;point to ho and sign
	LD A,(HL) ;get ho and sign
	RLCA ;duplicate the sign in carry and the lsb
	SCF ;restore the hidden one
	RRA ;restore the number in a
	LD (HL),A ;save ho
	CCF ;get the complement of the sign
	RRA ;get it in the sign bit
	INC HL ;point to temporary sign byte
	INC HL
	LD (HL),A ;save complement of sign
	LD A,C ;get ho and sign of the registers
	RLCA ;duplicate the sign in carry and the lsb
	SCF ;restore the hidden one
	RRA ;restore the ho in a
	LD C,A ;save the ho
	RRA ;get the sign back
	XOR (HL) ;compare sign of fac and sign of registers
	RET ;all done


					;move any type value from memory [(hl)] to fac
					;alters a,b,d,e,h,l
vmovfa:	LD HL,arglo ;entry from dadd, move arg to fac
vmovfm:	LD DE,movvfm ;get address of location that does
	JP vmvvfm ; an "XCHG" and falls into move1


					;move any type value from fac to memory [(hl)]
					;alters a,b,d,e,h,l
vmovaf:	LD HL,arglo ;entry from fin, dmul10, ddiv10
					;move fac to arg
vmovmf:	LD DE,vmove ;get address of move subroutine
vmvvfm:	PUSH DE ;shove it on the stack
vdfacs:	LD DE,faclo ;get first address for int, str, sng
	CALL getypr ;get the value type
	RET C ;go move it if we do not have a dbl
	LD DE,dfaclo ;we do, get lo addr of the dbl number
	RET ;go do the move
	page
	subttl	compare two numbers
					;compare two single precision numbers
					;a=1 if arg .lt. fac
					;a=0 if arg=fac
					;a=-1 if arg .gt. fac
					;dorel depends upon the fact that fcomp returns with carry on
					; iff a has 377
					;alters a,h,l
fcomp:	LD A,B ;check if arg is zero
	OR A
	JP Z,sign
	LD HL,fcomps ;we jump to fcomps when we are done
	PUSH HL ;put the address on the stack
	CALL sign ;check if fac is zero
	LD A,C ;if it is, result is minus the sign of arg
	RET Z ;it is
	LD HL,facs ;point to sign of fac
	XOR (HL) ;see if the signs are the same
	LD A,C ;if they are different, result is sign of arg
	RET M ;they are different
	CALL fcomp2 ;check the rest of the number
fcompd:	RRA ;numbers are different, change sign if
	XOR C ; both numbers are negative
	RET ;go set up a

fcomp2:	INC HL ;point to exponent
	LD A,B ;get exponent of arg
	CP (HL) ;compare the two
	RET NZ ;numbers are different
	DEC HL ;point to ho
	LD A,C ;get ho of arg
	CP (HL) ;compare with ho of fac
	RET NZ ;they are different
	DEC HL ;point to mo of fac
	LD A,D ;get mo of arg
	CP (HL) ;compare with mo of fac
	RET NZ ;the numbers are different
	DEC HL ;point to lo of fac
	LD A,E ;get lo of arg
	SUB (HL) ;subtract lo of fac
	RET NZ ;numbers are different
	POP HL ;numbers are the same, don'T SCREW UP STACK
	POP HL
	RET ;all done


					;compare two integers
					;a=1 if (de) .lt. (hl)
					;a=0 if (de)=(hl)
					;a=-1 if (de) .gt. (hl)
					;alters a only
icomp:	LD A,D ;are the signs the same?
	XOR H
	LD A,H ;if not, answer is the sign of (hl)
	JP M,icomps ;they are different
	CP D ;they are the same, compare the ho'S
	JP NZ,signj ;5.21: jump to jmp stub
	LD A,L ;compare the lo'S
	SUB E
	RET Z ;5.21: return if same
signj:	JP signs ;5.21: stub for indirect jump


					;compare two double precision numbers
					;a=1 if arg .lt. fac
					;a=0 if arg=fac
					;a=-1 if arg .gt. fac
					;alters a,b,c,d,e,h,l
dcompd:	LD HL,arglo ;entry with pointer to arg in (de)
	CALL vmove ;move the argument into arg
xdcomp:	LD DE,arg ;get pointer to arg
	LD A,(DE) ;see if arg=0
	OR A
	JP Z,sign ;arg=0, go set up a
	LD HL,fcomps ;push fcomps on stack so we will return to
	PUSH HL ; to it and set up a
	CALL sign ;see if fac=0
	DEC DE ;point to sign of argument
	LD A,(DE) ;get sign of arg
	LD C,A ;save it for later
	RET Z ;fac=0, sign of result is sign of arg
	LD HL,facs ;point to sign of fac
	XOR (HL) ;see if the signs are the same
	LD A,C ;if they are, get the sign of the numbers
	RET M ;the signs are different, go set a
	INC DE ;point back to exponent of arg
	INC HL ;point to exponent of fac
	LD B,10o ;set up a count
dcomp1:	LD A,(DE) ;get a byte from arg
	SUB (HL) ;compare it with the fac
	JP NZ,fcompd ;they are different, go set up a
	DEC DE ;they are the same, examine the next lower
	DEC HL ; order bytes
	DEC B ;are we done?
	JP NZ,dcomp1 ;no, compare the next bytes
	POP BC ;they are the same, get fcomps off stack
	RET ;all done


					;compare two double precision numbers
					;a=1 if arg .gt. fac
					;a=0 if arg=fac
					;a=-1 if arg .lt. fac
					;note:	this is the reverse of icomp, fcomp and xdcomp
					;alters a,b,c,d,e,h,l
dcomp:	CALL xdcomp ;compare the two numbers
	JP NZ,fcomps ;negate the answer, make sure the carry comes
	RET ; out correct for docmp
	page
	subttl	conversion routines between integer, single and double precision
					;force the fac to be an integer
					;alters a,b,c,d,e,h,l
frcint:	CALL getypr ;see what we have
	LD HL,(faclo) ;get faclo+0,1 in case we have an integer
	RET M ;we have an integer, all done
	JP Z,tmerr ;we have a string, that is a "NO-NO"
	JP PO,frcin2 ;go do s.p.
fdbint:	CALL vmovaf ;add d.p. .5
	LD HL,dhalf ;
	CALL vmovfm
	CALL dadd ;
frdbin:	CALL consd
	JP frcin3
frcin2:	CALL faddh
frcin3:	LD A,(facs) ;get sign byte
	OR A ;set condition codes correctly
	PUSH AF
	AND 177o ;clear sign
	LD (facs),A ;make fac positive
	LD A,(fac) ;get exponent
	CP 220o ;see if too large
	JP NC,overr ;
	CALL qint ;convert to integer
	LD A,(fac)
	OR A
	JP NZ,frciaa
	POP AF ;
	EX DE,HL
	JP frci3a
frciaa:
	POP AF ;
	EX DE,HL ;move integer to (hl)
	JP P,frcin4
frci3a:	LD A,H
	CPL
	LD H,A ;complement (hl)
	LD A,L
	CPL
	LD L,A ;
frcin4:	JP makint
	LD HL,overr ;put overr on the stack so we will get error
	PUSH HL ; if number is too big
					;fall into conis


					;convert single precision number to integer
					;alters a,b,c,d,e,h,l
conis:	LD A,(fac) ;get the exponent
	CP 220o ;see if it is too big
	JP NC,conis2 ;it is, but it might be -32768
	CALL qint ;it isn'T, CONVERT IT TO AN INTEGER
	EX DE,HL ;put it in (hl)
					;entry from iadd
conis1:	POP DE ;get error address off stack

					;put (hl) in faclo, set valtyp to int
					;alters a only
makint:	LD (faclo),HL ;store the number in faclo
valint:	LD A,2 ;set valtyp to "INTEGER"
conisd:	LD (valtyp),A ;entry from conds
	RET ;all done

conis2:	LD BC,220q*256+200q
	LD DE,000q*256+000q ;check if number is -32768, entry from fin
	CALL fcomp
	RET NZ ;error:  it can'T BE CONVERTED TO AN INTEGER
	LD H,C ;it is -32768, put it in (hl)

	LD L,D
	JP conis1 ;store it in the fac and set valtyp


					;force the fac to be a single precision number
					;alters a,b,c,d,e,h,l
frcsng:	CALL getypr ;see what kind of number we have
	RET PO ;we already have a sng, all done
	JP M,consi ;we have an integer, convert it
	JP Z,tmerr ;strings!! -- error!!
					;dbl prec -- fall into consd


					;convert double precision number to a single precison one
					;alters a,b,c,d,e,h,l
consd:	CALL movrf ;get the ho'S IN THE REGISTERS
	CALL valsng ;set valtyp to "SINGLE PRECISON"
	LD A,B ;check if the number is zero
	OR A
	RET Z ;if it is, we are done
	CALL unpack ;unpack the number
	LD HL,dfaclo+3 ;5.21: get first byte below a sng number
	LD B,(HL) ;put it in b for round
	JP round ;round the dbl number up and we are done


					;convert an integer to a single precision number
					;alters a,b,c,d,e,h,l
consi:	LD HL,(faclo) ;get the integer
consih:	CALL valsng ;set valtyp to "SINGLE PRECISION"
	LD A,H ;set up registers for floatr
	LD D,L
	LD E,0
	LD B,220o
	JP floatr ;go float the number


					;force the fac to be a double precision number
					;alters a,b,c,d,e,h,l
frcdbl:	CALL getypr ;see what kind of number we have
	RET NC ;we already have a dbl, we are done
	JP Z,tmerr ;give an error if we have a string
	CALL M,consi ;convert to sng if we have an int
					;fall into conds and convert to dbl


					;convert a single precision number to a double precision one
					;alters a,h,l
conds:	LD HL,0 ;zero h,l
	LD (dfaclo),HL ;clear the four lower bytes in the double
	LD (dfaclo+2),HL ; precision number
valdbl:	LD A,10o ;set valtyp to "DOUBLE PRECISION"
	db	001 ;"LXI	B" over the next 2 bytes
valsng:	LD A,4 ;set valtyp to "SINGLE PRECISION"
	JP conisd ;go to it


					;force the fac to be a string
					;alters a only
chkstr:
frcstr:	CALL getypr ;see what kind of value we have
	RET Z ;we have a string, everything is ok
	JP tmerr ;we don'T HAVE A STRING, FALL INTO TMERR

	page
	subttl	greatest integer function
					;quick greatest integer function
					;leaves int(fac) in c,d,e (signed)
					;assumes fac .lt. 2^23 = 8388608
					;assumes the exponent of fac is in a
					;alters a,b,c,d,e
qint:	LD B,A ;zero b,c,d,e in case the number is zero
	LD C,A
	LD D,A
	LD E,A
	OR A ;set condition codes
	RET Z ;it is zero, we are done

;the hard case in qint is negative non-integers.  to handle this, if the
;number is negative, we regard the 3-byte mantissa as a 3-byte integer and
;subtarct one.  then all the fractional bits are shifted out by shifting the
;mantissa right.  then, if the number was negative, we add one.  so, if we
;had a negative integer, all the bits to the right of the binary point were
;zero.  so the net effect is we have the original number in c,d,e.  if the
;number was a negative non-integer, there is at least one non-zero bit to the
;right of the binary point.  so the net effect is that we get the absolute
;value of int(fac) in c,d,e.  c,d,e is then negated if the original number was
;negative so the result will be signed.
	PUSH HL ;save (hl)
	CALL movrf ;get number in the registers
	CALL unpack ;unpack the number
	XOR (HL) ;get sign of number
	LD H,A ;don'T LOSE IT
	CALL M,qinta ;subtract 1 from lo if number is negative
	LD A,230o ;see how many we have to shift to change
	SUB B ; number to an integer
	CALL shiftr ;shift number to get rid of fractional bits
	LD A,H ;get sign
	RLA ;put sign in carry so it will not be changed
	CALL C,rounda ;if number was negative, add one
	LD B,0 ;forget the bits we shifted out
	CALL C,negr ;negate number if it was negative because we
					; want a signed mantissa
	POP HL ;get old (hl) back
	RET ;all done

qinta:	DEC DE ;subtract one from c,d,e
	LD A,D ;we have to subtract one from c if
	AND E ; d and e are both all ones
	INC A ;see if both were -1
	RET NZ ;they were not, we are done
dcx4bd:;5.21: same as dcxbrt
dcxbrt:	DEC BC ;this is for bill.  c will never be zero
					; (the msb will always be one) so "DCX	B"
					; and "DCR	C" are functionally equivalent
	RET ;all done
					; this is the fix (x) function. it returns
					; fix(x)=sgn(x)*int(abs(x))
fixer:	CALL getypr ;get valtype of arg
	RET M ;int, done
	CALL sign ;get sign
	JP P,vint ;if positive, just call regular int code
	CALL neg ;negate it
	CALL vint ;get the integer of it
	JP vneg ;now re-negate it

					;greatest integer function
					;alters a,b,c,d,e,h,l
vint:	CALL getypr ;see what type of a number we have
	RET M ;it is an integer, all done
	JP NC,dint ;convert the double precision number
	JP Z,tmerr ;blow up on strings
	CALL conis ;try to convert the number to an integer
					;if we can'T, WE WILL RETURN HERE TO GIVE A
					; single precision result
int:	LD HL,fac ;get exponent
	LD A,(HL)
	CP 230o ;see if number has any fractional bits

					;the only guy who needs this doesn'T CARE
	LD A,(faclo) ; about the sign
	RET NC ;it does not
	LD A,(HL) ;get exponent back
	CALL qint ;it does, shift them out
	LD (HL),230o ;change exponent so it will be correct
					;note:qint unpacked the number!!!!
					; after normalization
	LD A,E ;get lo
	PUSH AF ;save it
	LD A,C ;negate number if it is negative
	RLA ;put sign in carry
	CALL fadflt ;refloat number
	POP AF ;get lo back
	RET ;all done


					;greatest integer function for double precision numbers
					;alters a,b,c,d,e,h,l
dint:	LD HL,fac ;get pointer to fac
	LD A,(HL) ;get exponent
	CP 220o ;can we convert it to an integer?
din00:	JP NZ,dint2 ;check for -32768
	LD C,A ;save exponent in c
	DEC HL ;get pointer to sign and ho
	LD A,(HL) ;get sign and ho
	XOR 200o ;check if it is 200
	LD B,6 ;set up a count to check if the rest of
dint1:	DEC HL ; the number is zero, point to next byte
	OR (HL) ;if any bits are non-zero, a will be non-zero
	DEC B ;are we done?
	JP NZ,dint1 ;no, check the next lower order byte
	OR A ;is a now zero?
	LD HL,200o*400o+0 ;get -32768 just in case
	JP NZ,din05
	CALL makint ;a is zero so we have -32768
	JP frcdbl ;force back to double
din05:	LD A,C ;get exponent
dint2:	OR A ;check for zero value
	RET Z ;***fix 5.11***^1 -- alalow 0 in dint
	CP 270o ;are there any fractional bits?
	RET NC ;no, the number is already an integer

dintfo:	PUSH AF ;entry from fout, carry is zero if we come
					; here from fout
	CALL movrf ;get ho'S OF NUMBER IN REGISTERS FOR UNPACKING
	CALL unpack ;unpack it
	XOR (HL) ;get its sign back
	DEC HL ;set the exponent to normalize correctly
	LD (HL),270o
	PUSH AF ;save the sign
	DEC HL
	LD (HL),C ;get unpacked high byte
	CALL M,dinta ;subtract 1 from lo if number is negative
	LD A,(facs) ;fetch new high mantissa byte
	LD C,A ;and put in c
	LD HL,facs ;point to the ho of the fac
	LD A,270o ;get how many bits we have to shift out
	SUB B
	CALL dshftr ;shift them out!!
	POP AF ;get the sign back
	CALL M,drouna ;if number was negative, add one
	XOR A ;put a zero in the extra lo byte so when
	LD (dfacx),A ; we normalize, we will shift in zeros
	POP AF ;if we were called from fout, don'T NORMALIZE,
	RET NC ; just return
	JP dnorml ;re-float the integer

dinta:	LD HL,dfaclo ;subtract one from fac, get pointer to lo
dinta1:	LD A,(HL) ;get a byte of fac
	DEC (HL) ;subtract one from it
	OR A ;continue only if the byte used to be zero
	INC HL ;increment pointer to next byte
	JP Z,dinta1 ;continue if necessary
	RET ;all done
	page
	subttl	integer arithmetic routines
					;integer multiply for multiply dimensioned arrays
					; (de):=(bc)*(de)
					;overflow causes a bs error
					;alters a,b,c,d,e
umult:	PUSH HL ;save [h,l]
	LD HL,0 ;zero product registers
	LD A,B ;check if (bc) is zero
	OR C ;if so, just return, (hl) is already zero
	JP Z,mulret ;this is done for speed
	LD A,20o ;set up a count
umult1:	ADD HL,HL ;rotate (hl) left one
	JP C,bserr ;check for overflow, if so,
	EX DE,HL ; bad subscript (bs) error
	ADD HL,HL ;rotate (de) left one
	EX DE,HL
	JP NC,umult2 ;add in (bc) if ho was 1
	ADD HL,BC
	JP C,bserr ;check for overflow
umult2:	DEC A ;see if done
	JP NZ,umult1
mulret:	EX DE,HL ;return the result in [d,e]
	POP HL ;get back the saved [h,l]
	RET


;
;	integer arithmetic conventions
;
;integer variables are 2 byte, signed numbers
;	the lo byte comes first in memory
;
;calling conventions:
;for one argument functions:
;	the argument is in (hl), the result is left in (hl)
;for two argument operations:
;	the first argument is in (de)
;	the second argument is in (hl)
;	the result is left in the fac and if no overflow, (hl)
;if overflow occurs, the arguments are converted to single precision
;when integers are stored in the fac, they are stored at faclo+0,1
;valtyp(integer)=2
;%


					;integer subtrtaction	(hl):=(de)-(hl)
					;alters a,b,c,d,e,h,l
isub:	LD A,H ;extend the sign of (hl) to b
	RLA ;get sign in carry
	SBC A
	LD B,A
	CALL ineghl ;negate (hl)
	LD A,C ;get a zero
	SBC B ;negate sign
	JP iadds ;go add the numbers


					;integer addition	(hl):=(de)+(hl)
					;alters a,b,c,d,e,h,l
iadd:	LD A,H ;extend the sign of (hl) to b
	RLA ;get sign in carry
	SBC A
iadds:	LD B,A ;save the sign
	PUSH HL ;save the second argument in case of overflow
	LD A,D ;extend the sign of (de) to a
	RLA ;get sign in carry
	SBC A
	ADD HL,DE ;add the two lo'S
	ADC B ;add the extra ho
	RRCA ;if the lsb of a is different from the msb of
	XOR H ; h, then overflow occured
	JP P,conis1 ;no overflow, get old (hl) off stack and we
					; are done, save (hl) in the fac also
	PUSH BC ;overflow -- save extended sign of (hl)
	EX DE,HL ;get (de) in (hl)
	CALL consih ;float it
	POP AF ;get sign of (hl) in a
	POP HL ;get old (hl) back
	CALL pushf ;put first argument on stack
	EX DE,HL ;put second argument in (de) for floatr
	CALL inegad ;float it
	JP faddt ;add the two numbers using single precision


					;integer multiplication		(hl):=(de)*(hl)
					;alters a,b,c,d,e,h,l
imult:	LD A,H ;check (hl) if is zero, if so
	OR L ; just return.  this is for speed.
	JP Z,makint ;update faclo to be zero and return
	PUSH HL ;save second argument in case of overflow
	PUSH DE ;save first argument
	CALL imuldv ;fix up the signs
	PUSH BC ;save the sign of the result
	LD B,H ;copy second argument into (bc)
	LD C,L
	LD HL,0 ;zero (hl), that is where the product goes
	LD A,20o ;set up a count
imult1:	ADD HL,HL ;rotate product left one
	JP C,imult5 ;check for overlfow
	EX DE,HL ;rotate first argument left one to see if
	ADD HL,HL ; we add in (bc) or not
	EX DE,HL
	JP NC,imult2 ;don'T ADD IN ANYTHING
	ADD HL,BC ;add in (bc)
	JP C,imult5 ;check for overlfow
imult2:	DEC A ;are we done?
	JP NZ,imult1 ;no, do it again
	POP BC ;we are done, get sign of result
	POP DE ;get original first argument
imldiv:	LD A,H ;entry from idiv, is result .ge. 32768?
	OR A
	JP M,imult3 ;it is, check for special case of -32768
	POP DE ;result is ok, get second argument off stack
	LD A,B ;get the sign of result in a
	JP inega ;negate the result if necessary
imult3:	XOR 200o ;is result 32768?
	OR L ;note: if we get here from idiv, the result
	JP Z,imult4 ; must be 32768, it cannot be greater
	EX DE,HL ;it is .gt. 32768, we have overflow
	db	001 ;"LXI	B" over next 2 bytes
imult5:	POP BC ;get sign of result off stack
	POP HL ;get the original first argument
	CALL consih ;float it
	POP HL ;get the original second argument
	CALL pushf ;save floated first arument
	CALL consih ;float second argument
fmultt:	POP BC
	POP DE
					;get first argument off stack, entry from polyx
	JP fmult ;multiply the arguments using single precision
imult4:	LD A,B ;is result +32768 or -32768?
	OR A ;get its sign
	POP BC ;discard original second argument
	JP M,makint ;the result should be negative, it is ok
	PUSH DE ;it is positive, save remainder for mod
	CALL consih ;float -32768
	POP DE ;get mod'S REMAINDER BACK
	JP neg ;negate -32768 to get 32768, we are done


					;integer division	(hl):=(de)/(hl)
					;remainder is in (de), quotient in (hl)
					;alters a,b,c,d,e,h,l
idiv:	LD A,H ;check for division by zero
	OR L
	JP Z,dv0err ;we have division by zero!!
	CALL imuldv ;fix up the signs
	PUSH BC ;save the sign of the result
	EX DE,HL ;get denominator in (hl)
	CALL ineghl ;negate it
	LD B,H ;save negated denominator in (bc)
	LD C,L
	LD HL,0 ;zero where we do the subtraction
	LD A,21o ;set up a count
	PUSH AF ;save it
	OR A ;clear carry 
	JP idiv3 ;go divide
idiv1:	PUSH AF ;save count
	PUSH HL ;save (hl) i.e. current numerator
	ADD HL,BC ;subtract denominator
	JP NC,idiv2 ;we subtracted too much, get old (hl) back
	POP AF ;the subtraction was good, discard old (hl)
	SCF ;next bit in quotient is a one
	db	076o ;"MVI	A" over next byte
idiv2:	POP HL ;ignore the subtraction, we couldn'T DO IT
idiv3:	LD A,E ;shift in the next quotient bit
	RLA
	LD E,A
	LD A,D ;shift the ho
	RLA
	LD D,A
	LD A,L ;shift in the next bit of the numerator
	RLA
	LD L,A
	LD A,H ;do the ho
	RLA
	LD H,A ;save the ho
	POP AF ;get count back
	DEC A ;are we done?
	JP NZ,idiv1 ;no, divide again
	EX DE,HL ;get quotient in (hl), remainder in (de)
	POP BC ;get sign of result
	PUSH DE ;save remainder so stack will be alright
	JP imldiv ;check for special case of 32768


					;get ready to multiply or divide
					;alters a,b,c,d,e,h,l
imuldv:	LD A,H ;get sign of result
	XOR D
	LD B,A ;save it in b
	CALL inegh ;negate second argument if necesary
	EX DE,HL ;put (de) in (hl), fall in and negate first
					; argument if necessary


					;negate h,l
					;alters a,c,h,l
inegh:	LD A,H ;get sign of (hl)
inega:	OR A ;set condition codes
	JP P,makint ;we don'T HAVE TO NEGATE, IT IS POSITIVE
					;save the result in the fac for when
					; operators return through here
ineghl:	XOR A ;clear a
	LD C,A ;store a zero (we use this method for isub)
	SUB L ;negate lo
	LD L,A ;save it
	LD A,C ;get a zero back
	SBC H ;negate ho
	LD H,A ;save it
	JP makint ;all done, save the result in the fac
					; for when operators return through here


					;integer negation
					;alters a,b,c,d,e,h,l
ineg:	LD HL,(faclo) ;get the integer
	CALL ineghl ;negate it
	LD A,H ;get the high order
	XOR 200o ;check for special case of 32768
	OR L
	RET NZ ;it did not occur, everything is fine
ineg2:	EX DE,HL ;we have it, float 32768
	CALL valsng ;change valtyp to "SINGLE PRECISION"
	XOR A ;get a zero for the high order
inegad:	LD B,230o ;entry from iadd, set exponent
	JP floatr ;go float the number


					;mod operator
					;(hl):=(de)-(de)/(hl)*(hl),  (de)=quotient
					;alters a,b,c,d,e,h,l
imod:	PUSH DE ;save (de) for its sign
	CALL idiv ;divide and get the remainder
	XOR A ;turnoff the carry and tranfer
	ADD D ;the remainder*2 which is in [d,e]
	RRA ;to [h,l] dividing by two
	LD H,A
	LD A,E
	RRA
	LD L,A ; ***whg01*** fix to mod operator
	CALL valint ;set valtyp to "INTEGER" in case result of
					; the division was 32768
	POP AF ;get the sign of the remainder back
	JP inega ;negate the remainder if necessary
	page

	subttl	double precision arithmetic routines
;
;	double precision arithmetic conventions
;
;double precision numbers are 8 byte quantities
;the last 4 bytes in memory are in the same format as single precision numbers
;the first 4 bytes are 32 more low order bits of precision
;the lowest order byte comes first in memory
;
;calling conventions:
;for one argument functions:
;	the argument is in the fac, the result is left in the fac
;for two argument operations:
;	the first argument is in the fac
;	the second argument is in arg-7,6,5,4,3,2,1,0  (note: arglo=arg-7)
;	the result is left in the fac
;note:	this order is reversed from int and sng
;valtyp(double precision)=10 octal
;%


					;double precision subtraction	fac:=fac-arg
					;alters all registers
dsub:	LD HL,args ;5.21: negate the second argument (sign byte)
	LD A,(HL) ;get the ho and sign
	XOR 200o ;complemnt the sign
	LD (HL),A ;put it back
					;fall into dadd


					;double precision addition	fac:=fac+arg
					;alters all registers
dadd:	LD HL,arg ;get  pointer to exponent of first argument
	LD A,(HL) ;check if it is zero
	OR A
	RET Z ;it is, result is already in fac
	LD B,A ;save exponent for unpacking
	DEC HL ;point to ho and sign
	LD C,(HL) ;get ho and sign for unpacking
	LD DE,fac ;get pointer to exponent of second argument
	LD A,(DE) ;get exponent
	OR A ;see if it is zero
	JP Z,vmovfa ;it is, move arg to fac and we are done
	SUB B ;subtract exponents to get shift count
	JP NC,dadd2 ;put the smaller number in fac
	CPL ;negate shift count
	INC A
	PUSH AF ;save shift count
	LD C,10o ;switch fac and arg, set up a count
	INC HL ;point to arg
	PUSH HL ;save pointer to arg
dadd1:	LD A,(DE) ;get a byte of the fac
	LD B,(HL) ;get a byte of arg
	LD (HL),A ;put the fac byte in arg
	LD A,B ;put the arg byte in a
	LD (DE),A ;put the arg byte in fac
	DEC DE ;point to the next lo byte of fac
	DEC HL ;point to the next lo byte of arg
	DEC C ;are we done?
	JP NZ,dadd1 ;no, do the next lo byte
	POP HL ;get the ho back
	LD B,(HL) ;get the exponent
	DEC HL ;point to the ho and sign
	LD C,(HL) ;get ho and sign for unpacking
	POP AF ;get the shift count back
dadd2:	CP 71o ;are we within 56 bits?
	RET NC ;no, all done
	PUSH AF ;save shift count
	CALL unpack ;unpack the numbers
	LD HL,arglox ;point to arglox
	LD B,A ;save subtraction flag
	LD A,0 ;
	LD (HL),A ;clear temporary least sig byte
	LD (dfacx),A ;clear extra byte
	POP AF ;get shift count
	LD HL,args ;5.21: point to the sign byte of arg
	CALL dshftr ;shift arg right the right number of times
	LD A,B ;5.21: reorder
	OR A ;get subtraction flag
	JP P,dadd3 ;subtract numbers if their signs are different
	LD A,(arglox) ;transfer overflow byte
	LD (dfacx),A ;from arg to fac
	CALL daddaa ;signs are the same, add the numbers
	JP NC,dround ;round the result if no carry
	EX DE,HL ;get pointer to fac in (hl)
	INC (HL) ;add 1 to exponent
	JP Z,ovfin4
	CALL dshfrb ;shift number right one, shift in carry
	JP dround ;round the result
dadd3:
	db	076o ;"MVI	A", subtract the numbers
	SBC (HL) ;get the subtract instruction in a
	CALL dadda ;subtract the numbers
	LD HL,fac+1 ;fix [h,l] to point to sign for dnegr
	CALL C,dnegr ;negate the result if it was negative
					;fall into dnorml


					;normalize fac
					;alters a,b,c,d,h,l
dnorml:	XOR A ;clear shift count
dnorm1:	LD B,A ;save shift count
	LD A,(facs) ;get ho
	OR A ;see if we can shift 8 left
	JP NZ,dnorm5 ;we can'T, SEE IF NUMBER IS NORMALIZED
	LD HL,dfacx ;we can, get pointer to lo
	LD C,10o ;set up a count
dnorm2:	LD D,(HL) ;get a byte of fac
	LD (HL),A ;put in byte from last location, the first
					; time through a is zero
	LD A,D ;put the current byte in a for next time
	INC HL ;increment pointer to next higher order
	DEC C ;are we done?
	JP NZ,dnorm2 ;no, do the next byte
	LD A,B ;subtract 8 from shift count
	SUB 10o
	CP 300o ;have we shifted all bytes to zero?
	JP NZ,dnorm1 ;no, try to shift 8 more
	JP zero ;yes, the number is zero
dnorm3:	DEC B ;decrement shift count
	LD HL,dfacx ;get pointer to lo
	CALL dshflc ;shift the fac left
	OR A ;see if number is normalized
dnorm5:	JP P,dnorm3 ;shift fac left one if it is not normalized
	LD A,B ;get the shift count
	OR A ;see if no shifting was done
	JP Z,dround ;none was, proceed to round the number
	LD HL,fac ;get pointer to exponent
	ADD (HL) ;update it
	LD (HL),A ;save updated exponent
	JP NC,zero ;underflow, the result is zero
	RET Z ;result is already zero, we are done
					;fall into dround and round the result


					;round fac
					;alters a,b,h,l
dround:	LD A,(dfacx) ;get extra byte to see if we have to round
drounb:	OR A ;entry from ddiv
	CALL M,drouna ;round up if necessary
	LD HL,fac+1 ;get pointer to unpacked sign
	LD A,(HL) ;get sign
	AND 200o ;isolate sign bit
	DEC HL ;point to ho
	DEC HL
	XOR (HL) ;pack sign and ho
	LD (HL),A ;put packed sign and ho in fac
	RET ;we are done



					;subroutine for round: add one to fac
drouna:	LD HL,dfaclo ;get pointer to lo, entry from dint
	LD B,7 ;set up a count
drona1:	INC (HL) ;increment a byte
	RET NZ ;return if there was no carry
	INC HL ;increment pointer to next higher order
	DEC B ;have we incremented all bytes
	JP NZ,drona1 ;no, try the next one
	INC (HL) ;yes, increment the exponent
	JP Z,ovfin4
	DEC HL ;the number overflowed its exponent
	LD (HL),200o ;put 200 in ho
	RET ;all done


					;add or subtract 2 dbl quantities
					;alters a,c,d,e,h,l
daddd:	LD DE,fbufp27 ;entry from ddiv
	LD HL,arglo ;add or subtract fbuffr+^d27 and arg
	JP dadds ;do the operation

daddaa:	db	076o ;"MVI	A", entry from dadd, dmult
	ADC (HL) ;setup add instruction for loop
dadda:	LD HL,arglo ;get pointer to arg, entry from dadd
daddfo:	LD DE,dfaclo ;get pointer to fac, entry from fout
dadds:	LD C,7 ;set up a count
dadds1:
	LD (daddop),A ;store the add or subtract instruction
	XOR A ;clear carry
daddl:	LD A,(DE) ;get a byte from result number
daddop:	ADC (HL) ;this is either "ADC	M" or "SBB	M"
	LD (DE),A ;save the changed byte
	INC DE ;increment pointers to next higher order byte
	INC HL
	DEC C ;are we done?
	JP NZ,daddl ;no, do the next higher order byte
	RET ;all done




					;negate signed number in fac
					;this is used by dadd, dint
					;alters a,b,c,h,l
dnegr:	LD A,(HL) ;complement sign of fac
	CPL ;use the unpacked sign byte
	LD (HL),A ;save the new sign
	LD HL,dfacx ;get pointer to lo
	LD B,10o ;set up a count
	XOR A ;clear carry and get a zero
	LD C,A ;save zero in c
dnegr1:	LD A,C ;get a zero
	SBC (HL) ;negate the byte of fac
	LD (HL),A ;update fac
	INC HL ;increment pointer to next higher order byte
	DEC B ;are we done?
	JP NZ,dnegr1 ;no, negate the next byte
	RET ;all done


					;shift dbl fac right one
					;a = shift count
					;alters a,c,d,e,h,l
dshftr:	LD (HL),C ;put the unpacked ho back
	PUSH HL ;save pointer to what to shift
dshfr1:	SUB 10o ;see if we can shift 8 right
	JP C,dshfr3 ;we can'T, CHECK IF WE ARE DONE
	POP HL ;get pointer back
dshfrm:	PUSH HL ;entry from dmult, save pointer to ho
	LD DE,10o*400o+0 ;shift a zero into the ho, set up a count
dshfr2:	LD C,(HL) ;save a byte of fac
	LD (HL),E ;put the last byte in its place
	LD E,C ;set up e for next time through the loop
	DEC HL ;point to next lower order byte
	DEC D ;are we done?
	JP NZ,dshfr2 ;no, do the next byte
	JP dshfr1 ;yes, see if we can shift over 8 more
dshfr3:	ADD 11o ;correct shift count
	LD D,A ;save shift count in d
dshfr4:	XOR A ;clear carry
	POP HL ;get pointer to ho
	DEC D ;are we done?
	RET Z ;yes
dshfra:	PUSH HL ;no, save pointer to lo, entry from dadd, dmult
	LD E,10o ;set up a count, rotate fac one left
dshfr5:	LD A,(HL) ;get a byte of the fac
	RRA ;rotate it left
	LD (HL),A ;put the updated byte back
	DEC HL ;decrement pointer to next lower order byte
	DEC E ;are we done?
	JP NZ,dshfr5 ;no, rotate the next lower order byte
	JP dshfr4 ;yes, see if we are done shifting

					;entry to dshftr from dadd, dmult
dshfrb:	LD HL,facs ;get pointer to ho of fac
	LD D,1 ;shift right once
	JP dshfra ;go do it


					;rotate fac left one
					;alters a,c,h,l
dshflc:	LD C,10o ;set up a count
dshftl:	LD A,(HL) ;
	RLA ;rotate it left one
	LD (HL),A ;update byte in fac
	INC HL ;increment pointer to next higher order byte
	DEC C ;are we done?
	JP NZ,dshftl
	RET ;all done


					;double precision multiplication	fac:=fac*arg
					;alters all registers
dmult:	CALL sign ;check if we are multiplying by zero
	RET Z ;yes, all done, the fac is zero
	LD A,(arg) ;must see if arg is zero
	OR A
	JP Z,zero ;return zero

	CALL muldva ;add exponents and take care of signs
	CALL dmuldv ;zero fac and put fac in fbuffr
	LD (HL),C ;put unpacked ho in arg
	INC DE ;get pointer to lo of arg
	LD B,7 ;set up a count
dmult2:	LD A,(DE) ;get the byte of arg to multiply by
	INC DE ;increment pointer to next higher byte
	OR A ;check if we are multiplying by zero
	PUSH DE ;save pointer to arg
	JP Z,dmult5 ;we are
	LD C,10o ;set up a count
dmult3:	PUSH BC ;save counters
	RRA ;rotate multiplier right
	LD B,A ;save it
	CALL C,daddaa ;add in old fac if bit of multipier was one
	CALL dshfrb ;rotate product right one
	LD A,B ;get multiplier in a
	POP BC ;get counters back
	DEC C ;are we done with this byte of arg?
	JP NZ,dmult3 ;no, multiply by the next bit of the multiplier
dmult4:	POP DE ;yes, get pointer into arg back
	DEC B ;are we done?
	JP NZ,dmult2 ;no, multiply by next higher order by of arg
					;point is to right of understood one
	JP dnorml ;all done, normalize and round result
dmult5:	LD HL,facs ;get pointer to ho of fac
	CALL dshfrm ;shift product right one byte, we are
	JP dmult4 ; multiplyiing by zero

					;constant for div10, ddiv10
tenth:	db	315o
	db	314o
	db	314o
	db	314o
	db	314o
	db	314o
	db	114o
	db	175o
dten:	db	000 ; 10d0
	db	000
	db	000
	db	000
ften:	db	000 ; 10.0
	db	000
	db	040o
	db	204o

					;double precision divide fac by 10
					;alters all registers
ddiv10:;double precision divide fac by 10
					;(fac)=(fac)*3/4*16/15*1/8
	LD A,(fac) ;must assure ourselves we can do
	CP 101o ;65 exponent decrements w/o 
	JP NC,dd04 ;reaching zero
	LD DE,tenth ;point to .1d0
	LD HL,arglo ;point to arg
	CALL vmove
	JP dmult
dd04:
	LD A,(facs) ;negative no?
	OR A
	JP P,dd05
	AND 177o ;want only pos. nos.
	LD (facs),A
	LD HL,neg
	PUSH HL ;will negate when finished
dd05:
	CALL $decf1 ;divide fac by 2
	LD DE,dfaclo
	LD HL,arglo
	CALL vmove
	CALL $decf1 ;divide fac by 2
	CALL dadd ;(fac)=(fac)+(arg)
	LD DE,dfaclo
	LD HL,arglo
	CALL vmove ;(arg)=(fac)
	LD A,15
dd10:	PUSH AF ;save loop counter
	CALL $deca4 ;(arg)=(arg)/16
	CALL $psarg ;push arg on the stack
	CALL dadd ;(fac)=(fac)+(arg)
	LD HL,args ;5.21: point to arg sign byte
	CALL $pparg ;pop arg off the stack
	POP AF ;fetch loop counter
	DEC A
	JP NZ,dd10
	CALL $decf1
	CALL $decf1 ;5.21: fall into $decf1 (no third call, no ret)
$decf1:	LD HL,fac
	DEC (HL) ;(fac)=(fac)/2
	RET NZ
	JP zero ;underflow
$deca4:;(arg)=(arg)/16
	LD HL,arg
	LD A,4
dc4:	DEC (HL)
	RET Z
	DEC A
	JP NZ,dc4
	RET
$psarg:;push double precision arg on the stack
	POP DE ;get our return address off the stack
	LD A,4
	LD HL,arglo
psa10:	LD C,(HL) ;fetch byte
	INC HL
	LD B,(HL)
	INC HL
	PUSH BC
	DEC A ;through?
	JP NZ,psa10
	PUSH DE
	RET
$pparg:;pop arg off the stack
	POP DE ;get our return address off the stack
	LD A,4
	LD HL,arg
ppa10:	POP BC
	LD (HL),B
	DEC HL
	LD (HL),C
	DEC HL
	DEC A
	JP NZ,ppa10
	PUSH DE
	RET
					;double precision division	fac:=fac/arg
					;alters all registers
ddiv:	LD A,(arg) ;check for division by zero
	OR A ;get the exponent of arg
	JP Z,indv0a ;5.21: jumps directly to indv0a
	LD A,(fac) ;if fac=0 then ans is zero
	OR A
	JP Z,zero
	CALL muldvs ;subtract exponents and check signs
	INC (HL) ;muldiv different for truans=0
	INC (HL) ;must correct for incorrect exp calc
	JP Z,ovfin4
	CALL dmuldv ;zero fac and put fac in fbuffr
	LD HL,fbufp34 ;get pointer to the extra ho byte we will use
	LD (HL),C ;zero it
	LD B,C ;zero flag to see when we start dividing
ddiv1:
	db	076o ;"MVI	A", subtract arg from fbuffr
	SBC (HL) ;get subtract instruction
	CALL daddd ;do the subtraction
	LD A,(DE) ;subtract from extra ho byte
	SBC C ;here c=0
	CCF ;carry=1 if subtraction was good
	JP C,ddiv2 ;was it ok?
	db	076o ;"MVI	A"  no, add fbuffr back in
	ADC (HL) ;get add instruction
	CALL daddd ;do the addition
	XOR A ;clear carry
	db	332o ;"JC" over next two bytes
ddiv2:	LD (DE),A ;store the new highest order byte
	INC B ;increment flag to show we could divide
	LD A,(facs) ;check if we are done dividing
	INC A ;set sign flag without affecting carry
	DEC A
	RRA ;put carry in msb for dround
	JP M,drounb ;we are done, we have 57 bits of accuracy
	RLA ;get old carry back where it belongs
	LD HL,dfaclo ;get pointer to lo of fac
	LD C,7 ;set up a count, shift fac left one
	CALL dshftl ;shift in the next bit in the quotient
	LD HL,fbufp27 ;get pointer to lo in fbuffr
	CALL dshflc ;shift dividend one left
	LD A,B ;is this the first time and was the
	OR A ; subtraction not good? (b will get
	JP NZ,ddiv1 ; changed on the first or second subtraction)
	LD HL,fac ;yes, subtract one from exponent to correct
	DEC (HL) ; scaling
	JP NZ,ddiv1 ;continue dividing if no underflow
	JP zero ;underflow


					;transfer fac to fbuffr for dmult and ddiv
					;alters a,b,c,d,e,h,l
dmuldv:
	LD A,C ;put unpacked ho back in arg
	LD (args),A ;5.21: store to arg sign byte
	DEC HL ;point to ho of fac
	LD DE,fbufp33 ;point to end of fbuffr
	LD BC,7*400o+0 ;set up a count
					;to fbuffr
dmldv1:	LD A,(HL) ;get a byte from fac
	LD (DE),A ;put it in fbuffr
	LD (HL),C ;put a zero in fac
	DEC DE ;point to next byte in fbuffr
	DEC HL ;point to next lower order byte in fac
	DEC B ;are we done?
	JP NZ,dmldv1 ;no, transfer the next byte
	RET ;all done



					;double precision multiply the fac by 10
					;alters all registers
dmul10:	CALL vmovaf ;save the fac in arg
					;vmovaf exits with (de)=fac+1
	EX DE,HL ;get the pointer into the fac in (hl)
	DEC HL ;point to the exponent
	LD A,(HL) ;get the exponent
	OR A ;is the number zero?
	RET Z ;yes, all done
	ADD 2 ;multiply fac by 4 by adding 2 to the exponent
	JP C,ovfin4
	LD (HL),A ;save the new exponent
	PUSH HL ;save pointer to fac
	CALL dadd ;add in the original fac to get 5 times  fac
	POP HL ;get the pointer to fac back
	INC (HL) ;add one to exponent to get 10 times fac
	RET NZ ;all done if overflow did not occur
	JP ovfin4
					;multiply fac by 10
	page
	subttl	floating point input routine
					;alters all registers
					;the number is left in fac
					;at entry, (hl) points to the first character in a text buffer.
					;the first character is also in a.  we pack the digits into the fac
					;as an integer and keep track of where the decimal point is.
					;c is 377 if we have not seen a decimal point, 0 if we have.
					;b is the number of digits after the decimal point.
					;at the end, b and the exponent (in e) are used to determine how many
					;times we multiply or divide by ten to get the correct number.
findbl:	CALL zero ;zero the fac
	CALL valdbl ;force to double precision
	db	366o ;"ORI" over "XRA A" so frcint is not called
fin:
	XOR A ;force call to frcint
	LD BC,finovc ;when done store overflow flag
	PUSH BC ;into strovc and go to normal overflow mode
	PUSH AF ;set up once only overflow mode
	LD A,1
	LD (flgovc),A
	POP AF
finchr:	EX DE,HL ;save the text pointer in (de)
	LD BC,377o+0 ;clear flags:  b=decimal place count
					;c="." flag
	LD H,B ;zero (hl)
	LD L,B
	CALL Z,makint ;zero fac, set valtyp to "INTEGER"
	EX DE,HL ;get the text pointer back in (hl) and 
					; zeros in (de)
	LD A,(HL) ;restore char from memory
	CP '&'
	JP Z,octcns
					;restore [a]
					;if we are called by val or input or read, the signs may not be crunched
	CP '-' ;see if number is negative
	PUSH AF ;save sign
	JP Z,fin1 ;ignore minus sign
	CP '+' ;ignore a leading sign
	JP Z,fin1
	DEC HL ;set character pointer back one
fin1:
					;here to check for a digit, a decimal point, "E" or "D"
finc:	CALL chrgtr ;get the next character of the number
	JP C,findig ;we have a digit
	CP '.' ;check for a decimal point
	JP Z,findp ;we have one, i guess
	CP 145o ;lower case "E"
	JP Z,finc1
	CP 'E' ;check for a single precision exponent
finc1:
	JP NZ,note ;no
	PUSH HL ;save text ptr
	CALL chrgtr ;get next char
	CP 'L'+40o ;see if lower case "L"
	JP Z,wuzels ;if so possible else
	CP 'L' ;is this really an "ELSE"?
	JP Z,wuzels ;was else
	CP 'Q'+40o ;see if lower case "Q"
	JP Z,wuzels ;if so possible "EQV"
	CP 'Q' ;possible "EQV"
wuzels:	POP HL ;restore [h,l]
	JP Z,wuz ;it was jump!
	LD A,(valtyp) ;if double don'T DOWNGRADE TO SINGLE
	CP 10o ;set condition codes
	JP Z,finex1
	LD A,0 ;make a=0 so number is a single
	JP finex1
wuz:
	LD A,(HL) ;restore original char
note:
	CP '%' ;trailing % (rsts-11 compatibility)
	JP Z,finint ;must be integer.
	CP '#' ;force double precision?
	JP Z,findbf ;yes, force it & finish up.
	CP '!' ;force single prec.
	JP Z,finsnf
	CP 144o ;lower case "D"
	JP Z,finex1
	CP 'D' ;check for a double precision exponent
	JP NZ,fine ;we don'T HAVE ONE, THE NUMBER IS FINISHED
finex1:	OR A ;double precision number -- turn off zero flag
finex:	CALL finfrc ;force the fac to be sng or dbl
	CALL chrgtr ;get the first character of the exponent
	CALL minpls ;eat sign of exponent
					;here to get the next digit of the exponent
finec:	CALL chrgtr ;get the next charater
	JP C,finedg ;pack the next digit into the exponent
	INC D ;it was not a digit, put the correct sign on
	JP NZ,fine ; the exponent, it is positive
	XOR A ;the exponent is negative
	SUB E ;negate it
	LD E,A ;save it again
					;here to finish up the number
fine:	PUSH HL ;save the text pointer
	LD A,E ;find out how many times we have to multiply
	SUB B ; or divide by ten
	LD E,A ;save new exponent in e
					;here to multiply or divide by ten the correct number of times
					;if the number is an int, a is 0 here.
fine2:	CALL P,finmul ;multiply if we have to
	CALL M,findiv ;divide if we have to
	JP NZ,fine2 ;multiply or divide again if we are not done
					;here to put the correct sign on the number
	POP HL ;get the text pointer
	POP AF ;get the sign
	PUSH HL ;save the text pointer again
	CALL Z,vneg ;negate if necessary
fine2c:	POP HL ;get the text pointer in (hl)
	CALL getypr ;we want -32768 to be an int, but until now
					; it would be a sng
	RET PE ;it is not sng, so it is not -32768
	PUSH HL ;we have a sng, save text pointer
	LD HL,pophrt ;get address that pop'S H OFF STACK BECAUSE
	PUSH HL ; conis2 does funny things with the stack
	CALL conis2 ;check if we have -32768
	RET ;we don'T, POPHRT IS STILL ON THE STACK SO
					; we can just return

					;here to check if we have seen 2 decimal points and set the decimal
					; point flag
findp:	CALL getypr ;set carry if we don'T HAVE A DOUBLE
	INC C ;set the flag
	JP NZ,fine ;we had 2 decimal points, now we are done
	CALL C,finfrc ;this is the first one, convert fac to sng
					; if we don'T ALREADY HAVE A DOUBLE
	JP finc ;continue looking for digits

finint:	CALL chrgtr
	POP AF ;get sign off the stack
	PUSH HL ;save text pointer
	LD HL,pophrt ;address pop (hl) and return
	PUSH HL ;
	LD HL,frcint ;address to force integer
	PUSH HL ;will want to force once d.p. done
	PUSH AF ;put sign back on the stack
	JP fine ;all done
findbf:	OR A ;set non-zero to force double prec
finsnf:	CALL finfrc ;force the type
	CALL chrgtr ;read after terminator
	JP fine ;all done

					;force the fac to be sng or dbl
					;if the zero flag is on, then force the fac to be sng
					;if the zero flag is off, force the fac to be dbl
finfrc:	PUSH HL ;save text pointer
	PUSH DE ;save exponent information
	PUSH BC ;save decimal point information
	PUSH AF ;save what we want the fac to be
	CALL Z,frcsng ;convert to sng if we have to
	POP AF ;get type flag back
	CALL NZ,frcdbl ;convert to dbl if we have to
	POP BC ;get decimal point information back
	POP DE ;get exponent information back
	POP HL ;get text pointer back
	RET ;all done

					;this subroutine muliplies by ten once.
					;it is a subroutine because it saves bytes when we check if a is zero
					;alters all registers
finmul:	RET Z ;return if exponent is zero, entry from fout
finmlt:	PUSH AF ;save exponent, entry from fout
	CALL getypr ;see what kind of number we have
	PUSH AF ;save the type
	CALL PO,mul10 ;we have a sng, multiply by 10.0
	POP AF ;get the type back
	CALL PE,dmul10 ;we have a dbl, multiply by 10d0
	POP AF ;get exponent
dcrart:	DEC A ;decrease it
	RET ;all done

					;this subroutine divides by ten once.
					;it is used by fin, fout
					;alters a,b,c
findiv:	PUSH DE ;save d,e
	PUSH HL ;save h,l
	PUSH AF ;we have to divide -- save count
	CALL getypr ;see what kind of number we have
	PUSH AF ;save the type
	CALL PO,div10 ;we have a sng number
	POP AF ;get the type back
	CALL PE,ddiv10 ;we have a dbl number
	POP AF ;get count back
	POP HL ;get h,l back
	POP DE ;get d,e back
	INC A ;update it
	RET

					;here to pack the next digit of the number into the fac
					;we multiply the fac by ten and add in the next digit
findig:
	PUSH DE ;save exponent information
	LD A,B ;increment decimal place count if we are
	ADC C ; past the decimal point
	LD B,A
	PUSH BC ;save decimal point information
	PUSH HL ;save text pointer
	LD A,(HL) ;get the digit
	SUB '0' ;convert it to ascii
	PUSH AF ;save the digit
	CALL getypr ;see what kind of a number we have
	JP P,findgv ;we do not have an integer
					;here to pack the next digit of an integer
	LD HL,(faclo) ;we have an integer, get it in (hl)
	LD DE,3277+0 ;see if we will overflow
	CALL dcompr ;compar returns with carry on if
	JP NC,findg2 ; (hl) .lt. (de), so the number is too big
	LD D,H ;copy (hl) into (de)
	LD E,L
	ADD HL,HL ;multiply (hl) by 2
	ADD HL,HL ;multiply (hl) by 2, (hl) now is 4*(de)
	ADD HL,DE ;add in old (hl) to get 5*(de)
	ADD HL,HL ;multiply by 2 to get ten times the old (hl)
	POP AF ;get the digit
	LD C,A ;save it so we can use dad, b is already zero
	ADD HL,BC ;add in the next digit
	LD A,H ;check for overflow
	OR A ;overflow occured if the msb is on
	JP M,findg1 ;we have overflow!!
	LD (faclo),HL ;everything is fine, store the new number
findge:	POP HL ;all done, get text pointer back
	POP BC ;get decimal point information back
	POP DE ;get exponent information back
	JP finc ;get the next character
					;here to handle 32768, 32769
findg1:	LD A,C ;get the digit
	PUSH AF ;put it back on the stack
					;here to convert the integer digits to single precision digits
findg2:	CALL consi ;convert the integer to single precision
	SCF ;do not take the following jump
					;here to decide if we have a single or double precision number
findgv:	JP NC,findgd ;fall through if valtyp was 4 i.e. sng prec
	LD BC,224q*256+164q
	LD DE,044q*256+000q ;get 1000000, do we have 7 digits already?
	CALL fcomp ;if so, fac .ge. 1000000
	JP P,findg3 ;we do, convert to double precision
	CALL mul10 ;multiply the old number by ten
	POP AF ;get the next digit
	CALL finlog ;pack it into the fac
	JP findge ;get flags off stack and we are done
					;here to convert a 7 digit single precision number to double precision
findg3:	CALL conds ;convert single to double precision
					;here to pack in the next digit of a double precision number
findgd:	CALL dmul10 ;multiply the fac by 10
	CALL vmovaf ;save the fac in arg
	POP AF ;get the next digit
	CALL float ;convert the digit to single precision
	CALL conds ;now, convert the digit to double precision
	CALL dadd ;add in the digit
	JP findge ;get the flags off the stack and we are done

					;subroutine for fin, log
finlog:	CALL pushf ;save fac on stack
	CALL float ;convert a to a floating point number
faddt:	POP BC
	POP DE
					;get previous number off stack
	JP fadd ;add it in

					;here we pack in the next digit of the exponent
					;we mutiply the old exponent by ten and add in the next digit
					;note: exponent overflow is not checked for
finedg:	LD A,E ;exponent digit -- multiply exponent by 10
	CP 12o ;check that the exponent does not overflow
					;if it did, e could get garbage in it.
	JP NC,finedo ;we already have two digits
	RLCA ;first by 4
	RLCA
	ADD E ;add 1 to make 5
	RLCA ;now double to get 10
	ADD (HL) ;add it in
	SUB '0' ;subtract off ascii code, the result is
					; positive on length=2 because of the
					; above check
	LD E,A ;store exponent
	db	372o ;"JM" over the next 2 bytes
finedo:	LD E,127 ;an exponent like this will safely cause
					; overflow or underflow
	JP finec ;continue
;5.21: removed dead code ovfin1 and ovfin9
ovfin2:	PUSH HL ;
	LD HL,facs ;point (hl) to sign byte
	CALL getypr
	JP PO,ovf2a ;sp proceed as normal
	LD A,(args) ;5.21: get arg sign byte
	JP ovf2b
ovf2a:
	LD A,C
ovf2b:
	XOR (HL) ;sign in high bit of (a)
	RLA ;sign in carry
	POP HL ;
	JP ovfint
;5.21: removed dead ovfin5
ovfin6:	POP AF
ovfin7:	POP AF
ovfin3:	LD A,(facs)
	RLA
	JP ovfint
ovfin8:	POP AF ;do a pop then fall into ovfin4
ovfin4:	LD A,(fac+1) ;get sign byte
	CPL ;sign was stored complemented
ovfi4b:	RLA ;sign to carry
	JP ovfint
intdv1:	LD A,C
	JP intdv2 ;
indv0a:
	LD A,(args) ;5.21: get arg sign byte
intdv2:	RLA ;to carry
	LD HL,divmsg ;get message address
	LD (overri),HL ;store so ovfint will pick up
ovfint:;ansi overflow routine
	PUSH HL
	PUSH BC
	PUSH DE
	PUSH AF ;save machine status
	PUSH AF ;again
	LD HL,(onelin) ;trapping errors?
	LD A,H
	OR L
	JP NZ,ovfprt ;jump print if trapping
					;otherwise +infinity
	LD HL,flgovc ;5.21: uses lxi h pattern
	LD A,(HL) ;print indicator flag
	OR A ;print if 0,1;set to 2 if 1
	JP Z,ov1a ;go print
	DEC A ;5.21: dcr a instead of cpi 1
	JP NZ,ov1b
	INC (HL) ;5.21: H points to flgovc, inr m
ov1a:
	LD HL,(overri) ;address of overflow message
	CALL strprn ;print
	LD (ttypos),A ;set tty position to char 0
					;set tty position to char 0
	LD A,15o
	CALL caltty
	LD A,12o
	CALL caltty ;carriage return,line feed
ov1b:
ovfprt:	POP AF ;get plus,minus indication back
	LD HL,faclo ;must now put right infinity
					;into the fac
	LD DE,infp
	JP NC,ovfina
	LD DE,infm ;minus infinity
ovfina:	CALL move ;move into fac
	CALL getypr
	JP C,ovfinb ;5.21: jc instead of jpo
	LD HL,dfaclo
	LD DE,infm ;all ones
	CALL move
ovfinb:
	LD HL,(onelin) ;trapping errors?
	LD A,H
	OR L ;Z flag set if not trapping
	LD HL,(overri) ;get old overflow msg ptr
	LD DE,ovrmsg ;new msg ptr
	EX DE,HL ;hl=ovrmsg, de=old overri
	LD (overri),HL ;always store ovrmsg
	JP Z,noodtp ;if not trapping, exit
	CALL dcompr ;compare old ptr with ovrmsg
	JP Z,overr ;if was ovrmsg, overflow error
	JP dv0err ;else division by zero
noodtp:
	POP AF ;restore regs and return
	POP DE
	POP BC
	POP HL
	RET
infp:	db	377o
	db	377o
	db	177o
	db	377o
infm:	db	377o
	db	377o
	db	377o
	db	377o
;intdv0 removed - 5.21 doesn't have this routine

	page
	subttl	floating point output routine
					;entry to linprt
inprt:	PUSH HL ;save line number
	LD HL,intxt ;print message
	CALL strout
	POP HL ;fall into linprt


					;print the 2 byte number in h,l
					;alters all registers
linprt:
	LD BC,stroui
	PUSH BC
linout:	CALL makint ;put the line number in the fac as an integer
	XOR A ;set format to free format
	CALL fouini ;set up the sign
	OR (HL) ;turn off the zero flag
	JP fout2 ;convert the number into digits

					;floating output of fac
					;alters all registers
					;the original contents of the fac is lost
;
;	output the value in the fac according to the format specifications
;	in a,b,c
;	all registers are altered
;	the original contents of the fac is lost
;
;	the format is specified in a, b and c as follows:
;	the bits of a mean the following:
;bit 7	0 means free format output, i.e. the other bits of a must be zero,
;	trailing zeros are suppressed, a number is printed in fixed or floating
;	point notation according to its magnitude, the number is left
;	justified in its field, b and c are ignored.
;	1 means fixed format output, i.e. the other bits of a are checked for
;	formatting information, the number is right justified in its field,
;	trailing zeros are not suppressed.  this is used for print using.
;bit 6	1 means group the digits in the integer part of the number into groups
;	of three and separate the groups by commas
;	0 means don'T PRINT THE NUMBER WITH COMMAS
;bit 5	1 means fill the leading spaces in the field with asterisks ("*")
;bit 4	1 means output the number with a floating dollar sign ("$")
;bit 3	1 means print the sign of a positive number as a plus sign ("+")
;	instead of a space
;bit 2	1 means print the sign of the number after the number
;bit 1	unused
;bit 0	1 means print the number in floating point notation i.e. "E NOTATION"
;	if this bit is on, the comma specification (bit 6) is ignored.
;	0 means print the number in fixed point notation.  numbers .ge. 1e16
;	cannot be printed in fixed point notation.
;
;	b and c tell how big the field is:
;b   =	the number of places in the field to the left of the decimal point
;	(b does not include the decimal point)
;c   =	the number of places in the field to the right of the decimal point
;	(c includes the decimal point)
;	b and c do not include the 4 positions for the exponent if bit 0 is on
;	fout assumes b+c .le. 24 (decimal)
;	if the number is too big to fit in the field, a percent sign ("%") is
;	printed and the field is extended to hold the number.
;&


					;entry to print the fac in free format
fout:	XOR A ;set format flags to free formated output
					;entry to print the fac using the format specifications in a, b and c
pufout:	CALL fouini ;save the format specification in a and put
					;a space for positive numbers in the buffer
	AND 10o ;check if positive numbers get a plus sign
	JP Z,fout1 ;they don'T
	LD (HL),'+' ;they do, put in a plus sign
fout1:	EX DE,HL ;save buffer pointer
	CALL vsign ;get the sign of the fac
	EX DE,HL ;put the buffer pointer back in (hl)
	JP P,fout2 ;if we have a negative number, negate it
	LD (HL),'-' ; and put a minus sign in the buffer
	PUSH BC ;save the field length specification
	PUSH HL ;save the buffer pointer
	CALL vneg ;negate the number
	POP HL ;get the buffer pointer back
	POP BC ;get the field length specifications back
	OR H ;turn off the zero flag, this depends on the
					; fact that fbuffr is never on page 0.
fout2:	INC HL ;point to where the next character goes
	LD (HL),'0' ;put a zero in the buffer in case the number
					; is zero (in free format) or to reserve space
					; for a floating dollar sign (fixed format)
	LD A,(temp3) ;get the format specification
	LD D,A ;save it for later
	RLA ;put the free format or not bit in the carry
	LD A,(valtyp) ;get the valtyp, vneg could have changed this
					; since -32768 is int and 32768 is sng.
	JP C,foutfx ;the man wants fixed formated output
					;here to print numbers in free format
	JP Z,foutzr ;if the number is zero, finish it up
	CP 4 ;decide what kind of a value we have
	JP NC,foufrv ;we have a sng or dbl
					;here to print an integer in free format
	LD BC,0 ;set the decimal point count and comma count
					; to zero
	CALL foutci ;convert the integer to decimal
					;fall into foutzs and zero suppress the thing


					;zero suppress the digits in fbuffr
					;asterisk fill and zero suppress if necessary
					;set up b and condition codes if we have a trailing sign
foutzs:	LD HL,fbufp1 ;get pointer to the sign
	LD B,(HL) ;save the sign in b
	LD C,' ' ;default fill character to a space
	LD A,(temp3) ;get format specs to see if we have to
	LD E,A ; asterisk fill.  save it
	AND 40o
	JP Z,fotzs1 ;we don'T
	LD A,B ;we do, see if the sign was a space
	CP C ;zero flag is set if it was
	LD C,'*' ;set fill character to an asterisk
	JP NZ,fotzs1 ;set the sign to an asterisk if it was a space
	LD A,E ;get format specs again
	AND 4 ;see if sign is trailing
	JP NZ,fotzs1 ;if so don'T ASTERISK FILL
	LD B,C ;b has the sign, c the fill character
fotzs1:	LD (HL),C ;fill in the zero or the sign
	CALL chrgtr ;get the next character in the buffer
					;since there are no spaces, "CHRGET" is
					; equivalent to "INX	H"/"MOV	A,M"
	JP Z,fotzs4 ;if we see a real zero, it is the end of
					; the number, and we must back up and put
					; in a zero.  chrget sets the zero flag on
					; real zeros or colons, but we won'T SEE
					; any colons in this buffer.
	CP 'E' ;back up and put in a zero if we see
	JP Z,fotzs4 ;an "E" or a "D" so we can print 0 in
	CP 'D' ;floating point notation with the c format zero
	JP Z,fotzs4
	CP '0' ;do we have a zero?
	JP Z,fotzs1 ;yes, suppress it
	CP 54o ;54=","  do we have a comma?
	JP Z,fotzs1 ;yes, suppress it
	CP '.' ;are we at the decimal point?
	JP NZ,fotzs2 ;no, i guess not
fotzs4:	DEC HL ;yes, back up and put a zero before it
	LD (HL),'0'
fotzs2:	LD A,E ;get the format specs to check for a floating
	AND 20o ; dollar sign
	JP Z,fotzs3 ;we don'T HAVE ONE
	DEC HL ;we have one, back up and put in the dollar
	LD (HL),curncy ; sign
fotzs3:	LD A,E ;do we have a trailing sign?
	AND 4
	RET NZ ;yes, return; note the non-zero flag is set
	DEC HL ;no, back up one and put the sign back in
	LD (HL),B ;put in the sign
	RET ;all done


					;here to initially set up the format specs and put in a space for the
					;sign of a positive number
fouini:	LD (temp3),A ;save the format specification
	LD HL,fbufp1 ;get a pointer into fbuffr
					;we start at fbufp1 in case the number will
					; overflow its field, then there is room in
					; fbuffr for the percent sign.
	LD (HL),' ' ;put in a space
	RET ;all done


					;here to print a sng or dbl in free format
foufrv:
					;the following code down to foufrf: is added to address the
					;ansi standard of printing numbers in fixed format rather than
					;scientific notation if they can be as accurately rpresented
					;in fixed format

	CALL pushf ;save in case needed for 2ed pass
	EX DE,HL ;save buffer pointer in (hl)
	LD HL,(dfaclo)
	PUSH HL ;save for d.p.
	LD HL,(dfaclo+2) ;
	PUSH HL ;
	EX DE,HL ;buffer pointer back to (hl)
	PUSH AF ;save in case needed for second pass
	XOR A ;(a)=0
	LD (fansii),A ;initialize fansii flag
	POP AF ;get psw right
	PUSH AF ;save psw
	CALL foufrf ;format number
	LD B,'E' ;will search for scientific notn.
	LD C,0 ;digit counter
fu1:;get original fbuffer pointer
	PUSH HL ;save in case we need to look for "D"
	LD A,(HL) ;fetch up first character
fu2:	CP B ;scientific notation?
	JP Z,fu4 ;if so, jump
	CP 72o ;if carry not set not a digit
	JP NC,fu2a
	CP 60o ;if carry set not a digit
	JP C,fu2a
	INC C ;incremented digits to print
fu2a:	INC HL ;point to next buffer character
	LD A,(HL) ;fetch next character
	OR A ;0(binary) at the end of characters
	JP NZ,fu2 ;continue search if not at end
	LD A,'D' ;now to check to see if searched for d
	CP B
	LD B,A ;in case not yet searched for
	POP HL ;now to check for "D"
	LD C,0 ;zero digit count
	JP NZ,fu1 ;go search for "D" if not done so
fu3:	POP AF ;pop	original psw
	POP BC
	POP DE
					;get dfaclo-dfaclo+3
	EX DE,HL ;(de)=buf ptr,(hl)=dfaclo
	LD (dfaclo),HL ;
	LD H,B
	LD L,C
	LD (dfaclo+2),HL
	EX DE,HL
	POP BC
	POP DE
					;get orig fac off stack
	RET ;complete
fu4:;print is in scientific notation , is this best?
	PUSH BC ;save type,digit count
	LD B,0 ;exponent value (in binary)
	INC HL ;point to next character of exp.
	LD A,(HL) ;fetch next character of exponent
fu5:	CP '+' ;is exponent positive?
	JP Z,fu8 ;if so no better printout
	CP '-' ;must be negative!
	JP Z,fu5a ;must process the digits
	SUB '0' ;subtract out ascii bias
	LD C,A ;digit to c
	LD A,B ;fetch old digit
	ADD A ;*2
	ADD A ;*4
	ADD B ;*5
	ADD A ;*10
	ADD C ;add in new digit
	LD B,A ;back out to exponent accumulator
	CP 20o ;16 d.p. digits for microsoft format
	JP NC,fu8 ;if so stop trying
fu5a:	INC HL ;point to next character 
	LD A,(HL) ;fetch up
	OR A ;binary zero at end
	JP NZ,fu5 ;continue if not at end
	LD H,B ;save exponent
	POP BC ;fetch type, digit count
	LD A,B ;determine type
	CP 'E' ;single precision?
	JP NZ,fu7 ;no -go process as double precision
	LD A,C ;digit count
	ADD H ;add exponent value
	CP 11o
	POP HL ;pop	old buffer pointer
	JP NC,fu3 ;can'T DO BETTER
fu6:	LD A,200o ;
	LD (fansii),A ;
	JP fu9 ;do fixed point printout
fu7:	LD A,H ;save exponent
	ADD C ;total digits necessary
	CP 22o ;must produce carry to use fixed point
	POP HL ;get stack right
	JP NC,fu3
	JP fu6 ;go  rint in fixed point
fu8:	POP BC ;
	POP HL ;get original buffer ptr back
	JP fu3 ;
fu9:	POP AF ;get original psw off stack
	POP BC
	POP DE
					;get dfaclo-dfaclo+3
	EX DE,HL ;(de)=buffer ptr,(hl)=dfaclo
	LD (dfaclo),HL ;
	LD H,B
	LD L,C
	LD (dfaclo+2),HL
	EX DE,HL
	POP BC
	POP DE
					;get original fac back
	CALL movfr ;move to fac
	INC HL ;because when we originally entered
					;foufrv the (hl) pointed to a char.
					;past the sign and the pass through
					;this code leaves (hl) pointing to
					;the sign. (hl) must point past sign!
foufrf:;
	CP 5 ;set cc'S FOR Z80
	PUSH HL ;save the buffer pointer
	SBC 0 ;map 4 to 6 and 10 to 20
	RLA ;this calculates how many digits we will
	LD D,A ; print
	INC D
	CALL foutnv ;normalize the fac so all significant digits
					; are in the integer part
	LD BC,3*400o+0 ;b = decimal point count
					;c = comma count
					;set comma count to zero and decimal point
					; count for e notation

	PUSH AF ;save for normal case
	LD A,(fansii) ;see if forced fixed output
	OR A ;set condition codes correctly
	JP P,fofv5a ;do normal thing
	POP AF ;
	ADD D
	JP foufv6 ;fixed output
fofv5a:	POP AF ;normal route
	ADD D ;see if number should be printed in e notation
	JP M,fofrs1 ;it should, it is .lt. .01
	INC D ;check if it is too big
	CP D
	JP NC,fofrs1 ;it is too big, it is .gt. 10^d-1
foufv6:	INC A ;it is ok for fixed point notation
	LD B,A ;set decimal point count
	LD A,2 ;set fixed point flag, the exponent is zero
					; if we are using fixed point notation
fofrs1:	SUB 2 ;e notation: add d-2 to original exponent
					;restore exp if not d.p.
	POP HL ;get the buffer pointer back
	PUSH AF ;save the exponent for later
	CALL foutan ;.01 .le. number .lt. .1?
	LD (HL),'0' ;yes, put ".0" in buffer
	CALL Z,inxhrt
	CALL foutcv ;convert the number to decimal digits
					;here to suppress the trailing zeros
fofrs2:	DEC HL ;move back to the last character
	LD A,(HL) ;get it and see if it was zero
	CP '0'
	JP Z,fofrs2 ;it was, continue suppressing
	CP '.' ;have we suppressed all the fractional digits?
	CALL NZ,inxhrt ;yes, ignore the decimal point also
	POP AF ;get the exponent back
	JP Z,foutdn ;we are done if we are in fixed point notation
					;fall in and put the exponent in the buffer


					;here to put the exponent and "E" or "D" in the buffer
					;the exponent is in a, the condition codes are assumed to be set
					;correctly.
fofldn:	PUSH AF ;save the exponent
	CALL getypr ;set carry for single precision
	LD A,42o ;[a]="D"/2
	ADC A ;multiply by 2 and add carry
	LD (HL),A ;save it in the buffer
	INC HL ;increment the buffer pointer
					;put in the sign of the exponent
	POP AF ;get the exponent back
	LD (HL),'+' ;a plus if positive
	JP P,fouce1
	LD (HL),'-' ;a minus if negative
	CPL ;negate exponent
	INC A
					;calculate the two digit exponent
fouce1:	LD B,'0'-1 ;initialize ten'S DIGIT COUNT
fouce2:	INC B ;increment digit
	SUB 12o ;subtract ten
	JP NC,fouce2 ;do it again if result was positive
	ADD '0'+12o ;add back in ten and convert to ascii
					;put the exponent in the buffer
	INC HL
	LD (HL),B ;put ten'S DIGIT OF EXPONENT IN BUFFER
	INC HL ;when we jump to here, a is zero
	LD (HL),A ;put one'S DIGIT IN BUFFER
foutzr:	INC HL ;increment pointer, here to finish up
					; printing a free format zero
foutdn:	LD (HL),0 ;put a zero at the end of the number
	EX DE,HL ;save the pointer to the end of the number
					; in (de) for ffxflv
	LD HL,fbufp1 ;get a pointer to the beginning
	RET ;all done




					;here to print a number in fixed format
foutfx:	INC HL ;move past the zero for the dollar sign
	PUSH BC ;save the field length specifications
	CP 4 ;check what kind of value we have
	LD A,D ;get the format specs
	JP NC,foufxv ;we have a sng or a dbl
					;here to print an integer in fixed format
	RRA ;check if we have to print it in floating
	JP C,ffxifl ; point notation
					;here to print an integer in fixed format-fixed point notation
	LD BC,6*400o+3+0 ;set decimal point count to 6 and
					; comma count to 3
	CALL fouicc ;check if we don'T HAVE TO USE THE COMMAS
	POP DE ;get the field lengths
	LD A,D ;see if we have to print extra spaces because
	SUB 5 ; the field is too big
	CALL P,fotzer ;we do, put in zeros, they will later be
					; converted to spaces or asterisks by foutzs
	CALL foutci ;convert the number to decimal digits
fouttd:	LD A,E ;do we need a decimal point?
	OR A
	CALL Z,dcxhrt ;we don'T, BACKSPACE OVER IT.
	DEC A ;get how many trailing zeros to print
	CALL P,fotzer ;print them
					;if we do have decimal places, fill them up
					; with zeros
					;fall in and finish up the number


					;here to finish up a fixed format number
foutts:	PUSH HL ;save buffer pointer
	CALL foutzs ;zero suppress the number
	POP HL ;get the buffer pointer back
	JP Z,ffxix1 ;check if we have a trailing sign
	LD (HL),B ;we do, put the sign in the buffer
	INC HL ;increment the buffer pointer
ffxix1:	LD (HL),0 ;put a zero at the end of the number


					;here to check if a fixed format-fixed point number overflowed its
					;field length
					;d = the b in the format specification
					;this assumes the location of the decimal point is in temp2
	LD HL,fbuffr ;get a pointer to the beginning
foube1:	INC HL ;increment pointer to the next character
foube5:	LD A,(temp2) ;get the location of the decimal point
					;since fbuffr is only 35 (decimal) long, we
					; only have to look at the low order to see
					; if the field is big enough
	SUB L ;figure out how much space we are taking
	SUB D ;is this the right amount of space to take?
	RET Z ;yes, we are done, return from fout
	LD A,(HL) ;no, we must have too much since we started
					; checking from the beginning of the buffer
					; and the field must be small enough to fit in
					; the buffer.  get the next character in
					; the buffer.
	CP ' ' ;if it is a space or an asterisk, we can
	JP Z,foube1 ; ignore it and make the field shorter with
	CP '*' ; no ill effects
	JP Z,foube1
	DEC HL ;move the pointer back one to read the
					; character with chrget
	PUSH HL ;save the pointer

					;here we see if we can ignore the leading zero before a decimal point.
					;this occurs if we see the following: (in order)
					;	+,-	a sign (either "-" or "+")	[optional]
					;	$	a dollar sign			[optional]
					;	0	a zero				[mandatory]
					;	.	a decimal point			[mandatory]
					;	0-9	another digit			[mandatory]
					;if you see a leading zero, it must be the one before a decimal point
					;or else foutzs would have suppressed it, so we can just "INX	H"
					;over the character following the zero, and not check for the
					;decimal point explicitly.
foube2:	PUSH AF ;put the last character on the stack.  the
					; zero flag is set.  the first time the zero
					; zero flag is not set.
	LD BC,foube2 ;get address we go to if we see a character
	PUSH BC ; we are looking for
	CALL chrgtr ;get the next character
	CP '-' ;save it and get the next character if it is
	RET Z ; a minus sign, a plus sign or a dollar sign
	CP '+'
	RET Z
	CP curncy
	RET Z
	POP BC ;it isn'T, GET THE ADDRESS OFF THE STACK
	CP '0' ;is it a zero?
	JP NZ,foube4 ;no, we can not get rid of another character
	INC HL ;skip over the decimal point
	CALL chrgtr ;get the next character
	JP NC,foube4 ;it is not a digit, we can'T SHORTEN THE FIELD
	DEC HL ;we can!!!  point to the decimal point
	db	001 ;"LXI	B" over the next 2 bytes
foube3:	DEC HL ;point back one character
	LD (HL),A ;put the character back

					;if we can get rid of the zero, we put the characters on the stack
					;back into the buffer one position in front of where they originally
					;were.  note that the maximum number of stack levels this uses is
					;three -- one for the last entry flag, one for a possible sign,
					;and one for a possible dollar sign.  we don'T HAVE TO WORRY ABOUT
					;the first character being in the buffer twice because the pointer
					;when fout exits will be pointing to the second occurance.
	POP AF ;get the character off the stack
	JP Z,foube3 ;put it back in the buffer if it is not the
					; last one
	POP BC ;get the buffer pointer off the stack
	JP foube5 ;see if the field is now small enough
					;here if the number is too big for the field
foube4:	POP AF ;get the characters off the stack
	JP Z,foube4 ;leave the number in the buffer alone
	POP HL ;get the pointer to the beginning of the
					; number minus 1
	LD (HL),'%' ;put in a percent sign to indicate the number
					; was too large for the field
	RET ;all done -- return from fout


					;here to print a sng or dbl in fixed format
foufxv:	PUSH HL ;save the buffer pointer
	RRA ;get fixed or floating notation flag in carry
	JP C,ffxflv ;print the number in e-notation
	JP Z,ffxsfx ;we have a sng
					;here to print a dbl in fixed format--fixed point notation
	LD DE,ffxdxm ;get pointer to 1d16
	CALL dcompd ;we can'T PRINT A NUMBER .GE. 10^16 IN FIXED
					; point notation
	LD D,20o ;set d = number of digits to print for a dbl
	JP M,ffxsdc ;if the fac was small enough, go print it
					;here to print in free format with a percent sign a number .ge. 10^16
ffxsdo:	POP HL ;get the buffer pointer off the stack
	POP BC ;get the field specification off the stack
	CALL fout ;print the number in free format
	DEC HL ;point to in front of the number
	LD (HL),'%' ;put in the percent sign
	RET ;all done--return from fout

					;here to print a sng in fixed format--fixed point notation
ffxsfx:	LD BC,266q*256+016q
	LD DE,033q*256+312q ;get 1e16, check if the number is too big
	CALL fcomp
	JP P,ffxsdo ;it is, print it in free format with a % sign
	LD D,6 ;d = number of digits to print in a sng

					;here to actually print a sng or dbl in fixed format
ffxsdc:	CALL sign ;see if we have zero
	CALL NZ,foutnv ;if not, normalize the number so all digits to
					; be printed are in the integer part
	POP HL ;get the buffer pointer
	POP BC ;get the field length specs
	JP M,ffxxvs ;do different stuff if exponent is negative
					;here to print a number with no fractional digits
ffxsd2:	PUSH BC ;save the field length specs again
	LD E,A ;save the exponent in e
	LD A,B ;we have to print leading zeros if the field
	SUB D ; has more characters than there are digits
	SUB E ; in the number.
					;if we are using commas, a may be too big.
					;this doesn'T MATTER BECAUSE FOUTTS WILL FIND
					; the correct beginning.  there is room in
					; fbuffr because the maximum value b can be is
					; 24 (decimal) so d+c .le. 16 (decimal)  since
					; fac .lt. 10^16.
					;so we need 8 more bytes for zeros.  4 come
					; since we will not need to print an exponent.
					; fbuffr also contains an extra 4 bytes for
					; this case.
					;(it would take more than 4 bytes to check for
					; this.)
	CALL P,fotzer ;foutzs will later suppress them
	CALL foutcd ;setup decimal point and comma count
	CALL foutcv ;convert the number to decimal digits
	OR E ;put in digits after the number if it
					; is big enough, here a=0
	CALL NZ,fotzec ;there can be commas in these zeros
	OR E ;make sure we get a decimal point for foutts
	CALL NZ,fouted
	POP DE ;get the field length specs
	JP fouttd ;go check the size, zero suppress, etc. and
					; finish the number

					;here to print a sng or dbl that has fractional digits
ffxxvs:	LD E,A ;save the exponent
	LD A,C ;divide by ten the right number of times so
	OR A ; the result will be rounded correctly and
	CALL NZ,dcrart ; have the correct number of significant
	ADD E ; digits
ffxxs2:	JP M,ffxxv8 ;for later calculations, we want a zero if the
	XOR A ; result was not negative
ffxxv8:	PUSH BC ;save the field specs
	PUSH AF ;save this number for later
ffxxv2:	CALL M,findiv ;this is the divide loop
	JP M,ffxxv2
	POP BC ;get the number we saved back in b
	LD A,E ;we have two cases depending on whether the
	SUB B ; the number has integer digits or not
	POP BC ;get the filed specs back
	LD E,A ;save how many decimal places before the
	ADD D ; the number ends
ffxxs4:	LD A,B ;get the "B" field spec
	JP M,ffxxv3
					;here to print numbers with integer digits
	SUB D ;print some leading zeros if the field is
	SUB E ; bigger than the number of digits we will
ffxxs6:	CALL P,fotzer ; print
	PUSH BC ;save field spec
	CALL foutcd ;set up decimal point and comma count
	JP ffxxv6 ;convert the digits and do the trimming up

					;here to print a number without integer digits
ffxxv3:	CALL fotzer ;put all zeros before the decimal point
	LD A,C ;save c
	CALL foutdp ;put in a decimal point
	LD C,A ;restore c
	XOR A ;decide how many zeros to print between the
	SUB D ; decimal point and the first digit we will
	SUB E ; print.
	CALL fotzer ;print the zeros
	PUSH BC ;save exponent and the "C" in the field spec
	LD B,A ;zero the decimal place count
	LD C,A ;zero the comma count
ffxxv6:	CALL foutcv ;convert the number to decimal digits
	POP BC ;get the field specs back
	OR C ;check if we have to print any zeros after
					; the last digit
	JP NZ,ffxxv7 ;check if there were any decimal places at all
					;e can never be 200, (it is negative) so if
					; a=0 here, there is no way we will call fotzer 
	LD HL,(temp2) ;the end of the number is where the dp is
ffxxv7:	ADD E ;print some more trailing zeros
	DEC A
	CALL P,fotzer
	LD D,B ;get the "B" field spec in d for foutts
	JP foutts ;finish up the number


					;here to print an integer in fixed format--floating point notation
ffxifl:	PUSH HL ;save the buffer pointer
	PUSH DE ;save the format specs
	CALL consi ;convert the integer to a sng
	POP DE ;get the format specs back
	XOR A ;set flags to print the number as a sng
					;fall into ffxflv


					;here to print a sng or dbl in fixed format-flotating point notation
ffxflv:	JP Z,ffxsfl ;if we have a sng, set the right flags
	LD E,20o ;we have a dbl, get how many digits we have
	db	001 ;"LXI	B" over the next two bytes
ffxsfl:	LD E,6 ;we have a sng, get how many digits we print
	CALL sign ;see if we have zero
ffxs03:	SCF ;set carry to determine if we are printing
					;zero. note: this depends on the fact that
					;foutnv exits with carry off
	CALL NZ,foutnv ;if not, normalize the number so all digits to
					; be printed are in the integer part
	POP HL ;get the buffer pointer back
	POP BC ;get the field length specs
	PUSH AF ;save the exponent
	LD A,C ;calculate how many significant digits we must
	OR A ; print
	PUSH AF ;save the "C" field spec for later
	CALL NZ,dcrart
	ADD B
	LD C,A
	LD A,D ;get the "A" field spec
	AND 4 ;see if the sign is a trailing sign
	CP 1 ;set carry if a is zero
	SBC A ;set d=0 if we have a trailing sign,
	LD D,A ; d=377 if we do not
	ADD C
	LD C,A ;set c=number of significant digits to print
	SUB E ;if we have less than e, then we must get rid
	PUSH AF ;save comparison # of sig digits and the
					;# of digits we will print
	PUSH BC ;save the "B" field spec and # of sig digits
ffxlv1:	CALL M,findiv ; of some by dividing by ten and rounding
	JP M,ffxlv1
	POP BC ;get "B" field spec and # of sig digits back
	POP AF ;get # of trailing zeros to print
	PUSH BC ;save the "B" field spec and # of sig digits
	PUSH AF ;save # of trailing zeros to print
	JP M,ffxlv3 ;take into account digits that were
	XOR A ;divided off at ffxlv1
ffxlv3:	CPL
	INC A
	ADD B ;set the decimal place count
	INC A
	ADD D ;take into account if the sign is trailing
	LD B,A ; or not
	LD C,0 ;set comma count to zero, the comma spec is
					; ignored.
	CALL foutcv ;convert the number to decimal digits
	POP AF ;get number trailing zeros to print
					;if the field length is longer than the # of digits
					;we can print
	CALL P,fotznc ;the decimal point could come out in here
	CALL fouted ;in case d.p. is last on list
	POP BC ;get # of sig digits and "B" field spac back
	POP AF ;get the "C" field spec back
	JP NZ,ffxlv4 ;if non-zero proceed
	CALL dcxhrt ;see if d.p. there
	LD A,(HL) ;fetch to make sure d.p.
	CP '.' ;if not must be zero
	CALL NZ,inxhrt ;if not must leave as is
	LD (temp2),HL ;need d.p. location in temp2
ffxlv4:; so ignore it.
	POP AF ;get the exponent back
	JP C,ffxlv2 ;exponent=0 if the number is zero
	ADD E ;scale it correctly
	SUB B
	SUB D
ffxlv2:	PUSH BC ;save the "B" field spec
	CALL fofldn ;put the exponent in the buffer
	EX DE,HL ;get the pointer to the end in (hl)
					; in case we have a trailing sign
	POP DE ;get the "B" field spec in d, put on a
	JP foutts ; possible trailing sign and we are done


					;normalize the number in the fac so all the digits are in the integer
					;part.  return the base 10 exponent in a
					;d,e are left unaltered
foutnv:	PUSH DE ;save (de)
	XOR A ;zero the exponent
	PUSH AF ;save it
	CALL getypr ;get type of number to be printed
	JP PO,foundb ;not double, do normal thing
forbig:	LD A,(fac) ;get exponent
	CP 221o ;is it .lt.1d5?
	JP NC,foundb ;no, dont multply
	LD DE,tenten ;multiply by 1d10
	LD HL,arglo ;move into arg
	CALL vmove ;put in arg
	CALL dmult ;multiply by it
	POP AF ;get orig exponent off stack
	SUB 10 ;get proper offset for exponent
	PUSH AF ;save exponent back
	JP forbig ;force it bigger if possible
foundb:	CALL founvc ;is the fac too big or too small?
founv1:	CALL getypr ;see what kind of value we have so we
					; can see if the fac is big enough
	JP PE,founv4 ;we have a dbl
	LD BC,221q*256+103q
	LD DE,117q*256+371q ;get 99999.95 to see if the fac is big
	CALL fcomp ; enough yet
	JP founv5 ;go do the check
founv4:	LD DE,foutdl ;get pointer to 999,999,999,999,999.5
	CALL dcompd ;see if the number is still too small
founv5:	JP P,founv3 ;it isn'T ANY MORE, WE ARE DONE
	POP AF ;it is, multiply by ten
	CALL finmlt
	PUSH AF ;save the exponent again
	JP founv1 ;now see if it is big enough
founv2:	POP AF ;the fac is too big, get the exponent
	CALL findiv ;divide it by ten
	PUSH AF ;save the exponent again
	CALL founvc ;see if the fac is small enough
founv3:	POP AF ;we are done, get the exponent back
	OR A ;clear carry
	POP DE ;get (de) back
	RET ;all done

					;here to see if the fac is small enough yet
founvc:	CALL getypr ;see what type number we have
	JP PE,fonvc1 ;we have a dbl
	LD BC,224q*256+164q
	LD DE,043q*256+370q ;get 999999.5 to see if the fac is too big
	CALL fcomp
	JP fonvc2 ;go do the check
fonvc1:	LD DE,foutdu ;get pointer to 9,999,999,999,999,999.5
	CALL dcompd ;see if the number is too big
fonvc2:	POP HL ;get the return address off the stack
	JP P,founv2 ;the number is too big, divide it by ten
	JP (HL) ;it isn'T TOO BIG, JUST RETURN


					;here to put some zeros in the buffer
					;the count is in a, it can be zero, but the zero flag must be set
					;only (hl) and a are altered
					;we exit with a=0
fotzer:	OR A ;this is because ffxxv3 call us with the
					; condition codes not set up
fotzr1:	RET Z ;return if we are done
	DEC A ;we are not done, so decrement the count
	LD (HL),'0' ;put a zero in the buffer
	INC HL ;update the buffer pointer
	JP fotzr1 ;go see if we are now done


					;here to put zeros in the buffer with commas or a decimal point in the
					;middle.  the count is in a, it can be zero, but the zero flag must be
					;set.  b the decimal point count and c the comma count are updated
					;a,b,c,h,l are altered
fotznc:	JP NZ,fotzec ;entry after a "CALL FOUTCV"
fotzrc:	RET Z ;return if we are done
	CALL fouted ;see if we have to put a comma or a decimal
					; point before this zero
fotzec:	LD (HL),'0' ;put a zero in the buffer
	INC HL ;update the buffer pointer
	DEC A ;decrement the zero count
	JP fotzrc ;go back and see if we are done


					;here to put a possible comma count in c, and zero c if we are not
					;using the comma specification
foutcd:	LD A,E ;setup decimal point count
	ADD D
	INC A
	LD B,A
	INC A ;setup comma count
fotcd1:	SUB 3 ;reduce [a] mod 3
	JP NC,fotcd1
	ADD 5 ;add 3 back in and add 2 more for
					;scaling
foutcc:	LD C,A ;save a possible comma count
fouicc:	LD A,(temp3) ;get the format specs
	AND 100o ;look at the comma bit
	RET NZ ;we are using commas, just return
	LD C,A ;we aren'T, ZERO THE COMMA COUNT
	RET ;all done


					;here to put decimal points and commas in their correct places
					;this subroutine should be called before the next digit is put in the
					;buffer.  b=the decimal point count, c=the comma count
					;the counts tell how many more digits have to go in before the comma
					;or decimal point go in.  the comma or decimal point then goes before 
					;the last digit in the count.  for example, if the decimal point should
					;come after the first digit, the decimal point count should be 2.
foutan:;save for later
	DEC B ;
	JP P,foute1 ;process as normal
	LD (temp2),HL ;save location of decimal point
	LD (HL),'.' ;put in d.p.
foutd1:	INC HL ;point to next buffer postion
	LD (HL),'0'
	INC B ;
	JP NZ,foutd1
	INC HL ;point to next available buffer location
	LD C,B
	RET
fouted:	DEC B ;time for d.p.?
foute1:;
	JP NZ,foued1 ;no, check for the comma
					;entry to put a decimal point in the buffer
foutdp:	LD (HL),'.' ;yes, put the decimal point in
	LD (temp2),HL ;save the location of the decimal point
	INC HL ;increment the buffer pointer
	LD C,B ;put zero in c so we won"T PRINT ANY COMMAS
	RET ; after the decimal point.  all done
					;here to see if it is time to print a comma
foued1:	DEC C ;is it time?
	RET NZ ;nope, we can return
	LD (HL),54o ;","=54, yes, put a comma in the buffer
	INC HL ;increment the buffer pointer
	LD C,3 ;reset the comma count so we will print a
	RET ; comma after three more digits.  all done


					;here to convert a sng or dbl number that has been normalized to
					;decimal digits.  the decimal point count and comma count are in b and
					;c respectively.  (hl) points to where the first digit will go.
					;this exits with a=0.  (de) is left unaltered.
foutcv:	PUSH DE ;save (de)
	CALL getypr ;see what kind of a number we have
	JP PO,foutcs ;we have a sng
					;here to convert a double precision number to decimal digits
	PUSH BC ;save the decimal point and comma counts
	PUSH HL ;save the buffer pointer
	CALL vmovaf ;move the fac into arg
	LD HL,dhalf ;get pointer to .5d0
	CALL vmovfm ;move the constant into the fac
	CALL dadd ;add .5 to the original number to round it
	XOR A ;clear the carry
	CALL dintfo ;take the integer part of the number
					;the number is not normalized afterwards
	POP HL ;get the buffer pointer back
	POP BC ;get the comma and decimal point counts back
	LD DE,fodtbl ;get a pointer to the dbl power of ten table
	LD A,12o ;convert ten digits, the others will be
					; converted as sng'S AND INT's
					;because we bracketed the number a
					;power of ten less in magnitude and
					;single precision conversion can handle
					;a magnitude of ten larger
					;here to convert the next digit
foucd1:	CALL fouted ;see if we have to put in a dp or comma
	PUSH BC ;save dp and comma information
	PUSH AF ;save digit count
	PUSH HL ;save buffer pointer
	PUSH DE ;save power of ten pointer
					;here to divide for the next digit
	LD B,'0'-1 ;set up the count for the digit
foucd2:	INC B ;increment the digit count
	POP HL ;get the pointer to the power of ten
	PUSH HL ;save it again
	db	076o ;"MVI	A", get the instruction to subtract
	SBC (HL) ; the power of ten
	CALL daddfo ;go subtract them
	JP NC,foucd2 ;if the number was not less than the power of
					; ten, subtract again
	POP HL ;we are done subtracting, but we did it once
					; too often, so add back in the power of ten
					;get the pointer to the power of ten
	db	076o ;"MVI	A", get the instruction to add the
	ADC (HL) ; power of ten and the number
	CALL daddfo ;add the two numbers
	EX DE,HL ;put the power of ten pointer in (de).  it is
					; updated for the next power of ten
	POP HL ;get the buffer pointer back
	LD (HL),B ;put the digit into the buffer
	INC HL ;increment the buffer pointer
	POP AF ;get the digit count back
	POP BC ;get the decimal point and comma counts
	DEC A ;have we printed the last digit?
	JP NZ,foucd1 ;no, go do the next one
	PUSH BC ;yes, convert remaining digits using single
	PUSH HL ; precision, this is faster, move the number
	LD HL,dfaclo ; that is left into the sng fac
	CALL movfm
	JP foucdc ;go to it!!

					;here to convert a single precision number to decimal digits
foutcs:	PUSH BC ;save the decimal point and comma counts
	PUSH HL ;save the buffer pointer
	CALL faddh ;round number to nearest integer
	LD A,1 ;make a non-zero, since number is positive
					; and non-zero, round will exit with the ho
					; in a, so the msb will always be zero and
					; adding one will never cause a to be zero
	CALL qint ;get integer part in c,d,e
	CALL movfr ;save number in fac
foucdc:	POP HL ;get the buffer pointer back
	POP BC ;get the decimal point and comma counts back
	XOR A ;clear carry, the carry is our flag to
					; calculate two digits
	LD DE,fostbl ;get pointer to power of ten table
					;here to calculate the next digit of the number
foucs1:	CCF ;complement flag that tells when we are done
	CALL fouted ;see if a comma or dp goes before this digit
	PUSH BC ;save comma and decimal point information
	PUSH AF ;save carry i.e. digit count
	PUSH HL ;save character pointer
	PUSH DE ;save power of ten pointer
	CALL movrf ;get number in c,d,e
	POP HL ;get power of ten pointer
	LD B,'0'-1 ;b = next digit to be printed
foucs2:	INC B ;add one to digit
	LD A,E ;subtract lo
	SUB (HL)
	LD E,A
	INC HL ;point to next byte of power of ten
	LD A,D ;subtract mo
	SBC (HL)
	LD D,A
	INC HL
	LD A,C ;subtract ho
	SBC (HL)
	LD C,A
	DEC HL ;point to beginning of power of ten
	DEC HL
	JP NC,foucs2 ;subtract again if result was positive
	CALL fadda ;it wasn'T, ADD POWER OF TEN BACK IN
	INC HL ;increment pointer to next power of ten
	CALL movfr ;save c,d,e in fac
	EX DE,HL ;get power of ten pointer in (de)
	POP HL ;get buffer pointer
	LD (HL),B ;put character in buffer
	INC HL ;increment buffer pointer
	POP AF ;get digit count (the carry) back
	POP BC ;get comma and dp information back
	JP C,foucs1 ;calculate next digit if we have not done 2
	INC DE ;we have, increment pointer to correct place
	INC DE ; in the integer power of ten table
	LD A,4 ;get the digit count
	JP fouci1 ;compute the rest of the digits like integers
					;note that the carry is off

					;here to convert an integer into decimal digits
					;this exits with a=0.  (de) is left unaltered.
foutci:	PUSH DE ;save (de)
	LD DE,foitbl ;get pointer to the integer power of ten table
	LD A,5 ;set up a digit count, we have to calculate 5
					; digits because the max pos integer is 32768
					;here to calculate each digit
fouci1:	CALL fouted ;see if a comma or dp goes before the digit
	PUSH BC ;save comma and decimal point information
	PUSH AF ;save digit count
	PUSH HL ;save buffer pointer
	EX DE,HL ;get the power of ten pointer in (hl)
	LD C,(HL) ;put the power of ten on the stack
	INC HL
	LD B,(HL)
	PUSH BC
	INC HL ;increment the pwr of ten ptr to next power
	EX (SP),HL ;get the power of ten in (hl) and put the
					; pointer on the stack
	EX DE,HL ;put the power of ten in (de)
	LD HL,(faclo) ;get the integer in (hl)
	LD B,'0'-1 ;set up the digit count, b=digit to be printed
fouci2:	INC B ;increment the digit count
	LD A,L ;subtract (de) from (hl)
	SUB E ;subtract the low orders
	LD L,A ;save the new result
	LD A,H ;subtract the high orders
	SBC D
	LD H,A ;save the new high order
	JP NC,fouci2 ;if (hl) was .ge. (de) then subtract again
	ADD HL,DE ;we are done, but we subtracted (de) once too
					; often, so add it back in
	LD (faclo),HL ;save in the fac what is left
	POP DE ;get the power of ten pointer back
	POP HL ;get the buffer pointer back
	LD (HL),B ;put the new digit in the buffer
	INC HL ;increment the buffer pointer to next digit
	POP AF ;get the digit count back
	POP BC ;get the comma and dp information back
	DEC A ;was that the last digit?
	JP NZ,fouci1 ;no, go do the next one
	CALL fouted ;yes, see if a dp goes after the last digit
	LD (HL),A ;put a zero at the end of the number, but
					; don'T INCREMENT (HL) SINCE AN EXPONENT OR A
					; trailing sign may be comming
	POP DE ;get (de) back
	RET ;all done, return with a=0


					;constants used by fout
tenten:	db	0 ;10000000000
	db	0
	db	0
	db	0
	db	371o
	db	2
	db	25o
	db	242o
foutdl:	db	341o ; 999,999,999,999,999.5
	db	377o
	db	237o
	db	061o
	db	251o
	db	137o
	db	143o
	db	262o
foutdu:	db	376o ; 9,999,999,999,999,999.5
	db	377o
	db	003
	db	277o
	db	311o
	db	033o
	db	016o
	db	266o
dhalf:	db	000 ; .5d0
	db	000
	db	000
	db	000
fhalf:	db	000 ; .5e0
	db	000
	db	000
	db	200o
ffxdxm:	db	000 ; 1d16
	db	000
	db	004
	db	277o
	db	311o
	db	033o
	db	016o
	db	266o
					;double precision power of ten table
fodtbl:	db	000 ; 1d15
	db	200o
	db	306o
	db	244o
	db	176o
	db	215o
	db	003
	db	000 ; 1d14
	db	100o
	db	172o
	db	020o
	db	363o
	db	132o
	db	000
	db	000 ; 1d13
	db	240o
	db	162o
	db	116o
	db	030o
	db	011o
	db	000
	db	000 ; 1d12
	db	020o
	db	245o
	db	324o
	db	350o
	db	000
	db	000
	db	000 ; 1d11
	db	350o
	db	166o
	db	110o
	db	027o
	db	000
	db	000
	db	000 ; 1d10
	db	344o
	db	013o
	db	124o
	db	002
	db	000
	db	000
	db	000 ; 1d9
	db	312o
	db	232o
	db	073o
	db	000
	db	000
	db	000
	db	000 ; 1d8
	db	341o
	db	365o
	db	005
	db	000
	db	000
	db	000
	db	200o ; 1d7
	db	226o
	db	230o
	db	000
	db	000
	db	000
	db	000
	db	100o ; 1d6
	db	102o
	db	017o
	db	000
	db	000
	db	000
	db	000
					;single precision power of ten table
fostbl:	db	240o ; 1e5
	db	206o
	db	001
	db	020o ; 1e4
	db	047o
	db	000
					;integer power of ten table
foitbl:	db	020o ; 10000
	db	047o
	db	350o ; 1000
	db	003
	db	144o ; 100
	db	000
	db	012o ; 10
	db	000
	db	001 ; 1
	db	000
;
; output routines for octal and hex numbers
;
fouto:	XOR A ;make a=0, set zero
	LD B,A ;save in [b]
	db	302o ;"JNZ" around next two bytes
fouth:	LD B,1 ;set hex flag
	PUSH BC ;save hex/octal flag
	CALL frqint ;get double byte int in [h,l]
	POP BC ;get back hex/octal flag
	LD DE,fbuffr ;pointer to output buffer in [d,e]
	PUSH DE ;save so we can return it later
	XOR A ;get set to have first digit for octal
	LD (DE),A ;clear digit seen flag
	DEC B ;see if octal
	INC B ;if so, zero set
	LD C,6 ;six digits for octal
	JP Z,octone ;do first octal digit
	LD C,4 ;four digit for hex

outhlp:	ADD HL,HL ;shift left one bit
	ADC A ;add in the shifted bit
outolp:	ADD HL,HL ;shift left one bit
	ADC A
	ADD HL,HL
	ADC A
octone:	ADD HL,HL ;enter here for first octal digit
	ADC A
	OR A ;see if we got a zero digit
	JP NZ,makdig ;no, make a digit
	LD A,C ;get digit counter
	DEC A ;was it going to go to zero (last dig?)
	JP Z,makdig ;if so, force one zero digit
	LD A,(DE) ;have we printed a non-zero digit?
	OR A ;set cc'S
	JP Z,nolead ;no, dont print this leading zero
	XOR A ;get zero
makdig:	ADD '0' ;make numeric digit
	CP '9'+1 ;is it a big hex digit? (a-f)
	JP C,nothal ;no, dont add offset
	ADD 'A'-'9'-1 ;add offset
nothal:	LD (DE),A ;save digit in fbuffr
	INC DE ;bump pointer
	LD (DE),A ;save here to flag printed sig. dig.
nolead:	XOR A ;make a zero
	DEC C ;all done printing?
	JP Z,finoho ;yes, return
	DEC B ;see if hex or octal
	INC B ;test
	JP Z,outolp ;was octal
	JP outhlp ;was hex

finoho:	LD (DE),A ;store final zero
	POP HL ;get pointer to fbuffr
	RET ;all done.
	page
	subttl	exponentiation and the square root function
					;all done

					;subroutine for fpwr, atn
pshneg:	LD HL,neg ;get the address of neg
	EX (SP),HL ;switch ret addr and addr of neg
	JP (HL) ;return, the address of neg is on the stack

					;square root function
					;we use sqr(x)=x^.5
sqr:	CALL pushf ;save arg x
	LD HL,fhalf ;get 1/2
	CALL movfm ;sqr(x)=x^.5

	JP fpwrt ;skip over the next 3 bytes
					;entry from the operator dispatch routines
fpwrq:	CALL frcsng ;make sure the fac is a sng
fpwrt:	POP BC
	POP DE
					;get arg in registers, entry to fpwr if
					; argument is on stack.  fall into fpwr


					;exponentiation    ---    x^y
					;n.b.  0^0=1
					;first we check if y=0, if so, the result is 1.
					;next, we check if x=0, if so, the result is 0.
					;then we check if x is positive, if not, we check that y is a
					;negative integer, and whether it is even or odd.  if y is a negative
					;integer, we negate x.  if not, log will give an fc error when we call
					;it.  if x is negative and y is odd, we push the address of neg on the
					;stack so we will return to it and get a negative result.  to compute
					;the result we use x^y=exp(y*log(x))
fpwr:
	LD HL,clrovc ;return to routine to set normal
	PUSH HL ;overflow mode
	LD A,1
	LD (flgovc),A ;set up once only overflow mode
	CALL sign ;see if y is zero
	LD A,B ;see if x is zero
	JP Z,exp ;it is, result is one
	JP P,posexp ;positive exponent
	OR A ;is it zero to minus power?
	JP Z,intdv2 ;give div by zero and continue
posexp:	OR A
	JP Z,zero0 ;it is, result is zero
	PUSH DE
	PUSH BC
					;save x on stack
	LD A,C ;check the sign of x
	OR 177o ;turn the zero flag off
	CALL movrf ;get y in the registers
					;end intfsw contittonal
	JP P,fpwr1 ;no problems if x is positive
;5.21: skip integer check if exponent too large
	PUSH AF ;save flags
	LD A,(fac) ;get exponent
	CP 99h ;is it >= 99h?
	JP C,fpwr0 ;if < 99h, do integer check
	POP AF ;else restore flags
	JP fpwr1 ;and skip to fpwr1
fpwr0:	POP AF ;restore flags
	PUSH DE
	PUSH BC
					;save y
	CALL int ;see if y is an integer
	POP BC
	POP DE
					;get y back
	PUSH AF ;save lo of int for even and odd information
	CALL fcomp ;see if we have an integer
	POP HL ;get even-odd information
	LD A,H ;put even-odd flag in carry
	RRA
fpwr1:	POP HL ;get x back in fac
	LD (facs),HL ;store ho'S
	POP HL ;get lo'S OFF STACK
	LD (faclo),HL ;store them in fac
	CALL C,pshneg ;negate number at end if y was odd
	CALL Z,neg ;negate the negative number
	PUSH DE
	PUSH BC
					;save y again
	CALL log ;compute  exp(y*log(x))
	POP BC
	POP DE
					;if x was negative and y not an integer then
	CALL fmult ; log will blow him out of the water
;	jmp	exp
	page
	subttl	exponential functon
					;the function exp(x) calculates e^x where e=2.718282
					;	the technique used is to employ a couple
					;	of fundamental identities that allows us to
					;	use the base 2 through the difficult portions of
					;	the calculation:
					;
					;		(1)e^x=2^y  where y=x*log2(e) [log2(e) is
					;						log base 2
					;						of e ]
					;
					;		(2) 2^y=2^[ int(y)+(y-int(y)]
					;		(3) if ny=int(y) then
					;		    2^(ny+y-ny)=[2^ny]*[2^(y-ny)]
					;
					;	now, since 2^ny is easy to compute (an exponent
					;	calculation with mantissa bits of zero) the difficult
					;	portion is to compute 2^(y-ny) where 0.le.(y-ny).lt.1
					;	this is accomplished with a polynomial approximation
					;	to 2^z where 0.le.z.lt.1  . once this is computed we
					;	have to effect the multiply by 2^ny .
exp:	LD BC,201q*256+070q
	LD DE,252q*256+073q ;get log2(e)
	CALL fmult ;y=fac*log2(e)
	LD A,(fac) ;must see if too large
	CP 210o ;abs .gt. 128?
	JP NC,exp100 ;if so overflow
	CP 150o ;if too small answer is 1
	JP C,exp200
	CALL pushf ;save y
	CALL int ;determine integer power of 2
	ADD 201o ;integer was returned in a
					;bias is 201 because binary
					;point is to left of understood 1
	POP BC
	POP DE ;recall y
	JP Z,exp110 ;overflow
	PUSH AF ;save exponent
	CALL fsub ;fac=y-int(y)
	LD HL,expbcn ;will use hart 1302 poly. eval now
	CALL poly ;compute 2^[y-int(y)]
	POP BC ;integer power of 2 exponent
	LD DE,0+0
	LD C,D ;now have floating representation 
					;of int(y) in (bcde)
	JP fmult ;multiply by 2^[y-int(y)] and return
exp100:	CALL pushf ;
exp110:
	LD A,(facs) ;if neg. then jump to zero
	OR A
	JP P,exp115 ;overflow if plus
	POP AF ;need stack right
	POP AF
	JP zero ;go zero the fac
exp115:	JP ovfin6 ;overflow
exp200:	LD BC,201q*256+000q
	LD DE,000q*256+000q ;1.
	JP movfr ;5.21: tail call optimization
;*************************************************************
;	hart 1302 polynomial coefficients
;*************************************************************
expbcn:	db	7 ;degree + 1
	db	174o ;.00020745577403-
	db	210o
	db	131o
	db	164o
	db	340o ;.00127100574569-
	db	227o
	db	046o
	db	167o
	db	304o ;.00965065093202+
	db	035o
	db	036o
	db	172o
	db	136o ;.05549656508324+
	db	120o
	db	143o
	db	174o
	db	032o ;.24022713817633-
	db	376o
	db	165o
	db	176o
	db	030o ;.69314717213716+
	db	162o
	db	061o
	db	200o
	db	000 ;1.0
	db	0000
	db	0000
	db	201o
					;end intfsw conditional

	page
	subttl	polynomial evaluator and the random number generator
					;evaluate p(x^2)*x
					;pointer to degree+1 is in (hl)
					;the constants follow the degree
					;constants should be stored in reverse order, fac has x
					;we compute:
					; c0*x+c1*x^3+c2*x^5+c3*x^7+...+c(n)*x^(2*n+1)
polyx:	CALL pushf ;save x
	LD DE,fmultt ;put address of fmultt on stack so when we
	PUSH DE ; return we will multiply by x
polyx2:	PUSH HL ;save constant pointer
	CALL movrf ;square x
	CALL fmult
	POP HL ;get constant pointer
					;fall into poly


					;polynomial evaluator
					;pointer to degree+1 is in (hl), it is updated
					;the constants follow the degree
					;constants should be stored in reverse order, fac has x
					;we compute:
					; c0+c1*x+c2*x^2+c3*x^3+...+c(n-1)*x^(n-1)+c(n)*x^n
poly:	CALL pushf ;save x
	LD A,(HL) ;get degree
	INC HL ;increment pointer to first constant
	CALL movfm ;move first constant to fac
	db	006 ;"MVI	B" over next byte
poly1:	POP AF ;get degree
	POP BC
	POP DE
					;get x
	DEC A ;are we done?
	RET Z ;yes, return
	PUSH DE
	PUSH BC
					;no, save x
	PUSH AF ;save degree
	PUSH HL ;save constant pointer
	CALL fmult ;evaluate the poly, multiply by x
	POP HL ;get location of constants
	CALL movrm ;get constant
	PUSH HL ;store location of constants so fadd and fmult
	CALL fadd ; will not screw them up, add in constant
	POP HL ;move constant pointer to next constant
	JP poly1 ;see if done


					;psuedo-random number generator
					;if arg=0, the last random number generated is returned
					;if arg .lt. 0, a new sequence of random numbers is started
					; using the argument
					;to form the next random number in the sequence, we multiply the
					;previous random number by a random constant, and add in another
					;random constant.  then the ho and lo bytes are switched, the
					;exponent is put where it will be shifted in by normal, and the
					;exponent in the fac set to 200 so the result will be less than 1.
					;this is then normalized and saved for the next time.
					;the ho and lo bytes were switched so we have a random chance of
					;getting a number less than or greater than .5
rndcop:	db	122o ;a copy of rndx to copy at run time
	db	307o
	db	117o
	db	200o
rndmon:	CALL chrgtr
rndmn2:	PUSH HL ;save text pointer for monadic rnd
	LD HL,fone ;pretend arg is 1.0
	CALL movfm
	CALL rnd ;pick up a random value
	POP HL ;get back the text pointer
	JP valsng
rnd:	CALL sign ;get sign of arg
	LD HL,rndcnt+1
	JP M,rndstr ;start new sequence if negative
	LD HL,rndx ;get last number generated
	CALL movfm
	LD HL,rndcnt+1
	RET Z ;return last number generated if zero
	ADD (HL) ;get counter into constants
					;and add one
	AND 7
	LD B,0
	LD (HL),A
	INC HL
	ADD A
	ADD A
	LD C,A
	ADD HL,BC
	CALL movrm
	CALL fmult
	LD A,(rndcnt)
	INC A
	AND 3
	LD B,0
	CP 1
	ADC B
	LD (rndcnt),A
	LD HL,rndtb2-4
	ADD A
	ADD A
	LD C,A
	ADD HL,BC
	CALL fadds
rnd1:	CALL movrf ;switch ho and lo bytes,
	LD A,E ;get lo
	LD E,C ;put ho in lo byte
	XOR 117o
	LD C,A ;put lo in ho byte
	LD (HL),200o ;make result positive
	DEC HL ;get pointer to exponent
	LD B,(HL) ;put exponent in overflow position
	LD (HL),200o ;set exp so result will be between 0 and 1
	LD HL,rndcnt-1
	INC (HL) ;increment the pertubation count
	LD A,(HL) ;see if its time
	SUB 253o
	JP NZ,ntptrb
	LD (HL),A ;zero the counter
	INC C
	DEC D
	INC E
ntptrb:	CALL normal ;normalize the result
	LD HL,rndx ;save random number generated for next
	JP movmf ; time
rndstr:	LD (HL),A ;zero the counters
	DEC HL
	LD (HL),A
	DEC HL
	LD (HL),A
	JP rnd1

					;storage for rnd
rndcm:	db	0 ;5.21: rndcnt-1
rndcnt:	db	0
	db	0
rndtab:	db	65o
	db	112o
	db	312o
	db	231o
	db	71o
	db	34o
	db	166o
	db	230o
	db	42o
	db	225o
	db	263o
	db	230o
	db	12o
	db	335o
	db	107o
	db	230o
	db	123o
	db	321o
	db	231o
	db	231o
	db	012o
	db	032o
	db	237o
	db	230o
	db	145o
	db	274o
	db	315o
	db	230o
	db	326o
	db	167o
	db	076o
	db	230o
rndx:	db	122o ;last random number generated, between 0 and 1
	db	307o
	db	117o
	db	200o
rndtb2:	db	150o
	db	261o
	db	106o
	db	150o
	db	231o
	db	351o
	db	222o
	db	151o
	db	020o
	db	321o
	db	165o
	db	150o
	page
	subttl	sine, cosine and tangent functions
					;cosine function
					;idea:  use cos(x)=sin(x+pi/2)
bobtst	set	0
cos:	LD HL,pi2 ;add pi/2 to fac
	CALL fadds
					;end intfsw
					;fall into sin


					;sine function
					;idea: use identities to get fac in quadrants i or iv
					;the fac is divided by 2*pi and the integer part is ignored because
					;sin(x+2*pi)=sin(x).  then the argument can be compared with pi/2 by
					;comparing the result of the division with pi/2/(2*pi)=1/4.
					;identities are then used to get the result in quadrants i or iv.
					;an approximation polynomial is then used to compute sin(x).
sin:
	LD A,(fac) ;will see if .lt.2^-10
					;and if so sin(x)=x
	CP 167o ;
	RET C
					;5.21: handle negative by pushing neg addr
	LD A,(faclo+2) ;load sign byte (facs, um80 bug workaround)
	OR A ;check sign
	JP P,sinpos ;skip if positive
	AND 7fh ;clear sign bit
	LD (faclo+2),A ;store back (facs)
	LD DE,neg ;address of neg routine
	PUSH DE ;push for return
sinpos:;sin by hart #3341
	LD BC,176q*256+042q
	LD DE,371q*256+203q ;will calculate x=fac/(2*pi)
	CALL fmult
	CALL pushf ;save x
	CALL int ;fac=int(x)
	POP BC
	POP DE
					;fetch x to registers
	CALL fsub ;fac=x-int(x)
	LD BC,177q*256+000q
	LD DE,000q*256+000q ;get 1/4
	CALL fcomp ;fac=facs/4
	JP M,sin2a
	LD BC,177q*256+200q
	LD DE,000q*256+000q ;-1/4
	CALL fadd ;
	LD BC,200q*256+200q
	LD DE,000q*256+000q ;-1/2
	CALL fadd ;x=x-1/2
	CALL sign
	CALL P,neg ;make sure if quadrants ii,iv
					;we work with 1/4-x
sin2:	LD BC,177q*256+000q
	LD DE,000q*256+000q ;1/4
	CALL fadd ;
	CALL neg ;
sin2a:	LD A,(facs) ;must reduce to [0,1/4]
	OR A ;sign in psw
	PUSH AF ;save for possible neg. after calc
	JP P,sin3
	XOR 200o ;
	LD (facs),A ;now in [0,1/4]
sin3:	LD HL,sincon ;point to hart coefficients
	CALL polyx ;do poly eval
	POP AF ;now to do sign
	RET P ;ok if pos
	LD A,(facs) ;fetch sign byte
	XOR 200o ;make neg
	LD (facs),A ;replace sign
	RET
					;end of intfsw cond

					;constants for sin, cos
p1b2pi:	db	000 ;1/(2*pi)
	db	000
	db	000
	db	000
	db	203o
	db	371o
	db	042o
	db	176o
pi2:	db	333o ; pi/2
	db	017o
	db	111o
	db	201o
fr4:	db	000 ; 1/4
	db	000
	db	000
	db	177o
sincon:;hart algorithm 3341 constants
;note that hart constants have been scaled by a power of 2
;this is due to range reduction as a % of 2*pi rather than pi/2
;would need to multiply argument by 4 but instead we factor this
;thru the constants.
	db	5 ;degree
	db	373o ; .1514851e-3
	db	327o
	db	036o
	db	206o
	db	145o ; -.4673767e-2
	db	046o
	db	231o
	db	207o
	db	130o ; .7968968e-1
	db	064o
	db	043o
	db	207o
	db	341o ; -.6459637
	db	135o
	db	245o
	db	206o
	db	333o ; 1.570796
	db	017o
	db	111o
	db	203o

					;tangent function
					;tan(x)=sin(x)/cos(x)
tan:	CALL pushf ;save arg
	CALL sin ;   tan(x)=sin(x)/cos(x)
	POP BC ;get x off stack
	POP HL ;pushf smashes (de)
	CALL pushf
	EX DE,HL ;get lo'S WHERE THEY BELONG
	CALL movfr
	CALL cos
	JP fdivt

	page
	subttl	arctangent function
					;idea: use identities to get arg between 0 and 1 and then use an
					;approximation polynomial to compute arctan(x)
atn:	CALL sign ;see if arg is negative
	CALL M,pshneg ;if arg is negative, use:
	CALL M,neg ;   arctan(x)=-arctan(-x)
	LD A,(fac) ;see if fac .gt. 1
	CP 201o
	JP C,atn2
	LD BC,201o*400o+0 ;get the constant 1
	LD D,C
	LD E,C ;compute reciprocal to use the identity:
	CALL fdiv ;  arctan(x)=pi/2-arctan(1/x)
	LD HL,fsubs ;put fsubs on the stack so we will return
	PUSH HL ; to it and subtract the reult from pi/2
atn2:	LD HL,atncon ;evaluate approximation polynomial
	CALL polyx
	LD HL,pi2 ;get pointer to pi/2 in case we have to
	RET ; subtract the result from pi/2

					;constants for atn
atncon:	db	11o ;degree
	db	112o ; .002866226
	db	327o
	db	073o
	db	170o
	db	002 ; -.01616574
	db	156o
	db	204o
	db	173o
	db	376o ; .04290961
	db	301o
	db	057o
	db	174o
	db	164o ; -.07528964
	db	061o
	db	232o
	db	175o
	db	204o ; .1065626
	db	075o
	db	132o
	db	175o
	db	310o ; -.142089
	db	177o
	db	221o
	db	176o
	db	344o ; .1999355
	db	273o
	db	114o
	db	176o
	db	154o ; -.3333315
	db	252o
	db	252o
	db	177o
	db	000 ; 1.0
	db	000
	db	000
	db	201o


;======================================================================
; Module: biptrg.mac
;======================================================================

	page
	title	biptrg	basic interpreter pointer get routines/whg/pga
	subttl	dimension & variable searching - ptrget
dimcon:	DEC HL ;see if comma ended this variable
	CALL chrgtr
	RET Z ;if terminator, good bye
	CALL synchr
	db	44 ;must be comma
;
; the "DIM" code sets dimflg and then falls into the variable
; search routine. the variable search routine looks at
; dimflg at three different points:
;
;	1) if an entry is found, dimflg being on indicates
;		a "DOUBLY DIMENSIONED" variable
;	2) when a new entry is being built dimflg'S BEING ON
;		indicates the indices should be used for
;		the size of each indice. otherwise the default
;		of ten is used.
;	3) when the build entry code finishes, only if dimflg is
;		off will indexing be done
;
dim:	LD BC,dimcon ;place to come back to
	PUSH BC
	db	366q ;"ORI" non zero thing
					;must turn the msb on
;
; routine to read the variable name at the current text position
; and put a pointer to its value in [d,e]. [h,l] is updated
; to point to the character after the variable name.
; valtyp is setup. note that evaluating subscripts in
; a variable name can cause recursive calls to ptrget so at
; that point all values must be stored on the stack.
; on return, [a] does not reflect the value of the terminating character
;
ptrget:	XOR A ;make [a]=0
	LD (dimflg),A ;flag it as such
	LD C,(HL) ;get first character in [c]
ptrgt2:	CALL islet ;check for letter
	JP C,snerr ;must have a letter
	XOR A
	LD B,A ;assume no second character
	LD (namcnt),A ;zero namcnt
	INC HL ;incrment text pointer
	LD A,(HL) ;get char
	CP '.' ;is it a dot?
	JP C,nosec ;too small for anything reasonable
	JP Z,issec ;"." is valid var char
	CP '9'+1 ;too big for numeric?
	JP NC,ptrgt3 ;yes
	CP '0' ;in right range?
	JP NC,issec ;yes, was numeric
ptrgt3:	CALL islet2 ;set carry if not alphabetic
	JP C,nosec ;allow alphabetics
issec:	LD B,A ;it is a number--save in b
	PUSH BC ;save [b,c]
	LD B,255 ;[b] counts the characters past #2
	LD DE,namcnt ;5.21: the place to put the characters (nambuf-1)
vmorch:	OR 128 ;extra characters must have the high bit on
					;so erase can scan backwards over them
	INC B ;increase the chacracter count
	LD (DE),A ;and store into the buffer
	INC DE ;and update the buffer pointer
	INC HL ;increment text pointer
	LD A,(HL) ;get char
	CP '9'+1 ;too big?
	JP NC,vmorc1 ;yes
	CP '0' ;in range for digit
	JP NC,vmorch ;yes, valid char
vmorc1:	CALL islet2 ;as are alphabetics
	JP NC,vmorch
	CP '.' ;dots also ok
	JP Z,vmorch ;so eat it
	LD A,B ;check for maximum count
	CP namlen-1 ;limited to size of nambuf only
	JP NC,snerr ;must be bad syntax
	POP BC ;get back the stored [b,c]
	LD (namcnt),A ;always set up count of extras
	LD A,(HL) ;restore terminating char
nosec:
	CP '%'+1 ;not a type indicator
	JP NC,tabtyp ;then dont check them
	LD DE,havtyp ;save jumps by using return address
	PUSH DE
	LD D,2 ;check for integer
	CP '%'
	RET Z
	INC D ;check for string
	CP '$'
	RET Z
	INC D ;check for single precision
	CP '!'
	RET Z
	LD D,8 ;assume its double precision
	CP '#' ;check the character
	RET Z ;when we match, setup valtyp
	POP AF ;pop off non-used havtyp address
tabtyp:	LD A,C ;get the starting character
	AND 127 ;get rid of the user-defined
					;function bit in [c]
	LD E,A ;build a two byte offset
	LD D,0
	PUSH HL ;save the text pointer
	LD HL,defta ;5.21: see what the default is
	ADD HL,DE
	LD D,(HL) ;get the type out of the table
	POP HL ;get back the text pointer
	DEC HL ;no marking character
havtyp:	LD A,D ;setup valtyp
	LD (valtyp),A
	CALL chrgtr ;read past type marker
	LD A,(subflg) ;get flag whether to allow arrays
	DEC A ;if subflg=1, "ERASE" has called
	JP Z,ersfin ;ptrget, and special handling must be done
	JP P,noarys ;no arrays allowed
	LD A,(HL) ;get char back
	SUB '(' ;array perhaps (if subflg set never will match)
	JP Z,isary ;it is!
	SUB '['-')'+1 ;see if left bracket
	JP Z,isary ;if so, ok subscript
noarys:	XOR A ;allow parens again
	LD (subflg),A ;save in flag location
	PUSH HL ;save the text pointer
	LD A,(nofuns) ;are functions active?
	OR A
	LD (prmflg),A ;indicate if parm1 needs searching
	JP Z,snfuns ;no functions so no special search
	LD HL,(prmlen) ;get the size to search
	LD DE,parm1 ;get the base of the search
	ADD HL,DE ;[h,l]= place to stop searching
	LD (aryta2),HL ;set up stopping point
	EX DE,HL ;[h,l]=start [d,e]=end
	JP lopfnd ;start looping
loptop:	LD A,(DE) ;get the valtyp of this simple variable
	LD L,A ;save so we know how much to skip
	INC DE
	LD A,(DE) ;[a]=first character of this variable
	INC DE ;point to 2nd char of var name
	CP C ;see if our variable matches
	JP NZ,notit1
	LD A,(valtyp) ;get type were looking for
	CP L ;compare with our valtyp
	JP NZ,notit1 ;not right kind -- skip it
	LD A,(DE) ;see if second chacracter matches
	CP B
	JP Z,finptr ;that was it, all done
notit1:	INC DE
nfinpt:	LD A,(DE) ;get length of var name in [a]
snomat:
					;skip over the
					;current variable since we didn'T MATCH
	LD H,0 ;[h,l]=number of bytes to skip
	ADD L ;add valtype to length of var
	INC A ;plus one
	LD L,A ;save in [l] to make offset
	ADD HL,DE ;add on the pointer
lopfnd:	EX DE,HL ;[d,e]=pointer into simple variables
	LD A,(aryta2) ;are low bytes different
	CP E ;test
	JP NZ,loptop ;yes
	LD A,(aryta2+1) ;are high bytes different
	CP D ;the same?
	JP NZ,loptop ;no, must be more vars to examine

notfns:	LD A,(prmflg) ;has parm1 been searched
	OR A
	JP Z,smkvar ;if so, create variable
	XOR A ;flag parm1 as searched
	LD (prmflg),A
snfuns:	LD HL,(arytab) ;stopping point is [aryta2]
	LD (aryta2),HL
	LD HL,(vartab) ;set up starting point
	JP lopfnd

;5.21: stub for varptr call - return address used as marker
ptrglb:	CALL ptrget
ptrrtn:	RET

; this is exit for varptr and others
varnot:
	LD D,A ;zero [d,e]
	LD E,A
	POP BC ;get rid of pushed [d,e]
	EX (SP),HL ;put return address back on stack
	RET ;return from ptrget

smkvar:	POP HL ;[h,l]= text pointer
	EX (SP),HL ;[h,l]= return address
	PUSH DE ;save current variable table position
	LD DE,ptrrtn ;5.21: check against ptrglb return addr
	CALL dcompr ;compare
	JP Z,varnot ;yes.
;5.21: comptr/compt2 checks not in original binary
	LD DE,retvar ;did eval call us?
	CALL dcompr ;if so, don'T MAKE A NEW VARIABLE
	POP DE ;restore the position
	JP Z,finzer ;make fac zero (all types) and skip return
	EX (SP),HL ;put return address back
	PUSH HL ;put the text pointer back
	PUSH BC ;save the looks
	LD A,(valtyp) ;get length of symbol table entry
	LD B,A ;[b]=valtyp
	LD A,(namcnt) ;include extra characters in size
	ADD B
	INC A ;as well as the extra character count
	LD C,A ;[b,c]=length of this variable
	PUSH BC ;save the valtyp on the stack
	LD B,0 ;[b]=0
	INC BC ;make the length include
					;the looks too
	INC BC
	INC BC
					;everything up by
	LD HL,(strend) ;the current end of storage
	PUSH HL ;save this #
	ADD HL,BC ;add on the amount of space
					;extra now being used
	POP BC ;pop off high address to move
	PUSH HL ;save new candidate for strend
	CALL bltu ;block transfer and make sure
					;we are not overflowing the
					;stack space
	POP HL ;[h,l]=new strend
	LD (strend),HL ;store since was ok
					;there was room, and block transfer
					;was done, so update pointers
	LD H,B ;get back [h,l] pointing at the end
	LD L,C ;of the new variable
	LD (arytab),HL ;update the array table pointer
zeroer:	DEC HL ;[h,l] is returned pointing to the
	LD (HL),0 ;end of the variable so we
	CALL dcompr ;zero backwards to [d,e] which
	JP NZ,zeroer ;points to the start of the variable
	POP DE ;[e]=valtyp
	LD (HL),D ;valtyp is in high order
	INC HL
	POP DE
	LD (HL),E ;put description
	INC HL
	LD (HL),D ;of this variable
					;into memory
	CALL nputsb ;save the extra characters in the name
	EX DE,HL ;pointer at variable into [d,e]
	INC DE ;point at the value
	POP HL ;restore the text pointer
	RET
finptr:	INC DE ;point at the extra character count
	LD A,(namcnt) ;see if the extra counts match
	LD H,A ;save length of new var
	LD A,(DE) ;get length of current var
	CP H ;are they the same?
	JP NZ,nfinpt ;skip extras and continue search
	OR A ;length zero?
	JP NZ,ntfprt ;no, more chars to look at
	INC DE ;point to value of var
	POP HL ;restore text pointer
	RET ;all done with this var
ntfprt:	EX DE,HL
	CALL matsub ;see if the characters match
	EX DE,HL ;table pointer back into [d,e]
	JP NZ,snomat ;if not, continue search
	POP HL ;get back the text pointer
	RET
;
; make all types zero and skip return
;
finzer:
	LD (fac),A ;make singles and doubles zero
	LD H,A ;make integers zero
	LD L,A
	LD (faclo),HL
	CALL getypr ;see if its a string
	JP NZ,pophr2 ;if not, done
	LD HL,reddym ;5.21: make it a null string by
	LD (faclo),HL ;pointing at a zero
pophr2:	POP HL ;get the text pointer
	RET ;return from eval


	page
	subttl	multiple dimension code

;
; format of arrays in core
;
; descriptor 
;	low byte = second charcter (200 bit is string flag)
;	high byte = first character
; length of array in core in bytes (does not include descriptor)
; number of dimensions 1 byte
; for each dimension starting with the first a list
; (2 bytes each) of the max indice+1
; the values
;
isary:	PUSH HL ;save dimflg and valtyp for recursion
	LD HL,(dimflg)
	EX (SP),HL ;text pointer back into [h,l]
	LD D,A ;set # dimensions =0
indlop:	PUSH DE ;save number of dimensions
	PUSH BC ;save looks
	LD DE,namcnt ;point at the area to save
	LD A,(DE) ;get length
	OR A ;is it zero?
	JP Z,shtnam ;yes, short name
	EX DE,HL ;save the text pointer in [d,e]
	ADD 2 ;we want smallest int .ge.(namcnt+1)/2
	RRA
	LD C,A ;see if there is room to save this stuff
	CALL getstk
	LD A,C ;restore count of pushes
lppsnm:	LD C,(HL) ;get values to push
	INC HL
	LD B,(HL)
	INC HL
	PUSH BC ;and do the save
	DEC A ;[a] times
	JP NZ,lppsnm
	PUSH HL ;save the address to store to
	LD A,(namcnt) ;save the number of bytes for a count
	PUSH AF
	EX DE,HL ;restore the text pointer
	CALL intidx ;evaluate indice into [d,e]
	POP AF ;count telling how much to restore
	LD (namtmp),HL ;save the text pointer
	POP HL ;the place to restore to
	ADD 2 ;calculate byte pops again
	RRA
lplnam:	POP BC
	DEC HL
	LD (HL),B
	DEC HL
	LD (HL),C
	DEC A ;loop [a] times poping name back into nambuf
	JP NZ,lplnam
	LD HL,(namtmp)
	JP lngnam ;was long one
shtnam:	CALL intidx ;evaluate it
	XOR A ;make sure namcnt=0
	LD (namcnt),A
lngnam:
	LD A,(optval) ;see what the option base is
	OR A
	JP Z,optb0 ;if base 0 do nothing
	LD A,D ;check for 0 subscript
	OR E ;which is illegal in base 1
	JP Z,bserr ;5.21: jz before dcx
	DEC DE ;adjust subscript
optb0:
	POP BC ;pop off the looks
	POP AF ;[a] = number of dimensions so far
	EX DE,HL ;[d,e]=text pointer
					;[h,l]=indice
	EX (SP),HL ;put the indice on the stack
					;[h,l]=valtyp & dimflg
	PUSH HL ;resave valtyp and dimflg
	EX DE,HL ;[h,l]=text pointer
	INC A ;increment # of dimensions
	LD D,A ;[d]=number of dimensions
	LD A,(HL) ;get terminating character
	CP 44 ;a comma so more indices follow?
	JP Z,indlop ;if so, read more
	CP ')' ;expected terminator?
	JP Z,dochrt ;do chrget for next one
	CP ']' ;bracket?
	JP NZ,snerr ;no, give error
dochrt:	CALL chrgtr
subsok:	LD (temp2),HL ;save the text pointer
	POP HL ;[h,l]= valtyp & dimflg
	LD (dimflg),HL ;save valtyp and dimflg
	LD E,0 ;when [d,e] is poped into psw, we
					;don'T WANT THE ZERO FLAG TO BE SET, SO
					;"ERASE" will have a unique condition
	PUSH DE ;save number of dimensions
	db	21o ;"LXI	D," over the next two bytes
ersfin:	PUSH HL ;save the text pointer
	PUSH AF ;save a dummy number of dimensions
					;with the zero flag set
;
; at this point [b,c]=looks. the text pointer is in temp2.
; the indices are all on the stack, followed by the number of dimensions.
;
	LD HL,(arytab) ;[h,l]=place to start the search
	db	76o ;"MVI A," around the next byte
lopfda:	ADD HL,DE ;skip over this array since it'S
					;not the one
	EX DE,HL ;[d,e]=current search point
	LD HL,(strend) ;get the place to stop into [h,l]
	EX DE,HL ;[h,l]=search point
	CALL dcompr ;stopping time?
	JP Z,notfdd ;yes, couldn'T FIND THIS ARRAY
	LD E,(HL) ;get valtyp in [e]
	INC HL
	LD A,(HL) ;get first character
	INC HL
	CP C ;see if it matches
	JP NZ,nmary1 ;not this one
	LD A,(valtyp) ;get type of var were looking for
	CP E ;same as this one?
	JP NZ,nmary1 ;no, skip this var
	LD A,(HL) ;get second character
	CP B ;another match?
	JP Z,cmpnam ;match, check out rest of name
nmary1:	INC HL ;point to size entry
bnamsz:	LD E,(HL) ;get var name length in [e]
	INC E ;add one to get correct length
	LD D,0 ;high byte of zero
	ADD HL,DE ;add offset
cnomat:
	LD E,(HL) ;[d,e]=length
	INC HL ;of the array being looked at
	LD D,(HL)
	INC HL
	JP NZ,lopfda ;if no match, skip this one
					;and try again
	LD A,(dimflg) ;see if called by "DIM"
	OR A ;zero means no
	JP NZ,dderr ;preserve [d,e], and dispatch to
					;"REDIMENSIONED VARIABLE" error
					;if its "DIM" calling ptrget
;
; temp2=the text pointer
; we have located the variable we were looking for
; at this point [h,l] points beyond the size to the number of dimensions
; the indices are on the stack followed by the number of dimensions
;
	POP AF ;[a]=number of dimensions
	LD B,H ;set [b,c] to point at number of dimensions
	LD C,L
	JP Z,pophrt ;"ERASE" is done at this point, so return
					;to do the actual erasure
	SUB (HL) ;make sure the number given now and
					;and when the array was set up are the
					;same
	JP Z,getdef ;jump off and read
					;the indices....

bserr:	LD DE,0+errbs ;"SUBSCRIPT OUT OF RANGE"
	JP error
cmpnam:	INC HL ;point to length of name
	LD A,(namcnt) ;see if count matches count in complex table
	CP (HL)
	JP NZ,bnamsz ;bad name size just skip and set nz cc
	INC HL ;point one byte after length field
	OR A ;length zero?
	JP Z,cnomat ;then found, exit
	DEC HL ;move back one
	CALL matsub ;otherwise try to match characters
	JP cnomat ;using common subroutine
;
; here when variable is not found in the array table
;
; building an entry:
; 
;	put down the descriptor	
;	setup numer of dimensions
;	make sure there is room for the new entry
;	remember varptr
;	tally=4 (valtyp for the extended)
;	skip 2 locs for later fill in -- the size
; loop:	get an indice
;	put number +1 down at varptr and increment varptr
;	tally= tally * number+1
;	decrement number-dims
;	jnz	loop
;	call reason with [h,l] reflecting last loc of variable
;	update strend
;	zero backwards
;	make tally include maxdims
;	put down tally
;	if called by dimension, return
;	otherwise index into the variable as if it
;	were found on the initial search
;
notfdd:
	LD A,(valtyp) ;get valtyp of new var
	LD (HL),A ;put down the variable type
	INC HL
	LD E,A
	LD D,0 ;[d,e]=size of one value (valtyp)
	POP AF ;[a]=number of dimensions
	JP Z,ptrrnz ;called by chain, just return non-zero
	LD (HL),C ;put down the descriptor
	INC HL
	LD (HL),B
	CALL nputsb ;store the extra characters in the table
	INC HL
	LD C,A ;[c]=number of two byte entries needed
					;to store the size of each dimension
	CALL getstk ;get space for dimension entries
	INC HL ;skip over the size locations
	INC HL
	LD (temp3),HL ;save the location to put the size
					;in -- points at the number of dimensions
	LD (HL),C ;store the number of dimensions
	INC HL
	LD A,(dimflg) ;called by dimension?
	RLA ;set carry if so
	LD A,C ;[a]=number of dimensions
loppta:
	JP C,popdim
	PUSH AF
	LD A,(optval) ;get the option base
	XOR 11 ;map 0 to 11 and 1 to 10
	LD C,A ;[b,c]=default dimension
	LD B,0
	POP AF
	JP NC,notdim ;default dimensions to ten
popdim:	POP BC ;pop off an indice into [b,c]
	INC BC ;add one to it for the zero entry
notdim:	LD (HL),C ;put the maximum down
	PUSH AF ;save the number of dimensions and
					;dimflg (carry)
	INC HL
	LD (HL),B
	INC HL
	CALL umult ;multiply [b,c]=newmax by curtol=[d,e]
	POP AF ;get the number of dimensions and
					;dimflg (carry) back
	DEC A ;decrement the number of dimensions left
	JP NZ,loppta ;handle the other indices
	PUSH AF ;save dimflg (carry)
	LD B,D ;[b,c]=size
	LD C,E
	EX DE,HL ;[d,e]=start of values
	ADD HL,DE ;[h,l]=end of values
	JP C,omerr ;out of memory pointer being generated?
	CALL reason ;see if there is room for the values
	LD (strend),HL ;update the end of storage
zerita:	DEC HL ;zero the new array
	LD (HL),0
	CALL dcompr ;back at the beginning?
	JP NZ,zerita ;no, zero more
	INC BC ;add one to the size to include
					;the byte for the number of dimensions
	LD D,A ;[d]=zero
	LD HL,(temp3) ;get a pointer at the number of dimensions
	LD E,(HL) ;[e]=number of dimensions
	EX DE,HL ;[h,l]=number of dimensions
	ADD HL,HL ;[h,l]=number of dimensions times two
	ADD HL,BC ;add on the size
					;to get the total number of bytes used
	EX DE,HL ;[d,e]=total size
	DEC HL ;back up to point to location to put
	DEC HL ;the size of the array in bytes in.
	LD (HL),E ;put down the size
	INC HL
	LD (HL),D
	INC HL
	POP AF ;get back dimflg (carry) and set [a]=0
	JP C,finnow
;
; at this point [h,l] points beyond the size to the number of dimensions
; strategy:
;	numdim=number of dimensions
;	curtol=0
; inlpnm:get a new indice
;	pop new max into curmax
;	make sure indice is not too big
;	mutliply curtol by curmax
;	add indice to curtol
;	numdim=numdim-1
;	jnz	inlpnm
;	use curtol*4 (valtyp for extended) as offset
;
getdef:	LD B,A ;[b,c]=curtol=zero
	LD C,A
	LD A,(HL) ;[a]=number of dimensions
	INC HL ;point past the number of dimensions
	db	26q ;"MVI D," around the next byte
inlpnm:	POP HL ;[h,l]= pointer into variable entry
	LD E,(HL) ;[d,e]=maximum for the current indice
	INC HL
	LD D,(HL)
	INC HL
	EX (SP),HL ;[h,l]=current indice
					;pointer into the variable goes on the stack
	PUSH AF ;save the number of dimensions
	CALL dcompr ;see if the current indice is too big
	JP NC,bserr ;if so "BAD SUBSCRIPT" error
	CALL umult ;curtol=curtol*current maximum
	ADD HL,DE ;add the indice to curtol
	POP AF ;get the number of dimensions in [a]
	DEC A ;see if all the indices have been processed
	LD B,H ;[b,c]=curtol in case we loop back
	LD C,L
	JP NZ,inlpnm ;process the rest of the indices
	LD A,(valtyp) ;see how big the values are
					;and multiply by that size
	LD B,H ;save the original value for multiplying
	LD C,L ;by three
	ADD HL,HL ;multiply by two at least
	SUB 4 ;for integers and strings
					;no more multiplying by two
	JP C,smlval
	ADD HL,HL ;now multiplied by four
	JP Z,donmul ;if single all done
	ADD HL,HL ;by eight for doubles
smlval:
	OR A ;fix cc'S FOR Z-80
	JP PO,donmul ;for strings
	ADD HL,BC ;add in the original
donmul:
	POP BC ;pop off the address of where the values
					;begin
	ADD HL,BC ;add it onto curtol to get the
					;place the value is stored
	EX DE,HL ;return the pointer in [d,e]
finnow:	LD HL,(temp2) ;reget the text pointer
	RET
ptrrnz:	SCF ;return with non-zero in [a]
	SBC A ;and condition codes set
	POP HL ;restore test pointer
	RET

;
; long variable name subroutines. after the normal 2 character name
; the count of additional characters is stored. following this
; comes the characters in order with the high bit turned on so a backward
; scan is possible
;
iadahl:	LD A,(HL) ;get the character count
	INC HL
addahl:	PUSH BC ;add [a] to [h,l]
	LD B,0
	LD C,A
	ADD HL,BC
	POP BC ;restore the saved [b,c]
	RET
nputsb:	PUSH BC ;this routine store the "LONG" name at [h,l]
	PUSH DE
	PUSH AF
	LD DE,namcnt ;point at data to save
	LD A,(DE) ;get the count
	LD B,A
	INC B ;[b]= number of bytes to save
slplng:	LD A,(DE) ;fetch store value
	INC DE
	INC HL ;move up to store name into table
	LD (HL),A ;do the store
	DEC B ;and repeat [b] times
	JP NZ,slplng ;for the count and data
	POP AF
	POP DE
	POP BC
	RET

matsub:	PUSH DE ;this routine tries to perform a match
	PUSH BC
	LD DE,nambuf ;point at count and data
	LD B,A ;[b]=character count
	INC HL ;point at the data
	INC B ;start off loop
slpmat:	DEC B ;matched all characters yet?
	JP Z,ismat2 ;if so, its a match
	LD A,(DE) ;get another character
	INC DE ;5.21: advance DE before compare
	CP (HL) ;see if its the same
	INC HL ;move forward in definition table
	JP Z,slpmat ;if match keep going until end
	LD A,B ;need to advance by [b]-1 to skip bad chars
	DEC A
	CALL NZ,addahl ;use the common subroutine. [h,l]=[h,l]+[a]
	XOR A ;set cc'S NON ZERO FOR NO MATCH
	DEC A ;and return [a]=ff
ismat2:	POP BC ;restore saved registers
	POP DE
	RET

	page

;======================================================================
; Module: biedit.mac
;======================================================================

	page
	title	biedit	basic interpreter edit routines/pga etc.
	subttl	edit command
;
;
;[c] contains count of characters in line
;[b] contains current character position 0=first in line.
;[d] contains number of times to repeat this subcommand
;[h,l] point to current character
;
;*
erredt:	LD (errflg),A ;reset the flag to call edit
	LD HL,(errlin) ;get the line number
	OR H ;see if it was direct
	AND L
	INC A ;set zero flag on direct
	EX DE,HL ;line number into [d,e]
	RET Z ;go back if direct
	JP eredit
edit:	CALL linspc ;get the argument line number
	RET NZ ;error if not end of line
eredit:	POP HL ;get rid of newstt address
eedits:	EX DE,HL ;save current line in dot
	LD (dot),HL ;for later edit or list
	EX DE,HL ;get back line # in [h,l]
	CALL fndlin ;find the line in question
	JP NC,userr ;if not found, undefined statement error.
	LD H,B ;ponter to line is in [b,c]
	LD L,C ;transfer it to [h,l]
	INC HL ;pass over pointer to next line
	INC HL ;like so.
	LD C,(HL) ;get first byte of line #
	INC HL ;move to 2nd byte
	LD B,(HL) ;pick it up into b
	INC HL ;advance to point to first byte of line
	PUSH BC ;save line # on stack
	CALL buflin ;unpack line into buf
lled:	POP HL ;get back line #
inled:	PUSH HL ;save it back on stack
	LD A,H ;test for double byte zero
	AND L
	INC A
	LD A,'!' ;get prompt for direct edit
	CALL Z,outdo ;send it
	CALL NZ,linprt ;print line # if not inlin edit
	LD A,' ' ;type a space
	CALL outdo ;...
	LD HL,buf ;get start of buf in [h,l]
	PUSH HL ;save [h,l] while we calc line length
	LD C,255 ;assume 0 char line
lenlp:	INC C ;bump count of chars
	LD A,(HL) ;get char from line
	INC HL ;bump pointer
	OR A
	JP NZ,lenlp ;if not zero (end of line) keep counting...
	POP HL ;get back pointer to line
	LD B,A ;set current line posit to zero
disped:	LD D,0 ;assume repition count is zero
dispi:
	CALL inchri ;get a char from user
	OR A ;ignore nulls
	JP Z,dispi
	CALL makups ;make upper case command
	SUB '0' ;get rid of offset
	JP C,notdgi ;...
	CP 10
	JP NC,notdgi
	LD E,A ;save char
	LD A,D ;get accum repitition
	RLCA ;multiply by 2
	RLCA ;by 4
	ADD D ;and add to get 5*d
	RLCA ;*2 to get 10*d
	ADD E ;add digit
	LD D,A ;save back new accum
	JP dispi ;get next char

notdgi:	PUSH HL ;save text pointer
	LD HL,disped ;put return address to disped
	EX (SP),HL ;on the stack
	DEC D ;see if d=0 (rep factor)
	INC D ;set condition codes
	JP NZ,ntzerd ;branch around
	INC D ;make it 1
ntzerd:
	CP 8-'0' ;backspace?
	JP Z,baked ;handle it
	CP 177o-'0' ;del?
	JP Z,deled ;backspace pointer
	CP 13-'0' ;carriage return
	JP Z,cred ;done editing
	CP ' '-'0' ;space
	JP Z,sped ;go to routine
	CP 'A'+40o-'0' ;command in lower case?
	JP C,notlw4 ;no, so ok.
	SUB 40o ;convert to upper case
notlw4:	CP 'Q'-'0' ;quit?
	JP Z,qed ;if so, quit & print "OK" or return to inlin
	CP 'L'-'0' ;l?
	JP Z,led ;branch
	CP 'S'-'0' ;s?
	JP Z,sed ;search
	CP 'I'-'0' ;i?
	JP Z,ied ;insert
	CP 'D'-'0' ;d?
	JP Z,ded ;delete
	CP 'C'-'0' ;c?
	JP Z,ced ;change
	CP 'E'-'0' ;end?
	JP Z,eed ;(same as <cr> but doesnt print rest)
	CP 'X'-'0' ;extend?
	JP Z,xed ;go to end of line & insert
	CP 'K'-'0' ;kill??
	JP Z,ked ;(same as "S" but deletes chars)
	CP 'H'-'0' ;hack??
	JP Z,hed ;hack off the rest of the line & insert
	CP 'A'-'0' ;again??
	LD A,7 ;get ready to type bel.
	JP NZ,outdo ;no match, send bel and return to dispatcher
	POP BC ;dispi return address
	POP DE ;line number into [d,e]
	CALL crdo ;type a carriage return line-feed
	JP eedits ;restart editing

sped:	LD A,(HL) ;get char from curent posit
	OR A ;are we at end of line?
	RET Z ;if so, return
	INC B ;bump current position
	CALL outch1 ;type character
	INC HL ;move pointer to next char
	DEC D ;test if done with repititions
	JP NZ,sped ;repeat
	RET ;return to dispatcher

ked:	PUSH HL ;save current char posit
	LD HL,typslh ;type slash when done
	EX (SP),HL ;put it on stack & get posit back
	SCF ;set the carry flag
sed:	PUSH AF ;save condition codes
	CALL inchri ;get search char
	LD E,A ;save it
	POP AF
	PUSH AF
	CALL C,typslh ;type beginning slash for "K"
srcalp:	LD A,(HL)
	OR A
	JP Z,popart
	CALL outch1 ;type the char
	POP AF ;get kill flag
	PUSH AF ;save back
	CALL C,delchr ;delete the char if k command.
	JP C,notsrc ;and dont move pointer as delchr already did
	INC HL
	INC B ;increment line posit
notsrc:	LD A,(HL) ;are we at end
	CP E ;are current char & search
	JP NZ,srcalp ;char the same? if not, look more
	DEC D ;look for n matches
	JP NZ,srcalp ;if not 0, keep looking

popart:	POP AF ;get rid of kill flag
	RET ;done searching
led:	CALL lisprt ;type rest of line
	CALL crdo ;type carriage return
	POP BC ;get rid of return to disped
	JP lled ;go to main code

ded:	LD A,(HL) ;get char which we are trying to delete
	OR A ;is it the end of line marker?
	RET Z ;done if so
	LD A,'\' ;type backslash
	CALL outch1 ;like so
dellp:	LD A,(HL) ;get char from line
	OR A ;are we at end?
	JP Z,typslh ;type slash
	CALL outch1 ;type char we'RE GOING TO DELETE
	CALL delchr ;delete current char
	DEC D ;decrement delete count
	JP NZ,dellp ;keep doing it
typslh:
	LD A,'\' ;type ending slash
	CALL outdo ;like so
	RET

ced:	LD A,(HL) ;are we at end of line?
	OR A ;see if 0
	RET Z ;return
ced2:	CALL inchri ;get char to replace char
	CP 32 ;is it control char?
	JP NC,notccc ;no
	CP 10 ;is it lf?
	JP Z,notccc ;yes
	CP 7 ;or bell?
	JP Z,notccc ;ok
	CP 9 ;or tab?
	JP Z,notccc ;ok
	LD A,7 ;get bell
	CALL outdo ;send it
	JP ced2 ;retry
notccc:	LD (HL),A ;save in memory
	CALL outch1 ;echo the char were using to replace
	INC HL ;bump pointer
	INC B ;increment position within line
	DEC D ;are we done changing?
	JP NZ,ced ;if not, change some more.
	RET ;done
hed:	LD (HL),0 ;make line end at current position
	LD C,B ;set up line length correctly

xed:	LD D,255 ;find end of line
	CALL sped ;by calling spacer
;now fall into insert code
ied:
	CALL inchri ;get char to insert

	CP 177o ;delete??
	JP Z,typarw ;yes, act like "_"
	CP 8 ;backspace?
	JP Z,typar1 ;do delete
	CP 15o ;is it a carriage return?
	JP Z,cred ;dont insert, and simulate <cr>
	CP 33o ;is it escape?
	RET Z ;if so, done.
	CP 8 ;backspace?
	JP Z,typar1 ;type backarrow and delete
	CP 10 ;line feed?
	JP Z,ntarrw ;allow it
	CP 7 ;bell?
	JP Z,ntarrw ;allow it
	CP 9 ;tab?
	JP Z,ntarrw ;allow it
	CP 32 ;is it illegal char
	JP C,ied ;too small
	CP '_' ;delete previous char inserted?
	JP NZ,ntarrw ;if not, jump around next code
typarw:
	LD A,'_' ;type it
typar1:	DEC B ;are we at start of line?
	INC B ;lets see
	JP Z,dingi ;if so, type ding.
	CALL outch1 ;type the back arrow
	DEC HL ;back up the pointer
	DEC B ;move back posit in line
	LD DE,ied ;set up return address
	PUSH DE ;save it  on stack & fall through
; subroutine to delete char pointed to by [h,l]. corrects c.
delchr:	PUSH HL ;save current posit pointer
	DEC C ;make length of line one less
cmprss:	LD A,(HL) ;get char to delete
	OR A ;are we at end of line
	SCF ;flag that delchr was called (for k)
	JP Z,pophrt ;if so, done compressing
	INC HL ;point to next byte
	LD A,(HL) ;pick it up
	DEC HL ;now back again
	LD (HL),A ;deposit it
	INC HL ;now to next byte
	JP cmprss ;keep crunching
ntarrw:	PUSH AF ;save the char to be inserted
	LD A,C ;get length of line
	CP buflen ;see if we arent trying to make line too long
	JP C,okins ;if length ok, go insert
	POP AF ;get the unlawful char
dingi:
	LD A,7 ;type a bell to let user know
	CALL outdo ;it all over
iedg:	JP ied ;he has to type <esc> to get out
okins:	SUB B ;calc pointer to 0 at end of line
	INC C ;we are going to have line longer by 1
	INC B ;position moves up one also
	PUSH BC ;save [b,c]
	EX DE,HL ;save [d,e] in [h,l]
	LD L,A ;save # of bytes to move in [l]
	LD H,0 ;get set to add [d,e] to [h,l]
	ADD HL,DE ;calc high pointer
	LD B,H ;get high byte to move pointer
	LD C,L ;in [b,c]
	INC HL ;always move at least zero at end
	CALL bltuc ;move line out 1 char
	POP BC ;restore [b,c]
	POP AF ;get char back
	LD (HL),A ;save it in line
	CALL outch1 ;type the char
	INC HL ;point to next char
	JP iedg ;and go get more chars

baked:	LD A,B ;are we moving back past the
	OR A ;first character
	RET Z ;don'T ALLOW IT
	DEC HL ;move char pointer back
	LD A,8
	CALL outch1 ;echo it
	DEC B ;change current position
	DEC D ;are we done moving back?
	JP NZ,deled ;if not, go back more
	RET ;return

deled:	LD A,B ;are we moving back past the
	OR A ;first character
	RET Z ;don'T ALLOW IT
	DEC B ;change current position
	DEC HL ;move char pointer back
	LD A,(HL) ;get current char
	CALL outch1 ;echo it
	DEC D ;are we done moving back?
	JP NZ,deled ;if not, go back more
	RET ;return

cred:	CALL lisprt ;type rest of line
eed:	CALL crdo ;type carriage return
	POP BC ;get rid of disped address
	POP DE ;get line # off stack
	LD A,D ;double byte zero.
	AND E
	INC A ;set zero if [d,e] = all ones.
editrt:;used by auto code
	LD HL,bufmin ;5.21: start krunching at buf (buf-1)
	RET Z ;return to inlin if called from there
	SCF ;flag line # was seen to fool insert code
	PUSH AF ;psw is on stack
	INC HL ;now point at buf.
	JP edent ;go to entry point in main code

qed:	POP BC ;get rid of disped address
	POP DE ;get line # off stack
	LD A,D ;double byte zero.
	AND E
	INC A ;set zero if [d,e] = all ones.
	JP Z,fininl ;type cr and store zero in buf.
	JP ready ;otherwise called from main

;======================================================================
; Module: biprtu.mac
;======================================================================

	page
	title	biprtu	basic interpreter print using driver/whg
	subttl	print using driver
;
; come here after the "USING" clause in a print statement
; is recognized. the idea is to scan the using string until
; the value list is exhausted, finding string and numeric
; fields to print values out of the list in,
; and just outputing any characters that aren'T PART OF
; a print field.
;
cstrng	set	134o
curncy	set	44o ;use dollar sign as default

prinus:	CALL frmchk ;evaluate the "USING" string
	CALL chkstr ;make sure it is a string
	CALL synchr
	db	73o ;must be delimited by a semi-colon
	EX DE,HL ;[d,e]=text pointer
	LD HL,(faclo) ;get pointer to "USING" string descriptor
	JP inius ;dont pop off or look at usflg
reusst:	LD A,(usflg) ;did we print out a value last scan?
	OR A ;set cc'S
	JP Z,fcerr3 ;no, give error
	POP DE ;[d,e]=pointer to "USING" string descriptor
	EX DE,HL ;[d,e]=text pointer
inius:	PUSH HL ;save the pointer to "USING" string descriptor
	XOR A ;initially indicate there are more
					;values in the value list
	LD (usflg),A ;reset the flag that says values printed
	INC A ;5.21: A=1, turn zero flag off
					;to indicate the value list hasn'T ENDED
	PUSH AF ;save flag indicating whether the value
					;list has ended
	PUSH DE ;save the text pointer into the value list
	LD B,(HL) ;[b]=length of the "USING" string
	OR B ;see if its zero
fcerr3:	JP Z,fcerr ;if so, "ILLEGAL FUNCTION CALL"
	INC HL ;[h,l]=pointer at the "USING" string'S
	LD A,(HL) ;5.21: use A as temp, not C
	INC HL
	LD H,(HL)
	LD L,A
	JP prcchr ;go into the loop to scan
					;the "USING" string
bgstrf:	LD E,B ;save the "USING" string character count
	PUSH HL ;save the pointer into the "USING" string
	LD C,2 ;the \\ string field has 2 plus
					;number of enclosed spaces width
lpstrf:	LD A,(HL) ;get the next character
	INC HL ;advance the pointer at the "USING" string
					;data
	CP cstrng ;the field terminator?
	JP Z,isstrf ;go evaluate a string and print
	CP ' ' ;a field extender?
	JP NZ,nostrf ;if not, its not a string field
	INC C ;increment the field width
					;see if there are more characters
	DEC B
	JP NZ,lpstrf ;keep scanning for the field terminator
;
; since  string field wasn'T FOUND, THE "USING" STRING 
; character count and the pointer into it'S DATA MUST
; be restored and the "\" printed
;
nostrf:	POP HL ;restore the pointer into "USING" string'S DATA
	LD B,E ;restore the "USING" string character count
	LD A,cstrng ;restore the character
;
; here to print the character in [a] since it wasn'T PART OF ANY FIELD
;
newuch:	CALL plsprt ;if a "+" came before this character
					;make sure it gets printed
	CALL outdo ;print the character that wasn'T
					;part of a field
prcchr:	XOR A ;set [d,e]=0 so if we dispatch
	LD E,A ;some flags are already zeroed
	LD D,A ;don'T PRINT "+" TWICE
plsfin:	CALL plsprt ;allow for multiple pluses
					;in a row
	LD D,A ;set "+" flag
	LD A,(HL) ;get a new character
	INC HL
	CP '!' ;check for a single character
	JP Z,smstrf ;string field
	CP '#' ;check for the start of a numeric field 
	JP Z,numnum ;go scan it
	CP '&' ;see if its a variable length string field
	JP Z,varstr ;go print entire string
	DEC B ;all the other possibilities
					;require at least 2 characters
	JP Z,reusin ;if the value list is not exhausted
					;go reuse "USING" string
	CP '+' ;a leading "+" ?
	LD A,8 ;setup [d] with the plus-flag on in
	JP Z,plsfin ;case a numeric field starts
	DEC HL ;pointer has already been incremented
	LD A,(HL) ;get back the current character
	INC HL ;reincrement the pointer
	CP '.' ;numeric field with trailing digits
	JP Z,dotnum ;if so go scan with [e]=
					;number of digits before the "."=0
	CP '_' ;check for literal character declaration
	JP Z,litchr
	CP cstrng ;check for a big string field starter
	JP Z,bgstrf ;go see if it really is a string field
	CP (HL) ;see if the next character matches the
					;current one
	JP NZ,newuch ;if not, can'T HAVE $$ OR ** SO ALL THE
					;possibilities are exhausted
	CP curncy ;is it $$ ?
	JP Z,dolrnm ;go set up the flag bit
	CP '*' ;is it ** ?
	JP NZ,newuch ;if not, its not part
					;of a field since all the possibilities
					;have been tried
	LD A,B ;see if the "USING" string is long
	INC HL ;check for $
	CP 2 ;enough for the special case of
	JP C,notspc ; **$
	LD A,(HL)
	CP curncy ;is the next character $ ?
notspc:	LD A,32 ;set the asterisk bit
	JP NZ,spcnum ;if it not the special case, don'T
					;set the dollar sign flag
	DEC B ;decrement the "USING" string character count
					;to take the $ into consideration
	INC E ;increment the field width for the
					;floating dollar sign
	db	376q ;"CPI" over the next byte
					;mvi si,  in 8086
dolrnm:	XOR A ;clear [a]
	ADD 16 ;set bit for floating dollar sign flag
	INC HL ;point beyond the special characters
spcnum:	INC E ;since two characters specify
					;the field size, initialize [e]=1
	ADD D ;put new flag bits in [a]
	LD D,A ;into [d]. the plus flag may have
					;already been set
numnum:	INC E ;increment the number of digits before
					;the decimal point
	LD C,0 ;set the number of digits after
					;the decimal point = 0
	DEC B ;see if there are more characters
	JP Z,endnus ;if not, we are done scanning this
					;numeric field
	LD A,(HL) ;get the new character
	INC HL ;advance the pointer at the "USING" string data
	CP '.' ;do we have trailing digits?
	JP Z,aftdot ;if so, use special scan loop
	CP '#' ;more leading digits ?
	JP Z,numnum ;increment the count and keep scanning
	CP 54o ;does he want a comma
					;every three digits?
	JP NZ,finnum ;no more leading digits, check for ^^^
	LD A,D ;turn on the comma bit
	OR 64
	LD D,A
	JP numnum ;go scan some more
;
; here when a "." is seen in the "USING" string
; it starts a numeric field if and only if
; it is followed by a "#"
;
dotnum:	LD A,(HL) ;get the character that follows
	CP '#' ;is this a numeric field?
	LD A,'.' ;if not, go back and print "."
	JP NZ,newuch
	LD C,1 ;initialize the number of
					;digits after the decimal point
	INC HL
aftdot:	INC C ;increment the number of digits
					;after the decimal point
	DEC B ;see if the "USING" string has more
	JP Z,endnus ;characters, and if not, stop scanning
	LD A,(HL) ;get the next character
	INC HL
	CP '#' ;more digits after the decimal point?
	JP Z,aftdot ;if so, increment the count and keep
					;scanning
;
; check for the "^^^^" that indicates scientific notation
;
finnum:	PUSH DE ;save [d]=flags and [e]=leading digits
	LD DE,notsci ;place to go if its not scientific
	PUSH DE ;notation
	LD D,H ;remember [h,l] in case
	LD E,L ;its not scientific notation
	CP '^' ;is the first character "^" ?
	RET NZ
	CP (HL) ;is the second character "^" ?
	RET NZ
	INC HL
	CP (HL) ;is the third character "^" ?
	RET NZ
	INC HL
	CP (HL) ;is the fourth character "^" ?
	RET NZ
	INC HL
	LD A,B ;were there enough characters for "^^^^"
	SUB 4 ;it takes four
	RET C
	POP DE ;pop off the notsci return address
	POP DE ;get back [d]=flags [e]=leading digits
	LD B,A ;make [b]=new character count
	INC D ;turn on the scientific notation flag
	INC HL
	db	312o ;skip the next two bytes with "JZ"
notsci:	EX DE,HL ;restore the old [h,l]
	POP DE ;get back [d]=flags [e]=leading digits
endnus:	LD A,D ;if the leading plus flag is on
	DEC HL
	INC E ;include leading "+" in number of digits
	AND 8 ;don'T CHECK FOR A TRAILING SIGN
	JP NZ,endnum ;all done with the field if so
					;if there is a leading plus
	DEC E ;no leading plus so don'T INCREMENT THE
					;number of digits before the decimal point
	LD A,B
	OR A ;see if there are more characters
	JP Z,endnum ;if not, stop scanning
	LD A,(HL) ;get the current character
	SUB '-' ;trail minus?
	JP Z,sgntrl ;set the trailing sign flag
	CP '+'-'-' ;a trailing plus?
	JP NZ,endnum ;if not, we are done scanning
	LD A,8 ;turn on the positive="+" flag
sgntrl:	ADD 4 ;turn on the trailing sign flag
	ADD D ;include with old flags
	LD D,A
	DEC B ;decrement the "USING" string character
					;count to account for the trailing sign
endnum:	POP HL ;[h,l]=the old text pointer
	POP AF ;pop off flag that says whether there
					;are more values in the value list
	JP Z,fldfin ;if not, we are done with the "PRINT"
	PUSH BC ;save [b]=# of characters remaining in
					;"USING" string and [c]=trailing digits
	PUSH DE ;save [d]=flags and [e]=leading digits
	CALL frmevl ;read a value from the value list
	POP DE ;[d]=flags & [e]=# of leading digits
	POP BC ;[b]=# character left in "USING" string
					;[c]=number of trailing digits
	PUSH BC ;save [b] for entering scan again
	PUSH HL ;save the text pointer
	LD B,E ;[b]=# of leading digits
	LD A,B ;make sure the total number of digits
	ADD C ;does not exceed twenty-four
	CP 25
	JP NC,fcerr ;if so, "ILLEGAL FUNCTION CALL"
	LD A,D ;[a]=flag bits
	OR 128 ;turn on the "USING" bit
	CALL pufout ;print the value
	CALL strout ;actually print it
fnstrf:	POP HL ;get back the text pointer
	DEC HL ;see what the terminator was
	CALL chrgtr
	SCF ;set flag that crlf is desired
	JP Z,crdnus ;if it was a end-of-statement
					;flag that the value list ended
					;and that  crlf should be printed
	LD (usflg),A ;flag that value has been printed.
					;doesnt matter if zero set, [a]
					;must be non-zero otherwise
	CP 73o ;a semi-colon?
	JP Z,semusn ;a legal delimiter
	CP 54o ;a comma ?
	JP NZ,snerr ;the delimeter was illegal
semusn:	CALL chrgtr ;is there another value?
crdnus:	POP BC ;[b]=characters remaining in "USING" string
	EX DE,HL ;[d,e]=text pointer
	POP HL ;[h,l]=point at the "USING" string
	PUSH HL ;descriptor. resave it.
	PUSH AF ;save the flag that indicates
					;whether or not the value list terminated
	PUSH DE ;save the text pointer
;
; since frmevl may have forced garbage collection
; we have to use the number of characters already scanned
; as an offset to the pointer to the "USING" string'S DATA
; to get a new pointer to the rest of the characters to
; be scanned
;
	LD A,(HL) ;get the "USING" string'S LENGTH
	SUB B ;subtract the number of characters
					;already scanned
	INC HL ;5.21: mvi d,0 before address fetch
	LD D,0 ;setup [d,e] as a double byte offset
	LD E,A
	LD A,(HL) ;the "USING" string'S
	INC HL ;string data
	LD H,(HL)
	LD L,A ;5.21: use A as temp, not C
	ADD HL,DE ;add on the offset to get
					;the new pointer
chkusi:	LD A,B ;[a]=the number of characters left to scan
	OR A ;see if there are any left
	JP NZ,prcchr ;if so, keep scanning
	JP finusi ;see if there are more values
reusin:	CALL plsprt ;print a "+" if necessary
	CALL outdo ;print the final character
finusi:	POP HL ;pop off the text pointer
	POP AF ;pop off the indicator of whether or not
					;the value list has ended
	JP NZ,reusst ;if not, reuse the "USING" string
fldfin:	CALL C,crdo ;if not comma or semi-colon
					;ended the value list
					;print a crlf
	EX (SP),HL ;save the text pointer
					;[h,l]=point at the "USING" string'S
					;descriptor
	CALL fretm2 ;finally free it up
	POP HL ;get back the text pointer
	JP finprt ;zero [ptrfil]
;
; here to handle a literal character in the using string preceded
; by "_"
;
litchr:	CALL plsprt ;print previous "+" if any
	DEC B ;decrement count for actual character
	LD A,(HL) ;fetch literal character
	INC HL
	CALL outdo ;output literal character
	JP chkusi ;go see if using string ended
;
; here to handle variable length string field specified with "&"
;
varstr:	LD C,0 ;5.21: 0 means variable length
	JP isstr1
;
; here when the "!" indicating a single character
; string field has been scanned
;
smstrf:	LD C,1 ;set the field width to 1
	db	76q ;skip next byte with a "MVI A,"
isstrf:	POP AF ;get rid of the [h,l] that was being
					;saved in case this wasn'T A STRING FIELD
isstr1:	DEC B ;decrement the "USING" string character count
	CALL plsprt ;print a "+" if one came before the field
	POP HL ;take off the text pointer
	POP AF ;take of the flag which says
					;whether there are more values in the
					;value list
	JP Z,fldfin ;if there are no more values
					;then we are done
	PUSH BC ;save [b]=number of characters yet to
					;be scanned in "USING" string
	CALL frmevl ;read a value
	CALL chkstr ;make sure its a string
	POP BC ;[c]=field width
	PUSH BC ;resave [b]
	PUSH HL ;save the text pointer
	LD HL,(faclo) ;get a pointer to the descriptor
	LD B,C ;[b]=field width
	LD C,0 ;set up for "LEFT$"
	LD A,B ;5.21: save width in A
	PUSH AF ;save the field width for space padding
	LD A,B ;get width again
	OR A ;test if zero
	CALL NZ,leftus ;5.21: call only if width non-zero
	CALL strprt ;print the string
	LD HL,(faclo) ;see if it needs to be padded
	POP AF ;[a]=field width
	OR A ;5.21: test for 0 (varstr uses 0, not 255)
	JP Z,fnstrf ;dont print any trailing spaces
	SUB (HL) ;5.21: no dcr a - direct subtract
	LD B,A
	LD A,' ' ;setup the print character
	INC B ;dummy increment of number of spaces
uprtsp:	DEC B ;see if more spaces
	JP Z,fnstrf ;no, go see if the value list ended and
					;resume scanning
	CALL outdo ;print a space
	JP uprtsp ;and loop printing them
;
; when a "+" is detected in the "USING" string
; if a numeric field follows a bit in [d] should
; be set, otherwise "+" should be printed.
; since deciding whether a numeric field follows is very
; difficult, the bit is always set in [d].
; at the point it is decided a character is not part
; of a numeric field, this routine is called to see
; if the bit in [d] is set, which means
; a plus preceded the character and should be
; printed.
;
plsprt:	PUSH AF ;save the current character
	LD A,D ;check the plus bit
	OR A ;since it is the only thing that could
					;be turned on
	LD A,'+' ;setup to print the plus
	CALL NZ,outdo ;print it if the bit was set
	POP AF ;get back the current character
	RET

;======================================================================
; Module: bio.mac
;======================================================================

	page
	title	bio basic interpreter i/o routines/whg/pga/mbm...
	subttl	outdo, outcon - character output
; microsoft basic has a number of primitive i/o routines:
;	outdo (either call or rst) prints char in [a] no registers affected
;		to either terminal or disk file or printer depending
;		flags:
;			prtflg if non-zero print to printer
;			ptrfil if non-zero print to disk file pointed to
;				by ptrfil
;
;	inchr	input a character into [a] condiation codes destroyed.
;		input from disk file if ptrfil non-zero.
;
;	crdo	print a carriage return sequence on either
;		terminal or printer or disk file depending on flags
;		see outdo above. see below code for register use
outdo:	PUSH AF
	PUSH HL
	CALL ptrchk ;5.21: check if disk output
outcon:
	JP NZ,filout
	POP HL
lptcod:	LD A,(prtflg) ;see if we want to talk to lpt
	OR A ;test bits

					;regular okia driver only
	JP Z,ttychr ;if zero then not
	POP AF ;get back char
	PUSH AF
	CP 8 ;backspace?
	JP NZ,ntbks2 ;no
	LD A,(lptpos) ;get lpt pos
	SUB 1 ;5.21: subtract 1, set carry if was 0
	JP C,lptbks ;skip store if was 0
	LD (lptpos),A ;correct lptpos
lptbks:	POP AF ;5.21: restore char
	JP lptchr ;send char
ntbks2:	CP 9 ;tab
	JP NZ,notabl ;no
morspl:	LD A,32 ;get space
	CALL outdo ;send it
	LD A,(lptpos) ;get current print posit
	AND 7 ;at tab stop?
	JP NZ,morspl ;go back if more to print
	POP AF ;pop off char
	RET ;return
notabl:

	POP AF ;get char back
	PUSH AF ;save again
	SUB 13 ;if funny control char, (lf) do nothing
	JP Z,zerlp1
	JP C,lptch1 ;just print char
	LD A,(lptsiz) ;get size of printer
	INC A ;is it infinite?
	LD A,(lptpos) ;get posit
	JP Z,zerlpt ;then dont fold
	PUSH HL ;ssave [h,l]
	LD HL,lptsiz ;max length
	CP (HL) ;set cc'S
	POP HL ;then do crlf
	CALL Z,printw ;do crlf
					;5.21: no jz here - falls through to cpi 255
zerlpt:
	CP 255 ;max length?
	JP Z,lptch1 ;then just print
	INC A ;increment posit
zerlp1:	LD (lptpos),A
lptch1:	POP AF ;get char back
lptchr:	PUSH AF ;save back again
	PUSH BC ;save [b,c]
	PUSH DE ;save [d,e]
	PUSH HL
	LD C,A ;cpm wants char in [c]
lptout:	CALL 0 ;printer routine address stored here
	POP HL ;restore regs
	POP DE
	POP BC
	POP AF ;restore char
	RET ;return from outchr
finlpt:	XOR A ;reset print flag so
	LD (prtflg),A ;output goes to terminal
	LD A,(lptpos) ;get current lpt posit
	OR A ;on left hand margin already?
	RET Z ;yes, return
printw:	LD A,13 ;put out crlf
	CALL lptchr
	LD A,10
	CALL lptchr
	XOR A ;zero lptpos
	LD (lptpos),A
	RET ;done
ttychr:
	LD A,(cntofl)
	OR A
	JP NZ,ppswrt ;no, do output
	POP AF ;get the character
	PUSH BC
	PUSH AF ;and save it again
	CP 8 ;backspace?
	JP NZ,ntbks1 ;no
	LD A,(ttypos) ;get tty pos
	OR A ;5.21: test if zero (NOT sui like LPT!)
	JP Z,morspr ;if zero, exit without output
	DEC A ;decrement ttypos
	LD (ttypos),A ;store new ttypos
	LD A,8 ;restore backspace char
	JP tryout ;send it to output
ntbks1:	CP 9 ;outputting tab?
	JP NZ,notab ;no.
morsp:	LD A,32 ;get space char
	CALL outdo ;call outchr recursively (!)
	LD A,(ttypos) ;get current print pos.
	AND 7 ;at tab stop yet??
	JP NZ,morsp ;no, keep spacing
morspr:	POP AF ;restore current char (tab)
	POP BC ;get [b,c] back
	RET ;all done
notab:
	CP 32 ;is this a meaningful character?
	JP C,tryout ;if it'S A NON-PRINTING CHARACTER
	LD A,(linlen)
	LD B,A ;[b]=line length
					;don'T INCLUDE IT IN TTYPOS
	LD A,(ttypos) ;see if print head is at the end of the line
	INC B ;is width 255?
	JP Z,inctps ;yes, just inc ttypos
	DEC B ;correct [b]
	CP B
linpt1	set	$-1
	CALL Z,crdo ;type crlf and set ttypos and [a]=0 if so
					;5.21: no jz here - falls through to cpi 255
inctps:
	CP 255 ;have we hit max #?
	JP Z,tryout ;then leave it there
	INC A ;increment ttypos since we'RE
					;going to print a character.
	LD (ttypos),A ;store new print head position
					;store new print head position
tryout:
	POP AF ;get char off stack
	POP BC ;restore [b,c]
	PUSH AF ;save psw back
noprin:; end of phlz80 off
	POP AF ;get character back

	PUSH AF ;then save back
	PUSH BC ;save all regs
	PUSH DE
	PUSH HL
					;5.21: no ani 127 here
	LD C,A ;cpm wants char in [c]
conout:	CALL 0 ;cpm (bios) entry point
	POP HL ;restore regs
	POP DE
	POP BC
	POP AF ;restore char
	RET ;return from outchr




	page
	subttl	inchr, tryin - character input routines
inchr:
	CALL ptrchk ;5.21: check if disk file input
	JP Z,notflc ;get character from terminal
	CALL indskc ;read a character
	RET NC ;5.21: return directly with character
	PUSH BC ;save all registers
	PUSH DE
	PUSH HL
	CALL prgfin ;close the file
	POP HL
	POP DE
	POP BC
	LD A,(chnflg) ;chain in progress?
	OR A ;test..
	JP NZ,chnret ;yes, perform variable block transfer, etc.
	LD A,(lstfre) ;run it or not?
	OR A
	JP Z,norun ;5.21: jz before lxi
	LD HL,newstt
	PUSH HL ;5.21: push instead of xthl
	JP runc ;5.21: jmp instead of jnz
norun:
	PUSH HL ;5.21: push h, not xthl
	PUSH BC ;preserve registers
	PUSH DE
	LD HL,reddy ;print prompt "OK"
	CALL strout
	POP DE
	POP BC
	XOR A
	POP HL
	RET
notflc:;5.21: removed pop h - ptrchk preserves h
tryin:
inchri:
	PUSH BC ;save regs
	PUSH DE
	PUSH HL
conin:	CALL 0 ;changed to call ci
	POP HL ;restore regs
	POP DE
	POP BC
cnlcb2	set	$-1 ;console command change loc

inexit:
	AND 127 ;get rid of parity bit
	CP conto ;is it supress output?
	RET NZ
	LD A,(cntofl)
	OR A ;are we supressing output?
	CALL Z,ctropt ;then print control-o now.
	CPL ;complement its state
	LD (cntofl),A ;save back
	OR A ;see if we are turning output on.
	JP Z,ctropt ;print the ^o
	XOR A ;return with null which is always ignored

	RET

					;for some reason sbc doent have cst
					;terminates rshack
	page
	subttl	crdo	put out a carriage return and associated routines
; crdo returns with all registers except [a]
; preserved, [a]=0, zero cc set, carry reset.

; crdonz only does a cr if ttypos is not zero.
; in other words, only print a carriage return when not at left margin.
crdonz:
	LD A,(ttypos) ;get current ttypos
					;get current ttypos
	OR A ;set cc'S
	RET Z ;if already zero, return
	JP crdo ;do cr
fininl:	LD (HL),0 ;put a zero at the end of buf
	LD HL,bufmin ;setup pointer
					;don'T PUT CR/LF OUT TO LOAD FILE
crdo:
	LD A,13
	CALL outdo
	LD A,10
crfino:	CALL outdo
crfin:
	CALL ptrchk ;5.21: check if outputting to disk
	JP Z,crcont ;not disk file, continue
	XOR A ;crfin must always return with a=0
	RET ;and carry=0.
crcont:
	LD A,(prtflg) ;going to printer?
	OR A ;test
	JP Z,ntprtr ;no
	XOR A ;done, return
	LD (lptpos),A ;zero positon
	RET
ntprtr:
	XOR A ;set ttypos=0
	LD (ttypos),A
	LD A,(nulcnt) ;get number of nulls
prtnul:	DEC A
	RET Z ;all nulls done [a]=0
					;some routines depend on crdo
					;and crfin returning [a]=0 and z true
	PUSH AF ;save the count
	XOR A ;[a]= a null
	CALL outdo ;send it out
	POP AF ;restore the count
	JP prtnul ;loop printing nulls
iscntc:

	PUSH BC ;save regs
	PUSH DE
	PUSH HL

consts:	CALL csts ;get console status
	POP HL
	POP DE
	POP BC
	OR A ;set cc'S
	RET Z ;0=false - no character typed
					;if none, return
cntccn:
	CALL inchri ;read the character that was present
	CP 23o ;pause? (^s)
	CALL Z,inchri ;if pause, read next char
	LD (charc),A ;save char in the buffer
	CP 3 ;^c?
	CALL Z,ctrlpt ;type ^c
	JP stop
inkey:
	CALL chrgtr
	PUSH HL ;save the text pointer
	CALL charcg ;get charc and clear if set
	JP NZ,bufcin
mrchri:
const3::	CALL 0
	OR A ;set non-zero if char there
	JP Z,nulrt ;no, return null string
; get char if one,
;****some versions already have char and dont want this code ***
;****so they should turn on chseat to turn off reads
	CALL inchri
bufcin:	PUSH AF
	CALL strin1 ;make one char string
	POP AF
	LD E,A ;char to [d]
	CALL setstr ;stuff in descriptor and goto putnew

nulrt:	LD HL,reddym ;5.21: reddy-1
	LD (faclo),HL
	LD A,3
	LD (valtyp),A
	POP HL
	RET

charcg::	LD A,(charc) ;get saved char
	OR A ;is there one?
	RET Z ;no, done
	PUSH AF ;save char
	XOR A ;clear it
	LD (charc),A ;by storing zero
	POP AF ;restore char and non-zero cc'S
	RET
outch1:
	CALL outdo ;output the char
	CP 10 ;was it a lf?
	RET NZ ;no, return
	LD A,13 ;do cr
	CALL outdo
	CALL crfin
	LD A,10 ;restore char (lf)
	RET

;======================================================================
; Module: bimisc.mac
;======================================================================

	page
	title	bimisc	basic interpreter miscellaneous routines/whg/pga etc.

;
; this is the block transfer routine
; it makes space by shoving everything forward
;
; [h,l] = destination of high address
; [d,e] = low address to be transferred
; [b,c] = high address to be transferred
;
; a check is made to make sure a reasonable amount
; of space remains between the top of the stack and
; the highest location transferred into
;
; on exit [h,l]=[d,e]=low [b,c]=location low was moved into
;
bltu:	CALL reason ;check destination to make
					;sure the stack won'T BE OVERRUN
bltuc:	PUSH BC ;exchange [b,c] and [h,l]
	EX (SP),HL
	POP BC
bltlop:	CALL dcompr ;see if we are done
	LD A,(HL) ;get the word to transfer
	LD (BC),A ;transfer it
	RET Z
	DEC BC
	DEC HL ;backup for next guy
	JP bltlop
;
; this routine is used to make sure a certain number
; of locations remain available for the
; stack. the call is :
;	mvi	c,number of 2 byte entries necessary
;	call	getstk
;
; this routine must be called by any routine which puts
; an arbitrary amount of stuff on the stack
; (i.e. any recursive routine like frmevl)
; it is also called by routines such as "GOSUB" and "FOR"
; which make permanent entries on the stack
; routines which merely use and free up the guaranteed
; numlev stack locations need not call this
;
getstk:	PUSH HL ;save [h,l]
	LD HL,(memsiz)
	LD B,0
	ADD HL,BC
	ADD HL,BC ;see if we can have this many
;
; [h,l]= some address
; [h,l] is examined to make sure at least numlev
; locations remain between it and the top of the stack
;
cons1	set	256-(2*numlev)
	LD A,cons1 ;set [h,l]=-[h,l]-2*numlev
	SUB L
	LD L,A
	LD A,255
	SBC H
	LD H,A ;5.21: mov h,a before jc
	JP C,omerr ;in case [h,l] was too big(mbm 3/18**)
	ADD HL,SP ;if so, carry will be set
	POP HL ;get back original [h,l]
	RET C ;was ok?
omerr:

					;for space reasons leave this code out

					;only important in versions where
					;stack context survives other errors
	LD HL,(topmem)
	DEC HL ;up some memory space
	DEC HL ;make sure the fndfor stopper is saved
	LD (savstk),HL ;place stack is restored from
omerrr:	LD DE,0+errom ;"OUT OF MEMORY"
	JP error
reason:	CALL really ;enough space between string & stack
	RET NC ;yes
	PUSH BC ;save all regs
	PUSH DE
	PUSH HL
	CALL garba2 ;do a garbage collection
	POP HL ;restore all regs
	POP DE
	POP BC
	CALL really ;enough space this time?
	RET NC ;yes
	JP omerrr ;no, give "OUT OF MEMORY BUT DONT TOUCH STACK
really:	PUSH DE ;save [d,e]
	EX DE,HL ;save [h,l] in [d,e]
	LD HL,(fretop) ;get where strings are
	CALL dcompr ;is top of vars less than strings?
	EX DE,HL ;back to [d,e]
	POP DE ;restore [d,e]
	RET ;done
	page
	subttl	nodsks, scratch (new), runc, clearc, stkini, qinlin
; the code below sets the file mode to 0 (closed) for all fcb'S
nodsks:	LD A,(maxfil) ;get largest file #
	LD B,A ;into b for counter
	LD HL,filptr ;point to table of file data blocks
	XOR A ;make a zero to mark files as closed
	INC B
lopnto:	LD E,(HL) ;get pointer to file data block in [d,e]
	INC HL
	LD D,(HL)
	INC HL
	LD (DE),A ;mark file as closed (mode zero)
	DEC B
	JP NZ,lopnto ;loop until done
	CALL clsall
	XOR A
					;dont wipe out init message on screen(new does clear screen)
;
; the "NEW" command clears the program text as well
; as variable space
;
scrath:	RET NZ ;make sure there is a terminator
scrtch:
	LD HL,(txttab) ;get pointer to start of text
	CALL toff ;turn off trace. set [a]=0.
	LD (proflg),A ;no longer a protected file
	LD (autflg),A ;clear auto mode
	LD (ptrflg),A ;say no pointers exist
	LD (HL),A ;save at end off text
	INC HL ;bump pointer
	LD (HL),A ;save zero
	INC HL ;bump pointer
	LD (vartab),HL ;new start of variables
runc:
	LD HL,(txttab) ;point at the start of text
	DEC HL
;
; clearc is a subroutine which initializes the variable and
; array space by reseting arytab [the end of simple variable space]
; and strend [the end of array storage]. it falls into stkini
; which resets the stack. [h,l] is preserved.
;
clearc:	LD (temp),HL ;save [h,l] in temp
	LD A,(mrgflg) ;doing a chain merge?
	OR A ;test
	JP NZ,levdtb ;leave default table alone
	XOR A
	LD (optflg),A ;indicate no "OPTION" has been seen
	LD (optval),A ;default to "OPTION BASE 0"
	LD B,26 ;initialize the default valtype table
	LD HL,deftbl ;point at the first entry
lopdft:	LD (HL),4 ;loop 26 times storing a default valtyp
	INC HL ;for single precision
					;count off the letters
	DEC B
	JP NZ,lopdft ;loop back, and setup the rest of the table
levdtb:
	LD DE,rndcop ;reset the random number generator
	LD HL,rndx ;seed in rndx
	CALL move
	LD HL,rndcm ;5.21: and zero count registers (rndcnt-1)
	XOR A
	LD (HL),A
	INC HL
	LD (HL),A
	INC HL
	LD (HL),A
	XOR A
	LD (oneflg),A ;reset on error flag for runs
	LD L,A ;reset error line number
	LD H,A ;by setting onelin=0.
	LD (onelin),HL
	LD (oldtxt),HL ;make continuing impossible
	LD HL,(memsiz)
	LD A,(chnflg) ;are we chaining?
	OR A ;test
	JP NZ,godfre ;fretop is good, leave it alone
	LD (fretop),HL ;free up string space
godfre:	XOR A ;make sure [a] is zero, cc'S SET
	CALL restor ;restore data
	LD HL,(vartab) ;get start of variable space
	LD (arytab),HL ;save in start of array space
	LD (strend),HL ;and end of variable storage
	LD A,(mrgflg) ;doing chain merge?
	OR A
	CALL Z,clsall ;if so, dont close files...
;
; stkini resets the stack pointer eliminating
; gosub & for context.  string temporaries are freed
; up, subflg is reset, continuing is disallowed,
; and a dummy entry is put on the stack. this is so
; fndfor will always find a non-"FOR" entry at the bottom
; of the stack. [a]=0 and [d,e] is preserved.
;
stkini:	POP BC ;get return address here
	LD HL,(topmem)
	DEC HL ;take into account fndfor stopper
	DEC HL
	LD (savstk),HL ;make sure savstk ok just in case.
	INC HL ;increment back for sphl
	INC HL
stkerr:	LD SP,HL ;initialize stack
	LD HL,tempst
	LD (temppt),HL ;initialize string temporaries
	CALL clrovc ;back to normal overflow print mode
	CALL finlpt
	CALL finprt ;clear ptrfil, other i/o flags
	XOR A ;zero out a
	LD H,A ;zero out h
	LD L,A ;zero out l
	LD (prmlen),HL ;flag no active parameters
	LD (nofuns),A ;indicate no user functions active
	LD (prmln2),HL ;no parameters being built
	LD (funact),HL ;set number of functions active to 0
	LD (prmstk),HL ;and no parameter blocks on the stack
	LD (subflg),A ;allow subscripts
	PUSH HL ;put zero (non $for,$gosub)
					;on the stack
	PUSH BC ;put return address back on
gtmprt:	LD HL,(temp) ;get saved [h,l]
	RET

	page
	subttl	dcompr, synchr - replacements for compar & synchk in rstles version
dcompr:	LD A,H ;replacement for "COMPAR" rst
	SUB D
	RET NZ
	LD A,L
	SUB E
	RET

synchr:	LD A,(HL) ;replacement for "SYNCHK" rst
	EX (SP),HL
	CP (HL)
	JP NZ,synerr
	INC HL
	EX (SP),HL
	INC HL ;look at next char
	LD A,(HL) ;get it
	CP ':' ;is it end of statment or bigger
	RET NC
syncon:	JP chrcon ;rest of chrget
synerr:	JP snerr
	subttl	restore, stop, end

restor:	EX DE,HL ;save [h,l] in [d,e]
	LD HL,(txttab)
	JP Z,bgnrst ;restore data pointer to beginning of program
	EX DE,HL ;text pointer back to [h,l]
	CALL linget ;get the following line number
	PUSH HL ;save text pointer
	CALL fndlin ;find the line number
	LD H,B ;get pointer to line in [h,l]
	LD L,C
	POP DE ;text pointer back to [d,e]
	JP NC,userr ;should have found line
bgnrst:
	DEC HL ;initialize datptr to [txttab]-1
resfin:	LD (datptr),HL ;read finishes come to resfin
	EX DE,HL ;get the text pointer back
	RET
stop:	RET NZ ;return if not control-c and make
					;sure "STOP" statements have a terminator
stoprg:
	INC A
	JP constp
					;to type the break message
ends:	RET NZ ;make sure "END" statements have a terminator
	PUSH AF ;preserve condition codes over call to clsall
	CALL Z,clsall
	POP AF ;restore condition codes
constp:	LD (savtxt),HL ;save for "CONTINUE"
	LD HL,tempst ;reset string temp pointer
	LD (temppt),HL ;save in case ^c print using
	db	41q ;"LXI H," over next two
stpend:	OR 377o ;set non-zero to force printing of break message
	POP BC ;pop off newstt address
endcon:	LD HL,(curlin) ;save curlin
	PUSH HL ;save line to print
	PUSH AF ;save the message flag
					;zero means don'T PRINT "BREAK"
	LD A,L
	AND H ;see if it was direct
	INC A
	JP Z,diris ;if not set up for continue
	LD (oldlin),HL ;save old line #
	LD HL,(savtxt) ;get pointer to start of statement
	LD (oldtxt),HL ;save it
diris:
	XOR A
	LD (cntofl),A ;force output
	CALL finlpt
	CALL crdonz ;print cr if ttypos .ne. 0
	POP AF ;get back ^c flag
	LD HL,brktxt ;"BREAK"
	JP NZ,errfin ;call strout and fall into ready
	JP stprdy ;pop off line number & fall into ready
	page
	subttl	ctrlpt, ddt, cont, null, tron, troff
ctropt:	LD A,conto ;print an ^o.
ctrlpt:	PUSH AF ;save current char
	SUB 3 ;control-c?
	JP NZ,ntctct ;no
	LD (prtflg),A ;display ^c only(not on lpt)
	LD (cntofl),A ;reset ^o flag
ntctct:
	LD A,'^' ;print up-arrow.
	CALL outdo ;send it
	POP AF ;get back control char.
	ADD 100o ;make printable
	CALL outdo ;send it
	JP crdo ;and then send crlf.
cont:	LD HL,(oldtxt) ;a stored text pointer of
					;zero is setup by stkini
					;and indicates there is nothing
					;to continue
	LD A,H ;"STOP","END",typing crlf
	OR L ;to "INPUT" and ^c setup oldtxt
reserr:	LD DE,0+errcn ;"CAN'T CONTINUE"
	JP Z,error
	EX DE,HL ;save [h,l]
	LD HL,(oldlin)
	EX DE,HL ;5.21: redundant xchg pair in original
	EX DE,HL
	LD (curlin),HL ;set up old line # as current line #
	EX DE,HL ;restore [h,l]
	RET
null:	CALL getbyt
	RET NZ ;make sure there is a terminator
	INC A ;code at crdo expects at least 1
	LD (nulcnt),A ;change number of nulls
	RET
ton:	db	76q ;"MVI A," non-zero quantity
toff:	XOR A ;make [a]=0 for no trace
	LD (trcflg),A ;update the trace flag
	RET
	page
	subttl	swap, erase
swap:	CALL ptrget ;[d,e]=pointer at value #1
	PUSH DE ;save the pointer at value #1
	PUSH HL ;save the text pointer
	LD HL,swptmp ;temporary store location
	CALL vmove ;swptmp=value #1
	LD HL,(arytab) ;get arytab so change can be noted
	EX (SP),HL ;get the text pointer back
					;and save current [arytab]
	CALL getypr
	PUSH AF ;save the type of value #1
	CALL synchr
	db	44 ;make sure the variables are
					;delimited by a comma
	CALL ptrget ;[d,e]=pointer at value #2
	POP AF ;5.21: pop psw, then mov b,a
	LD B,A ;[b]=type of value #1
	CALL getypr ;[a]=type of value #2
	CP B ;make sure they are the same
	JP NZ,tmerr ;if not, "TYPE MISMATCH" error
	EX (SP),HL ;[h,l]=old [arytab] save the text pointer
	EX DE,HL ;[d,e]=old [arytab]
	PUSH HL ;save the pointer at value #2
	LD HL,(arytab) ;get new [arytab]
	CALL dcompr
	JP NZ,fcerj ;5.21: if its changed, error (via stub)
	POP DE ;[d,e]=pointer at value #2
	POP HL ;[h,l]=text pointer
	EX (SP),HL ;save the text pointer on the stack
					;[h,l]=pointer at value #1
	PUSH DE ;save the pointer at value #2
	CALL vmove ;transfer value #2 into value #1'S OLD
					;position
	POP HL ;[h,l]=pointer at value #2
	LD DE,swptmp ;location of value #1
	CALL vmove ;transfer swptmp=value #1 into value #2'S
					;old position
	POP HL ;get the text pointer back
	RET
fcerj:	JP fcerr ;5.21: stub for indirect jump
erase:
	LD A,1
	LD (subflg),A ;that this is "ERASE" calling ptrget
	CALL ptrget ;go find out where to erase
	JP NZ,fcerj ;5.21: ptrget did not find variable! (via stub)
	PUSH HL ;save the text pointer
	LD (subflg),A ;zero out subflg to reset "ERASE" flag
	LD H,B ;[b,c]=start of array to erase
	LD L,C
	DEC BC ;back up to the front
	DEC BC ;no value type without length=2
	DEC BC ;back up one more
lpbknm:	LD A,(BC) ;get a character. only the count has high bit=0
	DEC BC ;so loop until we skip over the count
	OR A ;skip all the extra characters
	JP M,lpbknm
	DEC BC
	DEC BC
	ADD HL,DE ;[h,l]=the end of this array entry
	EX DE,HL ;[d,e]=end of this array
	LD HL,(strend) ;[h,l]=last location to move up
erslop:	CALL dcompr ;see if the last location is going to be moved
	LD A,(DE) ;do the move
	LD (BC),A
	INC DE ;update the pointers
	INC BC
	JP NZ,erslop ;move the rest
	DEC BC
	LD H,B ;setup the new storage end pointer
	LD L,C
	LD (strend),HL
	POP HL ;get back the text pointer
	LD A,(HL) ;see if more erasures needed
	CP 54o ;additional variables delimited by comma
	RET NZ ;all done if not
	CALL chrgtr
	JP erase
casdon:
popaht:	POP AF
	POP HL ;get the text pointer
	RET
	page
;
;test for a letter / carry on=not a letter
;		     carry off=a letter
;
islet:	LD A,(HL)
islet2:	CP 'A'
	RET C ;if less than "A", return early
	CP 91 ;91="Z"+1
	CCF
	RET
cleaj:	JP clearc ;5.21: stub for indirect jump
	subttl	clear
;
; this code is for the "CLEAR" command with an argument
; to change the amount of string space allocated.
; if no formula is given the amount of string space
; remains unchanged.
;
clear:	JP Z,cleaj ;5.21: if no formula just clear (via stub)
	CP 54o ;allow no string space
	JP Z,cskpcm
	CALL intid2 ;get an integer into [d,e]
	DEC HL
	CALL chrgtr ;see if its the end
	JP Z,cleaj ;5.21: via stub
cskpcm:	CALL synchr
	db	54o
	JP Z,cleaj ;5.21: via stub
	EX DE,HL
	LD HL,(topmem) ;get highest address
	EX DE,HL
	CP 54o
	JP Z,clears ;should finish there
	CALL clrhlp ;5.21: call helper subroutine
clears:	DEC HL ;back up
	CALL chrgtr ;get char
	PUSH DE ;save new high mem
	JP Z,cdfstk ;use same stack size
	CALL synchr
	db	54o
	JP Z,cdfstk
	CALL clrhlp ;5.21: changed from intid2 to clrhlp
	DEC HL
	CALL chrgtr
	JP NZ,snerr
cleart:	EX (SP),HL ;save text pointer
	PUSH HL ;save candidate for topmem
	LD HL,0+(2*numlev)+20 ;check stack size is reasonable
	CALL dcompr
	JP NC,omerj ;5.21: via stub
	POP HL
	CALL subde ;subtract [h,l]-[d,e] into [d,e]
	JP C,omerj ;5.21: wanted more than total! (via stub)
	PUSH HL ;save memsiz
	LD HL,(vartab) ;top location in use
	LD BC,0+20 ;leave breathing room
	ADD HL,BC
	CALL dcompr ;room?
	JP NC,omerj ;5.21: no, don't even clear (via stub)
	EX DE,HL ;new stack location [h,l]
	LD (memsiz),HL ;set up new stack location
	POP HL ;get back memsiz
	LD (topmem),HL ;set it up, must be ok
	POP HL ;regain the text pointer
	JP cleaj ;5.21: go clear (via stub)
;5.21: helper subroutine for CLEAR formula evaluation
clrhlp:	CALL frmhqi ;call helper at 22D1
	LD A,D
	OR E
	JP Z,fcerr ;error if zero
	RET
omerj:	JP omerr ;5.21: stub for indirect jump
cdfstk:	PUSH HL ;save text pointer
	LD HL,(topmem) ;figure out current stack size so
	EX DE,HL ;it is saved
	LD HL,(memsiz)
	LD A,E
	SUB L
	LD E,A
	LD A,D
	SBC H
	LD D,A
	POP HL
	JP cleart

subde:	LD A,L
	SUB E
	LD E,A
	LD A,H
	SBC D
	LD D,A
	RET
	page
	subttl	next code
;
; a "FOR" entry on the stack has the following format:
;
; low address
;	token ($for in high byte)  1 bytes
;	a pointer to the loop variable  2 bytes
;	under ansi & length=2, two bytes giving text pointer of matching "NEXT"
;	a byte reflecting the sign of the increment 1 byte
;	under length=2, a byte minus for integer and positive for floating "FOR"s
;	the step 4 bytes
;	the upper value 4 bytes
;	the line # of the "FOR" statement 2 bytes
;	a text pointer into the "FOR" statement 2 bytes
; high address
;
; total 16-19 bytes
;
next:
	PUSH AF ;save the character codes
	db	366q ;set [a] non-zero
nexts:	XOR A ;flag that "FOR" is using "NEXT"
	LD (nxtflg),A
	POP AF ;get back the character code
	LD DE,0 ;for the "NEXT"
					;statement without any args
					;we call fndfor with [d,e]=0
nextc:
	LD (nxttxt),HL ;save starting text pointer
	CALL NZ,ptrget ;get a pointer to the
					;loop variable into [d,e]
	LD (temp),HL ;put the text pointer
					;in a temp location
					;in case the loop terminates
	CALL fndfor ;try to find a for entry
					;on the stack whose variable name
					;matches this ones
	JP NZ,nferr ;"NEXT WITHOUT FOR"
	LD SP,HL ;setup stack pointer by chopping
					;at this point
	PUSH DE ;put the variable ptr back on
	LD E,(HL) ;pick up the correct "NEXT" text pointer
	INC HL
	LD D,(HL)
	INC HL
	PUSH HL ;save the pointer into the stack entry
	LD HL,(nxttxt) ;[h,l]=text pointer at the start of this "NEXT"
	CALL dcompr
	JP NZ,nferr ;if no match, "NEXT WITHOUT FOR"
	POP HL
	POP DE ;get back the variable pointer
	PUSH DE
	LD A,(HL) ;step onto the stack
	PUSH AF
	INC HL
	PUSH DE ;put the pointer to the loop
					;variable onto the stack
	LD A,(HL) ;get flag whether this is an integer "FOR"
	INC HL ;advance the "FOR" entry pointer
	OR A ;set the minus flag if it'S AN INTEGER "FOR"
	JP M,intnxt ;handle integers seperately
	CALL movfm ;step value into the fac
	EX (SP),HL ;put the pointer into the
					;for entry onto the stack
	PUSH HL ;put the pointer to the loop
					;variable back onto the stack
	LD A,(nxtflg) ;is "FOR" using "NEXT"
	OR A
	JP NZ,nxtdo ;no, continue "NEXT"
	LD HL,fvalsv ;fetch the initial value into the fac
	CALL movfm
	XOR A ;continue the "NEXT" with initial value
nxtdo:	CALL NZ,fadds
	POP HL ;pop off the pointer to 
					;the loop variable
	CALL movmf ;mov fac into loop variable
	POP HL ;get the entry pointer
	CALL movrm ;get the final into the registers
	PUSH HL ;save the entry pointer
	CALL fcomp ;compare the numbers returning 377 if fac is
					;less than the registers,
					;0 if equal, otherwise 1
	JP finnxt ;skip over integer code
intnxt:	INC HL ;skip the four dummy bytes
	INC HL
	INC HL
	INC HL
	LD C,(HL) ;[b,c]= the step
	INC HL
	LD B,(HL)
	INC HL
	EX (SP),HL ;save the entry pointer on the stack
					;and set [h,l]=pointer to the loop variable
	LD E,(HL) ;[d,e]=loop variable value
	INC HL
	LD D,(HL)
	PUSH HL ;save the pointer at the loop variable value
	LD L,C
	LD H,B ;setup to add [d,e] to [h,l]
	LD A,(nxtflg) ;see if "FOR" is using "NEXT"
	OR A
	JP NZ,inxtdo ;no, just continue next
	LD HL,(fvalsv) ;get the initial value
	JP iforin ;continue first iteration check
inxtdo:	CALL iadd ;add the step to the loop variable
	LD A,(valtyp) ;see if there was overflow
	CP 4 ;turned to single-precision?
	JP Z,overr ;indice got too large
iforin:	EX DE,HL ;[d,e]=new loop variable value
	POP HL ;get the pointer at the loop variable
	LD (HL),D ;store the new value
	DEC HL
	LD (HL),E
	POP HL ;get back the pointer into the "FOR" entry
	PUSH DE ;save the value of the loop variable
	LD E,(HL) ;[d,e]=final value
	INC HL
	LD D,(HL)
	INC HL
	EX (SP),HL ;save the entry pointer again
					;get the value of the loop variable into [h,l]
	CALL icomp ;do the compare
finnxt:
	POP HL ;pop off the "FOR" entry pointer which is now
					;pointing past the final value
	POP BC ;get the sign of the increment
	SUB B ;subtract the increments sign from that
					;of (current value-final value)
	CALL movrm ;get line # of "FOR" into [d,e]
					;get text pointer of "FOR" into [b,c]
	JP Z,loopdn ;if sign(final-current)+sign(step)=0
					;then the loop is finished
	EX DE,HL
	LD (curlin),HL ;store the line #
	LD L,C ;setup the text pointer
	LD H,B
	JP nxtcon

loopdn:	LD SP,HL ;eliminate the for entry
					;since [h,l] moved all
					;the way down the entry
	LD (savstk),HL ;update saved stack
	LD HL,(temp) ;restore the text pointer
	LD A,(HL) ;is there a comma at the end
	CP 44 ;if so look at another
	JP NZ,newstt ;variable name to "NEXT"
	CALL chrgtr ;read first charcter
	CALL nextc ;do next, but don'T ALLOW
					;blank variable name [d,e]=stk ptr
					;and will never match any varptr
					;use call to put dummy "NEWSTT" entry on
	page
					;end i8086 conditonal

;======================================================================
; Module: bistrs.mac
;======================================================================

	page
	title	bistrs	basic interpreter string  routines/whg/pga etc.
;
; the following routine compares two strings
; one with desc in [d,e] other with desc. in [faclo, faclo+1]
; a=0 if strings equal
; a=377 if b,c,d,e .gt. faclo
; a=1 if b,c,d,e .lt. faclo
;
;5.21: ptrchk - subroutine to check if disk file output active
ptrchk:	PUSH HL
	LD HL,(ptrfil)
	LD A,H
	OR L
	POP HL
	RET
strcmp:	CALL frestr ;free up the fac string, and get the
					;pointer to the fac descriptor in [h,l]
	LD A,(HL) ;save the length of the fac string in [a]
	INC HL
	LD C,(HL) ;save the pointer at the fac string
					;data in [b,c]
	INC HL
	LD B,(HL)
	POP DE ;get the stack string pointer
	PUSH BC ;save the pointer at the fac string data
	PUSH AF ;save the fac string length
	CALL fretmp ;free up the stack string and return
					;the pointer to the stack string descriptor
					;in [h,l]
	POP AF ;5.21: restore fac string length to A
	LD D,A ;5.21: move length to D
	LD E,(HL) ;[e]=length of stack string
	INC HL
	LD C,(HL) ;[b,c]=pointer at stack string
	INC HL
	LD B,(HL)
	POP HL ;get back 2nd character pointer
csloop:	LD A,E ;both strings ended
	OR D ;test by or'ING THE LENGTHS TOGETHER
	RET Z ;if so, return with a zero
	LD A,D ;get faclo string length
	SUB 1 ;set carry and make [a]=255 if [d]=0
	RET C ;return if that string ended
	XOR A ;must not have been zero, test case
	CP E ;of b,c,d,e string having ended first
	INC A ;return with a=1
	RET NC ;test the condition
;here when neither string ended
	DEC D ;decrement both character counts
	DEC E
	LD A,(BC) ;get character from b,c,d,e string
	INC BC
	CP (HL) ;compare with faclo string
	INC HL ;bump pointers (inx doesnt clobber cc'S)
	JP Z,csloop ;if both the same, must be more to strings
	CCF ;here when strings differ
	JP signs ;set [a] according to carry
	subttl	string functions
; the stro$ function takes a number and gives
; a string with the characters the number would give if
; output in octal
;
stro$:	CALL fouto ;put octal number in fbuffr
	JP str$1 ;jump into str$ code

; strh$ same as stro$ except uses hex instead of octal
strh$:	CALL fouth ;put hex number in fbuffr
	JP str$1 ;jump into str$ code
;
; the str$ function takes a number and gives
; a string with the characters the output of the number
; would have given
;
str$:
					;is a numeric
	CALL fout ;do its output
str$1:	CALL strlit ;scan it and turn it into a string
	CALL frefac ;free up the temp
	LD BC,finbck
	PUSH BC ;set up answer in new temp
;
; strcpy creates a copy of the string
; whose descriptor is pointed to by [h,l].
; on return [d,e] points to dsctmp
; which has the string info (length,where copied to)
;
strcpy:	LD A,(HL) ;get length
	INC HL ;move up to the pointer
	PUSH HL ;get pointer to pointer of arg
	CALL getspa ;get the space
	POP HL ;find out where string to copy
	LD C,(HL)
	INC HL
	LD B,(HL)
	CALL strad2 ;setup dsctmp
	PUSH HL ;save pointer to dsctmp
	LD L,A ;get character count into [l]
	CALL movstr ;move the chars in
	POP DE ;restore pointer to dsctmp
	RET ;return

strin1:	LD A,1 ;make one char string (chr$, inkey$)
strini:	CALL getspa ;get some string space ([a] chars)
strad2:	LD HL,dsctmp ;get desc. temp
strad1:	PUSH HL ;save desc. pointer
	LD (HL),A ;save character count
putdei:	INC HL ;store [d,e]=pointer to free space
	LD (HL),E
	INC HL
	LD (HL),D
	POP HL ;and restore [h,l] as the descriptor pointer
	RET
;
; strlt2 takes the string literal whose first character
; is pointed by [h,l]+1 and builds a descriptor for it.
; the descriptor is initially built in dsctmp, but putnew
; transfers it into a temporary and leaves a pointer
; at the temporary in faclo. the characters other than
; zero that terminate the string should be set up in [b]
; and [d]. it the terminator is a quote, the quote is skipped
; over. leading quotes should be skipped before call. on return
; the character after the string literal is pointed to
; by [h,l] and is in [a], but the condition codes are
; not set up.
;
strlit:	DEC HL
strlti:	LD B,34 ;assume str ends on quote
strlt3:	LD D,B
strlt2:	PUSH HL ;save pointer to start of literal
	LD C,255 ;initialize character count
strget:	INC HL
	LD A,(HL) ;get char
	INC C ;bump character count
	OR A ;if 0, (end of line) done
	JP Z,strfin ;test
	CP D
	JP Z,strfin
	CP B ;closing quote
	JP NZ,strget ;no, go back for more
strfin:	CP 34 ;if quote terminates the string
	CALL Z,chrgtr ;skip over the quote
	PUSH HL ;save pointer at end of string
	LD A,B ;were we scanning an unquoted string?
	CP 44
	JP NZ,nttrls ;if not, don'T SUPPRESS TRAILING SPACES
	INC C ;fix [c] which is the character count
lptrls:	DEC C ;decrement until we find a non-space character
	JP Z,nttrls ;don'T GO PAST START (ALL SPACES)
	DEC HL ;look at previous character
	LD A,(HL)
	CP ' '
	JP Z,lptrls ;if so continue looking
nttrls:	POP HL
	EX (SP),HL
	INC HL
	EX DE,HL ;get pointer to temp
	LD A,C ;get character count in a
	CALL strad2 ;save str info
;
; some string function is returning a result in dsctmp
; we want to setup a temp descriptor with dcstmp in it
; put a pointer to the descriptor in faclo and flag the 
; result as type string
;
putnew:	LD DE,dsctmp ;[d,e] point at result descriptor
	db	76q ;skip the next byte ("MVI AL,")
puttmp:	PUSH DE ;save a pointer to the start of the string
	LD HL,(temppt) ;[h,l]=pointer to first free temp
	LD (faclo),HL ;pointer at where result descriptor will be
	LD A,3
	LD (valtyp),A ;flag this as a string
	CALL vmove ;and move the value into a temporary
	LD DE,dsctmp+3 ;if the call is to puttmp, [d,e]
					;will not equal dsctmp +3
	CALL dcompr ;dsctmp is just beyond the temps
					;and if temppt points at it there
					;are no free temps
	LD (temppt),HL ;save new temporary pointer
	POP HL ;get the text pointer
	LD A,(HL) ;get current character into [a]
	RET NZ
	LD DE,0+errst ;"STRING TEMPORARY" error
	JP error ;go tell him
;
; print the string pointed to by [h,l] which ends with a zero
; if the string is below dsctmp it will be copied into string space
;
stroui:	INC HL ;point at next character
strout:	CALL strlit ;get a string literal
;
; print the string whose descriptor is pointed to by faclo.
;
strprt:	CALL frefac ;return temp pointer by faclo
	CALL getbcd ;[d]=length [b,c]=pointer at data
	INC D ;increment and decrement early
					;to check for null string
strpr2:	DEC D ;decrement the length
	RET Z ;all done
	LD A,(BC) ;get character to print
	CALL outdo
	CP 13
	CALL Z,crfin
	INC BC ;point to the next character
	JP strpr2 ;and print it...
	page
	subttl	string garbage collection - getspa, garbag
;
; getspa - get space for character string
; may force garbage collection.
;
; # of chars (bytes) in [a]
; returns with pointer in [d,e] otherwise if cant get space
; blows off to "OUT OF STRING SPACE" type error.
;
getspa:	OR A ;must be non zero. signal no garbag yet
	db	16q ;"MVI C" around the next byte 
trygi2:	POP AF ;in case collected what was length?
	PUSH AF ;save it back
	LD HL,(strend)
	EX DE,HL ;in [d,e]
	LD HL,(fretop) ;get top of free space in [h,l]
	CPL ;-# of chars
	LD C,A ;in [b,c]
	LD B,255
	ADD HL,BC ;subtract from top of free
	INC HL
	CALL dcompr ;compare the two
	JP C,garbag ;not enough room for string, offal time
	LD (fretop),HL ;save new bottom of memory
	INC HL ;move back to point to string
	EX DE,HL ;return with pointer in [d,e]
ppswrt:	POP AF ;get character count
	RET ;return from getspa

garbag:	POP AF ;have we collected before?
	LD DE,0+errso ;get ready for out of string space error
	JP Z,error ;go tell user he lost
	CP A ;set zero flag to say weve garbaged
	PUSH AF ;save flag back on stack
	LD BC,trygi2 ;place for garbag to return to.
	PUSH BC ;save on stack
garba2:	LD HL,(memsiz) ;start from top down
fndvar:	LD (fretop),HL ;like so
	LD HL,0 ;get double zero
	PUSH HL ;say didnt see vars this pass
	LD HL,(strend) ;force dvars to ignore strings
					;in the program text (literals, data)
	PUSH HL ;force find high address
	LD HL,tempst ;get start of string temps
tvar:	EX DE,HL ;save in [d,e]
	LD HL,(temppt) ;see if done
	EX DE,HL ;flip
	CALL dcompr ;test
					;cannot run in ram since it stores to mess up basic
	LD BC,tvar ;force jump to tvar
	JP NZ,dvar2 ;do temp var garbage collect

	LD HL,prmprv ;setup iteration for parameter blocks
	LD (temp9),HL
	LD HL,(arytab) ;get stopping point in [h,l]
	LD (aryta2),HL ;store in stop location
	LD HL,(vartab) ;get starting point in [h,l]

svar:	EX DE,HL
	LD HL,(aryta2) ;get stopping location
	EX DE,HL
	CALL dcompr ;see if at end of simps
	JP Z,aryvar
	LD A,(HL) ;get valtyp
	INC HL ;bump pointer twice
	INC HL ;
	INC HL ;point at the value
	PUSH AF ;save valtyp
	CALL iadahl ;and skip over extra characters and count
	POP AF
	CP 3 ;see if its a string
	JP NZ,skpvar ;if not, just skip around it
	CALL dvars ;collect it
	XOR A ;and don'T SKIP ANYTHING MORE
skpvar:	LD E,A
	LD D,0 ;[d,e]=amount to skip
	ADD HL,DE
	JP svar ;get next one
aryvar:	LD HL,(temp9) ;get link in parameter block chain
	LD E,(HL) ;5.21: load into DE instead of HL
	INC HL
	LD D,(HL)
	LD A,D ;5.21: test DE properly
	OR E ;was that the end?
	LD HL,(arytab) ;5.21: no xchg needed
	JP Z,aryva4 ;otherwise garbage collect arrays
	EX DE,HL
	LD (temp9),HL ;setup next link in chain for iteration
	INC HL ;skip chain pointer
	INC HL
	LD E,(HL) ;pick up the length
	INC HL
	LD D,(HL)
	INC HL
	EX DE,HL ;set [d,e]= actual end address by
	ADD HL,DE ;adding base to length
	LD (aryta2),HL ;set up stop location
	EX DE,HL
	JP svar

aryva2:	POP BC ;get rid of stack garbage
aryva4:	EX DE,HL ;save aryvar in [d,e]
	LD HL,(strend) ;get end of arrays
	EX DE,HL ;flip back
	CALL dcompr ;see if done with arrays
	JP Z,grbpas ;yes, see if done collecting
	LD A,(HL) ;get the value type into [a]
	INC HL
	PUSH AF ;save the valtyp
	INC HL ;skip the name characters
	INC HL
	CALL iadahl ;skip the extra characters
	LD C,(HL) ;pick up the length
	INC HL
	LD B,(HL)
	INC HL
	POP AF ;restore the valtyp
	PUSH HL ;save pointer to dims
	ADD HL,BC ;add to current pointer position
	CP 3 ;see if its a string
	JP NZ,aryva2 ;if not just skip it
	LD (temp8),HL ;save end of array
	POP HL ;get back current position
	LD C,(HL) ;pick up number of dims
	LD B,0 ;make double with high zero
	ADD HL,BC ;go past dims
	ADD HL,BC ;by adding on twice #dims (2 byte guys)
	INC HL ;one more to account for #dims.
arystr:	EX DE,HL ;save current posit in [d,e]
	LD HL,(temp8) ;get end of array
	EX DE,HL ;fix [h,l] back to current
	CALL dcompr ;see if at end of array
	JP Z,aryva4 ;end of array, try next array
	LD BC,arystr ;addr of where to return to
dvar2:	PUSH BC ;goes on stack
dvar:
dvars:	XOR A
	OR (HL) ;see if its the null string
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL)
	INC HL ;[d,e]=pointer at the value
	RET Z ;null string, return
	LD B,H ;move [h,l] to [b,c]
	LD C,L
	LD HL,(fretop) ;get pointer to top of string free space
	CALL dcompr ;is this strings pointer .lt. fretop
	LD H,B ;move [b,c] back to [h,l]
	LD L,C
	RET C ;if not, no need to mess with it furthur
	POP HL ;get return address off stack
	EX (SP),HL ;get max seen so far & save return address
	CALL dcompr ;lets see
	EX (SP),HL ;save max seen & get return address off stack
	PUSH HL ;save return address back
	LD H,B ;move [b,c] back to [h,l]
	LD L,C
	RET NC ;if not, lets look at next var
	POP BC ;get return addr off stack
	POP AF ;pop off max seen
	POP AF ;and variable pointer
	PUSH HL ;save new variable pointer
	PUSH DE ;and new max pointer
	PUSH BC ;save return address back
	RET ;and return
;
; here when made one complete pass thru string vars
;
grbpas:	POP DE ;pop off max pointer
	POP HL ;and get variable pointer
	LD A,H ;5.21: get high byte first
	OR L ;see if zero pointer
	RET Z ;if end of collection,
					;then maybe return to getspa
	DEC HL ;currently just past the descriptor
	LD B,(HL) ;[b]=high byte of data pointer
	DEC HL
	LD C,(HL) ;[b,c]=pointer at string data
	PUSH HL ;save this location so the pointer
					;can be updated after the string is
					;moved
	DEC HL
	LD L,(HL) ;[l]=string length
	LD H,0 ;[h,l] get character count
	ADD HL,BC ;[h,l]=pointer beyond string
	LD D,B
	LD E,C ;[d,e]=original pointer
	DEC HL ;don'T MOVE ONE BEYOND STRING
	LD B,H ;get top of string in [b,c]
	LD C,L
	LD HL,(fretop) ;get top of free space
	CALL bltuc ;move string
	POP HL ;get back pointer to desc.
	LD (HL),C ;save fixed addr
	INC HL ;move pointer
	LD (HL),B ;high part
	LD H,B ;5.21: high first
	LD L,C ;[h,l]=new pointer
	DEC HL ;fix up fretop
	JP fndvar ;and try to find high again

	page
	subttl	string concatenation
;
; the following routine concatenates two strings
; the faclo contains the first one at this point,
; [h,l] points beyond the + sign after it
;
cat:	PUSH BC ;put old precedence back on
	PUSH HL ;save text pointer
	LD HL,(faclo) ;get pointer to string desc.
	EX (SP),HL ;save on stack & get text pointer back
	CALL eval ;evaluate rest of formula
	EX (SP),HL ;save text pointer, get back desc.
	CALL chkstr
	LD A,(HL)
	PUSH HL ;save desc. pointer.
	LD HL,(faclo) ;get pointer to 2nd desc.
	PUSH HL ;save it
	ADD (HL) ;add two lengths together
	LD DE,0+errls ;see if result .lt. 256
	JP C,error ;error "LONG STRING"
	CALL strini ;get initial string
	POP DE ;get 2nd desc.
	CALL fretmp
	EX (SP),HL ;save pointer to it
	CALL fretm2 ;free up 1st temp
	PUSH HL ;save desc. pointer (first)
incstr	set	2

incstr	set	1
	LD HL,(dsctmp+incstr) ;get pointer to first
	EX DE,HL ;in [d,e]
	CALL movins ;move in the first string
	CALL movins ;and the second
	LD HL,tstop ;cat reenters formula evaluation at tstop
	EX (SP),HL
	PUSH HL ;text pointer off first
	JP putnew ;then return address of tstop


movins:	POP HL ;get return addr
	EX (SP),HL ;put back, but get desc.
	LD A,(HL) ;[a]=string length
	INC HL
	LD C,(HL) ;[b,c]=pointer at string data
	INC HL
	LD B,(HL)
	LD L,A ;[l]=string length
movstr:	INC L
movlp:	DEC L ;set cc'S
	RET Z ;0, no byte to move
	LD A,(BC) ;get char
	LD (DE),A ;save it
	INC BC ;move pointers
	INC DE
	JP movlp ;keep doing it
	page
	subttl	free up string temporary - frestr, frefac, fretmp, fretms
;
; fretmp is passed a pointer to a string descriptor in [d,e]
; this value is returned in [h,l]. all the other registers are modified.
; a check to is made to see if the string descriptor [d,e] points
; to is the last temporary descriptor allocated by putnew.
; if so, the temporary is freed up by the updating of temppt.
; if a temporary is freed up, a further check is made to see if the
; string data that that string temporary pointed to is the
; the lowest part of string space in use.
; if so, fretmp is updated to reflect the fact that that space is no
; longer in use.
;
frestr:	CALL chkstr ;make sure its a string
frefac:	LD HL,(faclo)
fretm2:	EX DE,HL ;free up the temp in the faclo
fretmp:	CALL fretms ;free up the temporary
	EX DE,HL ;put the string pointer into [h,l]
	RET NZ
	PUSH DE ;save [d,e] to return in [h,l]
	LD D,B ;[d,e]=pointer at string
	LD E,C
	DEC DE ;subtract one
	LD C,(HL) ;[c]=length of the string freed up
	LD HL,(fretop) ;see if its the first 
					;one in string space
	CALL dcompr
	JP NZ,notlst ;no so don'T ADD
	LD B,A ;make [b]=0
	ADD HL,BC ;add
	LD (fretop),HL ;and update fretop
notlst:	POP HL ;get pointer at current descriptor
	RET
fretms:	LD HL,(temppt) ;get temp pointer
	DEC HL ;look at what is in the last temp
	LD B,(HL) ;[b,c]=pointer at string
	DEC HL ;decrement temppt by strsiz
	LD C,(HL)
	DEC HL
	CALL dcompr ;see if [d,e] point at the last 
	RET NZ ;return now if now freeing done
	LD (temppt),HL ;update the temp pointer since
					;its been decremented by 4
	RET
	page
	subttl	string functions - len, asc, chr$
;
; the function len($) returns the length of the
; string passed as an argument
;
len:	LD BC,sngflt ;call sngflt when done
	PUSH BC ;like so
len1:	CALL frestr ;free up temp pointed to by faclo
	XOR A ;force numeric flag
	LD D,A ;set high of [d,e] to zero for val
	LD A,(HL)
	OR A ;set condition codes on length
	RET ;return
;
; the following is the asc($) function. it returns an integer
; which is the decimal ascii equivalent
;
asc:
	LD BC,sngflt ;where to go when done
	PUSH BC ;save return addr on stack
asc2:	CALL len1 ;set up original str
	JP Z,fcerr ;null str, bad arg.
	INC HL ;bump pointer
	LD E,(HL) ;[d,e]=pointer at string data
	INC HL
	LD D,(HL)
	LD A,(DE) ;[a]=first character
	RET
;
; chr$(#) creates a string which contains as its only
; character the ascii equivalent of the integer arg (#)
; which must be .le. 255.
;
chr$:	CALL strin1 ;get string in dsctmp
	CALL conint ;get integer in range
incstr	set	2

incstr	set	1
setstr:	LD HL,(dsctmp+incstr) ;get addr of str
	LD (HL),E ;save ascii byte
finbck:	POP BC ;return to higher level &
					;skip the chknum call.
	JP putnew ;go call putnew

strng$:	CALL chrgtr ;get next char following "STRING$"
	CALL synchr
	db	'(' ;make sure left paren
	CALL getbyt ;evaluate first arg (length)
	PUSH DE ;save it
	CALL synchr
	db	54o ;comma
	CALL frmevl ;get formula arg 2
	CALL synchr
	db	')' ;expect right paren
	EX (SP),HL ;save text pointer on stack, get rep factor
	PUSH HL ;save back rep factor
	CALL getypr ;get type of arg
	JP Z,strstr ;was a string
	CALL conint ;get ascii value of char
	JP calspa ;now call space code
strstr:	CALL asc2 ;get value of char in [a]
calspa:	POP DE ;get rep factor in [e]
	CALL space2 ;into space code, put dummy entry
					;on stack popped off by finbck
space$:	CALL conint ;get number of chars in [e]
	LD A,32 ;get space char
space2:	PUSH AF ;save char
	LD A,E ;get number of chars in [a]
	CALL strini ;get a string that long
	LD B,A ;count of chars back in [b]
	POP AF ;get back char to put in string
	INC B ;test for null string
	DEC B
	JP Z,finbck ;yes, all done
	LD HL,(dsctmp+incstr) ;get desc. pointer
splp$:	LD (HL),A ;save char
	INC HL ;bump ptr
					;decr count
	DEC B
	JP NZ,splp$ ;keep storing char
	JP finbck ;put temp desc when done
	page
	subttl	string functions - left$, right$, mid$
;
; the following is the left$($,#) function.
; it takes the leftmost # chars of the str.
; if # is .gt. than the len of the str, it returns the whole str.
;
left$:	CALL pream ;test the parameters
	XOR A ;left never changes string pointer
left3:	EX (SP),HL ;save text pointer
	LD C,A ;offset now in [c]
	db	76q ;skip the next byte with "MVI A,"
;
; this is print usings entry point into left$
;
leftus:	PUSH HL ;this is a dummy push to offset
					;the extra pop in putnew
left2:	PUSH HL ;save desc. for  fretmp
	LD A,(HL) ;get string length
	CP B ;entire string wanted?
	JP C,allstr ;if #chars asked for.ge.length,yes
	LD A,B ;get truncated length of string
	db	21q ;skip over mvi using "LXI D,"
allstr:	LD C,0 ;make offset zero
	PUSH BC ;save offset on stack
	CALL getspa ;get space for new string
	POP BC ;get back offset
	POP HL ;get back desc pointer.
	PUSH HL ;but keep on stack
	INC HL ;move to string pointer field
	LD B,(HL) ;get pointer low
	INC HL ;
	LD H,(HL) ;pointer high
	LD L,B ;get low in  l
	LD B,0 ;get ready to add offset to pointer
	ADD HL,BC ;add  it
	LD B,H ;get offset pointer in [b,c]
	LD C,L
	CALL strad2 ;save info in dsctmp
	LD L,A ;get#  of chars to  move in l
	CALL movstr ;move them in
	POP DE ;get back desc. pointer
	CALL fretmp ;free it up.
	JP putnew ;put temp in temp list

right$:	CALL pream ;check arg
	POP DE ;get desc. pointer
	PUSH DE ;save back for left
	LD A,(DE) ;get present len of str
	SUB B ;subtract 2nd parm
	JP left3 ;continue with left code
;
; mid ($,#) returns str with chars from # position
; onward. if # is gt len($) then return null string.
; mid ($,#,#) returns str with chars from # position
; for #2 chars. if #2 goes past end of string, return
; as much as possible.
;
mid$:	EX DE,HL ;put the text pointer in [h,l]
	LD A,(HL) ;get the first character
	CALL pream2 ;get offset off stack and make
	INC B
	DEC B ;see if equal to zero
	JP Z,fcerr ;it must not be 0
					;sure does not = 0.
	PUSH BC ;put offset on to the stack
	CALL midrst ;duplicate of code conditioned out
					;below
	POP AF ;get offset back in a
	EX (SP),HL ;save text pointer, get desc.
	LD BC,left2 ;where to return to.
	PUSH BC ;goes on stack
	DEC A ;sub one from offset
	CP (HL) ;pointer past end of str?
	LD B,0 ;assume null length str
	RET NC ;yes, just use null str
	LD C,A ;save offset of character pointer
	LD A,(HL) ;get present len of str
	SUB C ;subtract index (2nd arg)
	CP E ;is it truncation
	LD B,A ;get calced length in b
	RET C ;if not use partial str
	LD B,E ;use truncated length
	RET ;return to left2
;
; the val function takes a string and turn it into
; a number by interpreting the ascii digits. etc..
; except for the problem that a terminator must be supplied
; by replacing the character beyond the string, val
; is merely a call to floating input (fin).
;
val:	CALL len1 ;do setup, set result=real
	JP Z,sngflt ;make sure type set up ok in extended
	LD E,A ;get length of str
	INC HL ;to handle the fact the if
	LD A,(HL)
	INC HL
	LD H,(HL) ;two strings "1" and "2"
	LD L,A ;are stored next to each other
	PUSH HL ;and fin is called pointing to
	ADD HL,DE ;the first twelve will be returned
	LD B,(HL) ;the idea is to store 0 in the
	LD (HL),D ;string beyond the one val
	EX (SP),HL ;is being called on
	PUSH BC ;the first character of the next string
	DEC HL ;***call chrget to make sure
	CALL chrgtr ;val(" -3")=-3
	CALL findbl ;in extended, get all the precision we can
	POP BC ;get the modified character of the next
					;string into [b]
	POP HL ;get the pointer to the modified character
	LD (HL),B ;restore the character
					;if string is highest in string space
					;we are modifying [memsiz] and
					;this is why [memsiz] can'T BE USED TO STORE
					;string data because what if the
					;user took val off that high string
	RET
;used by right$ and left$ for parameter checking and setup
pream:	EX DE,HL ;put the text pointer in [h,l]
	CALL synchr
	db	')' ;param list should end
;used by mid$ for parameter checking and setup
pream2:	POP BC ;get return addr off stack
	POP DE ;get length of arg off stack
	PUSH BC ;save return addr back on
	LD B,E ;save init length
	RET

	page
	subttl	string functions - instr

; this is the instr fucntion. it takes one of two
; forms: instr(i%,s1$,s2$) or instr(s1$,s2$)
; in the first form the string s1$ is searched for the
; character s2$ starting at character position i%.
; the second form is identical, except that the search
; starts at position 1. instr returns the character
; position of the first occurance of s2$ in s1$.
; if s1$ is null, 0 is returned. if s2$ is null, then
; i% is returned, unless i% .gt. len(s1$) in which
; case 0 is returned.

instr:	CALL chrgtr ;eat first char
	CALL frmprn ;evaluate first arg
	CALL getypr ;set zero if arg a string.
	LD A,1 ;if so, assume, search starts at first char
	PUSH AF ;save offset in case string
	JP Z,wuzstr ;was a string
	POP AF ;get rid of saved offset
	CALL conint ;force arg1 (i%) to be integer
	OR A ;dont allow zero offset
	JP Z,fcerr ;kill him.
	PUSH AF ;save for later
	CALL synchr
	db	44 ;eat the comma
	CALL frmevl ;eat first string arg
	CALL chkstr ;blow up if not string
wuzstr:	CALL synchr
	db	44 ;eat comma after arg
	PUSH HL ;save the text pointer
	LD HL,(faclo) ;get descriptor pointer
	EX (SP),HL ;put on stack & get back text pnt.
	CALL frmevl ;get last arg
	CALL synchr
	db	')' ;eat right paren
	PUSH HL ;save text pointer
	CALL frestr ;free up temp & check string
	EX DE,HL ;save 2nd desc. pointer in [d,e]
	POP BC ;get text pointer in b
	POP HL ;desc. pointer for s1$
	POP AF ;offset
	PUSH BC ;put text pointer on bottom
	LD BC,pophrt ;put address of pop h, ret on
	PUSH BC ;push it
	LD BC,sngflt ;now address of [a] returner
	PUSH BC ;onto stack
	PUSH AF ;save offset back
	PUSH DE ;save desc. of s2
	CALL fretm2 ;free up s1 desc.
	POP DE ;restore desc. s2
	POP AF ;get back offset
	LD B,A ;save unmodified offset
	DEC A ;make offset ok
	LD C,A ;save in c
	CP (HL) ;is it beyond length of s1?
	LD A,0 ;if so, return zero. (error)
	RET NC
	LD A,(DE) ;get length of s2$
	OR A ;null??
	LD A,B ;get offset back
	RET Z ;all if s2 null, return offset
	LD A,(HL) ;get length of s1$
	INC HL ;bump pointer
	LD B,(HL) ;get 1st byte of address
	INC HL ;bump pointer
	LD H,(HL) ;get 2nd byte
	LD L,B ;get 1st byte set up
	LD B,0 ;get ready for dad
	ADD HL,BC ;now indexing into string
	SUB C ;make length of string s1$ right
	LD B,A ;save length of 1st string in [b]
	PUSH BC ;save counter, offset
	PUSH DE ;put 2nd desc (s2$) on stack
	EX (SP),HL ;get 2nd desc. pointer
	LD C,(HL) ;set up length
	INC HL ;bump pointer
	LD E,(HL) ;get first byte of address
	INC HL ;bump pointer again
	LD D,(HL) ;get 2nd byte
	POP HL ;restore pointer for 1st string

chk1:	PUSH HL ;save position in search string
	PUSH DE ;save start of substring
	PUSH BC ;save where we started search
chk:	LD A,(DE) ;get char from substring
	CP (HL) ; = char pointer to by [h,l]
	JP NZ,ohwell ;no
	INC DE ;bump compare pointer
	DEC C ;end of search string?
	JP Z,gotstr ;we found it!
	INC HL ;bump pointer into string being searched
					;decrement length of search string
	DEC B
	JP NZ,chk ;end of string, you lose
retzer:	POP DE ;get rid of pointers
	POP DE ;get rid of garb
	POP BC ;like so
retzr1:	POP DE
	XOR A ;go to sngflt.
	RET ;return

gotstr:	POP HL
	POP DE ;get rid of garb
	POP DE ;get rid of excess stack
	POP BC ;get counter, offset
	LD A,B ;get original source counter
	SUB H ;subtract final counter
	ADD C ;add original offset (n1%)
	INC A ;make offset of zero = posit 1
	RET ;done


ohwell:	POP BC
	POP DE ;point to start of substring
	POP HL ;get back where we started to compare
	INC HL ;and point to next char
					;decr. # char left in source string
	DEC B
	JP NZ,chk1 ;try searching some more
	JP retzr1 ;end of string, return 0

	page
	subttl	string functions - left hand side mid$
lhsmid:	CALL synchr
	db	'(' ;must have ( 
	CALL ptrget ;get a string var
	CALL chkstr ;make sure it was a string
	PUSH HL ;save text pointer
	PUSH DE ;save desc. pointer
	EX DE,HL ;put desc. pointer in [h,l]
	INC HL ;move to address field
	LD E,(HL) ;get address of lhs in [d,e]
	INC HL ;bump desc. pointer
	LD D,(HL) ;pick up high byte of address
	LD HL,(strend) ;see if lhs string is in string space
	CALL dcompr ;by comparing it with stktop
	JP C,ncpmid ;if already in string space
					;dont copy.

					;9/23/79 allow mid$ on field strings
	LD HL,(txttab)
	CALL dcompr ;is this a fielded string?
	JP NC,ncpmid ;yes, don't copy!!
	POP HL ;get back desc. pointer
	PUSH HL ;save back on stack
	CALL strcpy ;copy the string literal into string space
	POP HL ;get back desc. pointer
	PUSH HL ;back on stack again
	CALL vmove ;move new desc. into old slot.
ncpmid:	POP HL ;get desc. pointer
	EX (SP),HL ;get text pointer to [h,l] desc. to stack
	CALL synchr
	db	54o ;must have comma
	CALL getbyt ;get arg#2 (offset into string)
	OR A ;make sure not zero
	JP Z,fcerr ;blow him up if zero
	PUSH AF ;save arg#2 on stack
	LD A,(HL) ;restore current char
	CALL midrst ;use mid$ code to evaluate posible third arg.
	PUSH DE ;save third arg ([e]) on stack
					;must have = sign
	CALL frmeql ;evaluate rhs of thing.
	PUSH HL ;save text pointer.
	CALL frestr ;free up temp rhs if any.
	EX DE,HL ;put rhs desc. pointer in [d,e]
	POP HL ;text pointer to [h,l]
	POP BC ;arg #3 to c.
	POP AF ;arg #2 to a.
	LD B,A ;and [b]
	EX (SP),HL ;get lhs desc. pointer to [h,l]
					;text pointer to stack
	PUSH HL ;save text pointer
	LD HL,pophrt ;get addr to return to
	EX (SP),HL ;save on stack & get back txt ptr.
	LD A,C ;get arg #3
	OR A ;set cc'S
	RET Z ;if zero, do nothing
	LD A,(HL) ;get length of lhs
	SUB B ;see how many chars in emainder of string
	JP C,fcerr ;cant assign past len(lhs)!
	INC A ;make proper count
	CP C ;see if # of chars is .gt. third arg
	JP C,biglen ;if so, dont truncate
	LD A,C ;truncate by using 3rd arg.
biglen:	LD C,B ;get offset of string in [c]
	DEC C ;make proper offset
	LD B,0 ;set up [b,c] for later dad b.
	PUSH DE ;save [d,e]
	INC HL ;pointer to address field.
	LD E,(HL) ;get low byte in [e]
	INC HL ;bump pointer
	LD H,(HL) ;get high byte in [h]
	LD L,E ;now copy low byte back to [l]
	ADD HL,BC ;add offset
	LD B,A ;set count of lhs in [b]
	POP DE ;restore [d,e]
	EX DE,HL ;move rhs. desc. pointer to [h,l]
	LD C,(HL) ;get len(rhs) in [c]
	INC HL ;move pointer
	LD A,(HL) ;get low byte of address in [a]
	INC HL ;bump pointer.
	LD H,(HL) ;get high byte of address in [h]
	LD L,A ;copy low byte to [l]
	EX DE,HL ;address of rhs now in [d,e]
	LD A,C ;is rhs null?
	OR A ;test
	RET Z ;then all done.
; now all set up for assignment.
; [h,l] = lhs pointer
; [d,e] = rhs pointer
; c = len(rhs)
; b = len(lhs)

mid$lp:	LD A,(DE) ;get byte from rhs.
	LD (HL),A ;store in lhs
	INC DE ;bump rhs pointer
	INC HL ;bump lhs pointer.
	DEC C ;bump down count of rhs.
	RET Z ;if zero, all done.
					;if lhs ended, also done.
	DEC B
	JP NZ,mid$lp ;if not done, more copying.
	RET ;back to newstt

midrst:	LD E,255 ;if two arg guy, truncate.
	CP ')'
	JP Z,mid2 ;[e] says use all chars
					;if one argument this is correct
	CALL synchr
	db	44 ;comma? must delineate 3rd arg.
	CALL getbyt ;get argument  in  [e]
mid2:	CALL synchr
	db	')' ;must be followed by )
	RET ;all done.

	subttl	fre  function and integer to floating  routines
fre:
	CALL getypr
	JP NZ,clcdif
	CALL frefac ;free up argument and setup
					;to give free string space
	CALL garba2 ;do garbage collection
clcdif:	EX DE,HL ;5.21: swap first
	LD HL,(strend)
	EX DE,HL
	LD HL,(fretop) ;top of free area
	JP givdbl ;return [h,l]-[d,e]

;======================================================================
; Module: binlin.mac
;======================================================================

	page
	title	inlin basic interpreter input line routine/whg/pga/mbm, etc.
	subttl	inlin - line input routine


; this is the line input routine
; it reads characters into buf using _ as the
; character delete character and @ as the line delete character
; if more than buflen character are typed, no echoing
; is done until a  _ @ or carriage-return is typed.
; control-g will be typed for each extra character.
; the routine is entered at inlin, at qinlin to type a question mark
; and a space first

qinlin:	LD A,'?' ;get a qmark
	CALL outdo ;type it
	LD A,' ' ;space
	CALL outdo ;type it too
	JP inlin ;no crunching in this case
inlinc:	CALL inchr ;get a char
	CP 1 ;control a?
	JP NZ,inlnc1 ;no, treat normally
	LD (HL),0 ;save terminator
	JP inled1 ;go edit from here

inlinq:	LD (HL),B ;store zero in buf
inlin:
	XOR A ;clear type ahead char
	LD (charc),A ;like so
	XOR A
	LD (tempa),A ;flag to do cr
sinlin:
					;save current cursor address (ttypos)
	CALL inchr ;get char
	CP 1 ;control-a?
	JP NZ,inlins ;go do it
inled1:
	CALL crdo ;type crlf
	LD HL,0+65535 ;get special line #
	JP inled ;go to edit code.
					;get char
rubout:
	LD A,(rubsw) ;are we already rubbing out?
	OR A ;set cc'S
	LD A,'\' ;get ready to type backslash
	LD (rubsw),A ;make rubsw non-zero if not already
	JP NZ,notbeg ;not rubbing back to beggining
	DEC B ;at beginning of line?
	JP Z,inlinq ;set first byte in buf to zero
	CALL outdo ;send backslash
	INC B ;effectively skip next instruction
notbeg:	DEC B ;back up char count by 1
	DEC HL ;and line posit
	JP Z,inlinn ;and re-set up input
	LD A,(HL) ;otherwise get char to echo
	CALL outdo ;send it
	JP inlinc ;and get next char

linlin:	DEC B ;back arrow so decrement count
linln2:	DEC HL ;back up pointer
	CALL outdo
	JP NZ,inlinc ;not too many so continue
inlinn:	CALL outdo ;print the @, or a second _ if there
					;were too many
inlinu:	CALL crdo ;type a crlf
inlins:	LD HL,buf
	LD B,1 ;character count
	PUSH AF
	XOR A ;always clear rubout switch
	LD (rubsw),A ;by storing in
	POP AF
inlnc1:
	LD C,A ;save current char in [c]
	CP 177o ;character delete?
	JP Z,rubout ;do it
	LD A,(rubsw) ;been doing a rubout?
	OR A ;set cc'S
	JP Z,notrub ;nope.
	LD A,'\' ;get ready to type slash
	CALL outdo ;send it
	XOR A ;clear rubsw
	LD (rubsw),A ;like so.
notrub:	LD A,C ;get back current char
	CP 7 ;is it bob albrecht ringing the bell
	JP Z,goodch ;for school kids?
	CP 3 ;control-c?

	CALL Z,ctrlpt ;type ^ followed by char, and crlf
	SCF ;return with carry on
	RET Z ;if it was control-c
	CP 13 ;is it a carriage return?
	JP Z,gfninl
	CP 9 ;tab?
	JP Z,goodch ;save it
	CP 10 ;lf?
	JP NZ,chkfun ;no, see if funny char
	DEC B ;see if only char on line
	JP Z,inlin ;it is, ignore
	INC B ;restore b
	JP goodch ;is lf and not null line
chkfun:
	CP 'U'-100o ;line delete? (control-u)
	CALL Z,ctrlpt ;print ^u
	JP Z,inlin
	CP 8 ;backspace? (control-h)?
	JP NZ,ntbksp ;no
drbksp:	DEC B ;at start of line?
	JP Z,sinlin
	CALL outdo ;send backspace
	LD A,' ' ;send space to wipe out char
	CALL outdo
	LD A,8 ;send another backspace
	JP linln2
ntbksp:
	CP 24 ;is it control-x (line delete)
	JP NZ,ntctlx ;no
	LD A,'#' ;send number sign
	JP inlinn ;send # sign and echo
ntctlx:
	CP 18 ;control-r?
	JP NZ,ntctlr ;no
	PUSH BC ;save [b,c]
	PUSH DE ;save [d,e]
	PUSH HL ;save [h,l]
	LD (HL),0 ;store terminator
	CALL crdo ;do crlf
	LD HL,buf ;point to start of buffer
	CALL lisprt ;handle line-feeds properly
	POP HL ;restore [h,l]
	POP DE ;restore [d,e]
	POP BC ;restore [b,c]
	JP inlinc ;get next char
ntctlr:
	CP 32 ;check for funny characters
	JP C,inlinc
					;philips must echo controls
goodch:	LD A,B ;get current length
					;*** special check if buffer 255 long for len2
	OR A ;5.21: test if non-zero
	JP NZ,outbnd ;no cause for bell
	PUSH HL ;save [h,l]
	LD HL,(ptrfil) ;see if reading from disk
	LD A,H ;by testing for ptrfil
	OR L ;non-zero
	POP HL ;restore [h,l]
	LD A,7 ;get bell char
	JP Z,outbel ;not reading from disk, send bell
	LD HL,buf ;make [h,l] point to buff
	CALL linget ;get line number
	EX DE,HL ;get line # in [h,l]
	LD (curlin),HL ;save in current line #
	JP lboerr ;give line buffer overflow error
outbnd:
	LD A,C ;restore  current character into [a]
	LD (HL),C ;store this character
	INC HL ;bump pointer into buf
	INC B ;increment character count
outbel:
	CALL outdo ;send the char
					;send char
	SUB 10 ;lf??
	JP NZ,inlinc ;no, get next char
	LD (ttypos),A ;make sure ttypos=0.
					;make sure ttypos=0
	LD A,13 ;send cr.
	CALL outdo ;by calling outchr
eatnul:	CALL inchr ;eat next char
	OR A ;null after lf?
	JP Z,eatnul ;dont let it get by
	CP 13 ;a carriage return??
	JP Z,inlinc ;eat it & get next char
	JP inlnc1 ;use it
					;must echo the char
	page
gfninl:
	LD A,(tempa) ;do cr or not?
	OR A ;test
	JP Z,fininl ;yes
	XOR A ;make zero
	LD (HL),A ;store terminator
	LD HL,bufmin ;get pointer to start of buf
	RET ;done

scnsem:	PUSH AF ;save char
	LD A,0 ;assume no semi
	LD (tempa),A
	POP AF ;get back char
	CP ';' ;is it a semi?
	RET NZ ;no
	LD (tempa),A ;flag no cr from inlin
	JP chrgtr

;======================================================================
; Module: fiveo.mac
;======================================================================

	page
	title	fiveo 5.0 features -while/wend, call, chain, write /p. allen
	.sall
	page
	subttl	while, wend
;
; this code handles the statements while/wend
; the 8080 stack is used to put an entry on for each active while
; the same way active gosub and for entries are made.
; the format is as follows:
;	$while - the token identifying the entry (1 byte)
;	a text pointer at the character after the wend of the while body (2 bytes)
;	a text pointer at the character after the while of the while body (2 bytes)
;	the line number of the line that the while is on (2 bytes)
;
;	total	7 bytes
;
while:	LD (endfor),HL ;keep the while text pointer here
	CALL wndscn ;scan for the matching wend
					;cause an errwh if no wend to match
	CALL chrgtr ;point at charactwer after wend
	EX DE,HL ;[d,e]= position of matching wend
	CALL fndwnd ;see if there is a stack entry for this while
	INC SP ;get rid of the newstt address on the stack
	INC SP
	JP NZ,wnotol ;if no match no need to truncate the stack
	ADD HL,BC ;eliminate everything up to and including
					;the matching while entry
	LD SP,HL
	LD (savstk),HL
wnotol:	LD HL,(curlin) ;make the stack entry
	PUSH HL
	LD HL,(endfor) ;get text pointer for while back
	PUSH HL
	PUSH DE ;save the wend text pointer
	JP fnwend ;finish using wend code

wend:	JP NZ,snerr ;statement has no arguments
	EX DE,HL ;find matching while entry on stack
	CALL fndwnd
	JP NZ,weerr ;must match or else error
	LD SP,HL ;truncate stack at match point
	LD (savstk),HL
	EX DE,HL ;save [h,l] pointing into stack entry
	LD HL,(curlin) ;remember wend line #
	EX DE,HL ;5.21: redundant swap pair
	EX DE,HL ;5.21: swap back
	LD (nxtlin),HL ;in nxtlin
	EX DE,HL
	INC HL ;index into stack entry to get values
	INC HL ;skip over text pointer of wend
	LD E,(HL) ;set [d,e]=text pointer of while
	INC HL
	LD D,(HL)
	INC HL
	LD A,(HL) ;[h,l]=line number of while
	INC HL
	LD H,(HL)
	LD L,A
	LD (curlin),HL ;in case of error or continuation fix curlin
	EX DE,HL ;get text pointer of while formula into [h,l]
fnwend:	CALL frmevl ;evaluate formula
	PUSH HL ;save text pointer
	CALL vsign ;get if true or false
	POP HL ;get back while text pointer
	JP Z,flswhl ;go back at wend if false
	LD BC,0+$while ;complete while entry
	LD B,C ;need it in the high byte
	PUSH BC
	INC SP ;only use one byte
	JP newstt

flswhl:	LD HL,(nxtlin) ;setup curlin for wend
	LD (curlin),HL
	POP HL ;take off text of wend as new text pointer
	POP BC ;5.21: get rid of text pointer of while
	POP BC ;5.21: take off line number of while
	JP newstt
;
; this subroutine searches the stack for an while entry
; whose wend text pointer matches [d,e]. it returns with zero true
; if a match is found and zero false otherwise. for entries
; are skipped over, but gosub entries are not.
;
whlsiz	set	6
fndwnd:	LD HL,0+4 ;skip over return address and newstt
	ADD HL,SP
fndwn2:
	LD A,(HL) ;get the entry type
	INC HL
	LD BC,0+$for
	CP C ;see if its $for
	JP NZ,fndwn3
	LD BC,forszc
	ADD HL,BC
	JP fndwn2
fndwn3:	LD BC,0+$while
	CP C
	RET NZ
	PUSH HL
	LD A,(HL) ;5.21: pick up the wend text pointer into A
	INC HL
	LD H,(HL) ;5.21: high byte into H
	LD L,A ;5.21: low byte into L
	CALL dcompr
	POP HL
	LD BC,0+whlsiz
	RET Z ;return if entry matches
	ADD HL,BC
	JP fndwn2

weerr:	LD DE,0+errwe
	JP error
	page
	subttl	call statement
; this is the call <simple var>[(<simple var>[,<simple var>]..)]
; stragegy:
;
; 1.) make sure suboutine name is simple var, get value & save it
;
; 2.) allocate space on stack for param adresses
;
; 3.) evaluate params & stuff pointers on stack
;
; 3.) pop off pointers ala calling convention
;
; 4.) call suboutine with return address on stack
maxprm	set	32 ;max # of params to assembly language subroutine
calls:
	LD A,200o ;flag ptrget not to allow arrays
	LD (subflg),A
	CALL ptrget ;evaluate var pointer
	PUSH HL ;save text pointer
	EX DE,HL ;var pointer to [h,l]
	CALL getypr ;get type of var
	CALL vmovfm ;store value in fac
	CALL frqint ;5.21: changed from frcint to frqint
	LD (tempa),HL ;save it
	LD C,maxprm ;check to see if we have space for max parm block
	CALL getstk
	POP DE ;get text pointer off stack
	LD HL,0-2*maxprm ;get space on stack for parms
	ADD HL,SP
	LD SP,HL ;adjust stack
	EX DE,HL ;put text pointer in [h,l], stack pointer in [d,e]
	LD C,maxprm ;get # of params again
	DEC HL ;back up text pointer
	CALL chrgtr ;get char
	LD (temp),HL ;save text pointer
	JP Z,callst ;if end of line, go!
	CALL synchr
	db	'(' ;eat left paren
getpar:	PUSH BC ;save count
	PUSH DE ;save pointer into stack
	CALL ptrget ;evaluate param address
	EX (SP),HL ;save text pointer get pointer into stack
	LD (HL),E ;save var address on stack
	INC HL
	LD (HL),D
	INC HL
	EX (SP),HL ;save back var pointer, get text pointer
	POP DE
	POP BC
	LD A,(HL) ;look at terminator
	CP 54o ;comma?
	JP NZ,endpar ;test
	DEC C ;decrement count of params
	CALL chrgtr ;get next char
	JP getpar ;back for more
endpar:	CALL synchr
	db	')' ;should have left paren
	LD (temp),HL ;save text pointer
	LD A,maxprm+1 ;calc # of params
	SUB C
	POP HL ;at least one, get its address in [h,l]
	DEC A ;was it one?
	JP Z,callst ;yes
	POP DE ;next address in [d,e]
	DEC A ;two?
	JP Z,callst ;yes
	POP BC ;final in [b,c]
	DEC A ;three?
	JP Z,callst ;yes
	PUSH BC ;save back third parm
	PUSH HL ;save back first
	LD HL,0+2 ;point to rest of parm list
	ADD HL,SP
	LD B,H ;get into [b,c]
	LD C,L
	POP HL ;restore parm three
callst:	PUSH HL ;save parm three
	LD HL,callrt ;where subroutines return
	EX (SP),HL ;put it on stack, get back parm three
	PUSH HL ;save parm three
	LD HL,(tempa) ;get subroutine address
	EX (SP),HL ;save, get back parm three
	RET ;dispatch to subroutine

callrt:	LD HL,(savstk) ;restore stack to former state
	LD SP,HL
	LD HL,(temp) ;get back text poiner
	JP newstt ;get next statement
	page
	subttl	chain
; this is the code for the chain statement
; the syntax is:
; chain [merge]<file name>[,[<line number>][,all][,delete <range>]]
; the steps required to execute a chain are:
;
; 1.) scan arguments
;
; 2.) scan program for all common statements and 
;	mark specified variables.
;
; 3.) squeeze unmarked entries from symbol table.
;
; 4.) copy string literals to string space
;
; 5.) move all simple variables and arrays into the
;	bottom of string space.
;
; 6.) load new program
;
; 7.) move variables back down positioned after program.
;
; 8.) run program
chain:
	XOR A ;assume no merge
	LD (mrgflg),A
	LD (mdlflg),A ;also no merge w/ delete option
	LD A,(HL) ;get current char
	LD DE,0+$merge ;is it merge?
	CP E ;test
	JP NZ,ntchnm ;no
	LD (mrgflg),A ;set merge flag
	INC HL
ntchnm:	DEC HL ;rescan file name
	CALL chrgtr
	CALL prgfli ;evaluate file name and open it
	PUSH HL ;save text pointer
	LD HL,0 ;get zero
	LD (chnlin),HL ;assume no chain line #
	POP HL ;restore text pointer
	DEC HL ;back up pointer
	CALL chrgtr ;scan char
	JP Z,ntchal ;no line number etc.
	CALL synchr
	db	54o ;must be comma
	CP 54o ;ommit line # (use all for instance)
	JP Z,ntlinf ;yes
	CALL frmevl ;evaluate line # formula
	PUSH HL ;save text poiner
	CALL frqint ;force to int in [h,l]
	LD (chnlin),HL ;save it for later
	POP HL ;restore text poiner
	DEC HL ;rescan last char
	CALL chrgtr
	JP Z,ntchal ;no all i.e. preserve all vars across chain
ntlinf:	CALL synchr
	db	54o ;should be comma here
	LD DE,0+$delet ;test for delete option
	CP E ;is it?
	JP Z,chmwdl ;yes
	CALL synchr
	db	'A' ;check for "ALL"
	CALL synchr
	db	'L'
	CALL synchr
	db	'L'
	JP Z,dncmda ;goto step 3
	CALL synchr
	db	54o ;force comma to appear
	CP E ;must be delete
	JP NZ,snerr ;no, give error
	OR A ;flag to goto dncmda
chmwdl:	PUSH AF ;save all flag
	LD (mdlflg),A ;set merge w/ delete
	CALL chrgtr ;get char after comma
	CALL scnlin ;scan line range
	PUSH BC
	CALL deptr ;change pointers back to numbers
	POP BC
	POP DE ;pop max line off stack
	PUSH BC ;save pointer to start of 1st line
	LD H,B ;save pointer to start line
	LD L,C
	LD (cmsptr),HL
	CALL fndlin ;find the last line
	JP NC,fcerg2 ;must have exact match on end of range
	LD D,H ;[d,e] =  pointer at the start of the line
	LD E,L ;beyond the last line in the range
	LD (cmeptr),HL ;save pointer to end line
	POP HL ;get back pointer to start of range
	CALL dcompr ;make sure the start comes before the end
fcerg2:	JP NC,fcerr ;if not, "Illegal function call"
	POP AF ;flag that says whether to go to dncmda
	JP NZ,dncmda ;"ALL" option was present
ntchal:	LD HL,(curlin) ;5.21: save current line
	PUSH HL ;5.21: on stack
	LD HL,(txttab) ;start searching for commons at program start
	DEC HL ;compensate for next instr
clpsc1:	INC HL ;look at first char of next line
clpscn:	LD A,(HL) ;get char from program
	INC HL
	OR (HL) ;are we pointing to program end?
	JP Z,clpfin ;yes
	INC HL
	LD E,(HL) ;get line # in [d,e]
	INC HL
	LD D,(HL)
	EX DE,HL ;save current line # in curlin for errors
	LD (curlin),HL
	EX DE,HL
cstscn:	CALL chrgtr ;get statment type
aftcom:	OR A
	JP Z,clpsc1 ;eol scan next one
	CP ':' ;are we looking at colon
	JP Z,cstscn ;yes, get next statement
	LD DE,0+$commo ;test for common, avoid byte externals
	CP E ;is it a common?
	JP Z,docomm ;yes, handle it
	CALL chrgtr ;get first char of statement
	CALL data ;skip over statement
	DEC HL ;back up to rescan terminator
	JP cstscn ;scan next one
docomm:	CALL chrgtr ;get thing after common
	JP Z,aftcom ;get next thing
nxtcom:	PUSH HL ;save text pointer
	LD A,1 ;call ptrget to search for array
	LD (subflg),A
	CALL ptrglb ;5.21: changed from ptrget to ptrglb
	JP Z,fndaay ;found array
	LD A,B ;try finding array with common bit set
	OR 128
	LD B,A
	XOR A ;set zero cc
	CALL ersfin ;search array table
	LD A,0 ;clear subflg in all cases
	LD (subflg),A
	JP NZ,ntfn2t ;not found, try simple
	LD A,(HL) ;get terminator, should be "("
	CP '(' ;test
	JP NZ,scnsmp ;must be simple then
	POP AF ;get rid of saved text pointer
	JP comady ;already was common, ignore it
ntfn2t:	LD A,(HL) ;get terminator
	CP '(' ;array specifier?
	JP Z,fcerr ;no such animal, give "Function call" error
scnsmp:	POP HL ;rescan variable name for start
	CALL ptrglb ;5.21: evaluate as simple (via stub)
comptr:	LD A,D ;if var not found, [d,e]=0
	OR E
	JP NZ,comfns ;found it
	LD A,B ;try to find in common
	OR 128 ;set common bit
	LD B,A
	LD DE,compt2 ;5.21: push return address
	PUSH DE
	LD DE,ptrrtn ;5.21: push parameter for noarys
	PUSH DE
	LD A,(valtyp) ;must have valtyp in [d]
	LD D,A
	JP noarys ;5.21: jump instead of call
compt2:	LD A,D ;found?
	OR E
	JP Z,fcerr ;no, who is this guy?
comfns:	PUSH HL ;save text pointer
	LD B,D ;get pointer to var in [b,c]
	LD C,E
	LD HL,bckucm ;loop back here
	PUSH HL
cbakbl:	DEC BC ;point at first char of rest
lpbknc:	LD A,(BC) ;back up until plus byte
	DEC BC
	OR A
	JP M,lpbknc
					;now point to 2nd char of var name
	LD A,(BC) ;set common bit
	OR 128
	LD (BC),A
	RET ;done
fndaay:	LD (subflg),A ;array found, clear subflg
	LD A,(HL) ;make sure really array spec
	CP '(' ;really an array?
	JP NZ,scnsmp ;no, scan as simp
	EX (SP),HL ;save text pointer, get rid of saved text pointer
bakcom:	DEC BC ;point at last char of name extension
	DEC BC
	CALL cbakbl ;back up before variable and mark as common
bckucm:	POP HL ;restore text pointer
	DEC HL ;rescan terminator
	CALL chrgtr
	JP Z,aftcom ;end of common statement
	CP '(' ;end of common array spec?
	JP NZ,chkcst ;no, should be comma
comady:	CALL chrgtr ;fetch char after paren
	CALL synchr
	db	')' ;right paren should follow
	JP Z,aftcom ;end of common
chkcst:	CALL synchr
	db	54o ;force comma to appear here
	JP nxtcom ;get next common variable
; step 3 - squeeze..
clpfin:	POP HL ;5.21: restore curlin from ntchal push
	LD (curlin),HL ;5.21: store it back
	EX DE,HL ;5.21: redundant swap
	LD HL,(arytab) ;end of simple var squeeze
	EX DE,HL ;to [d,e]
	LD HL,(vartab) ;start of simps
clpslp:	CALL dcompr ;are we done?
	JP Z,dncmds ;yes done, with simps
	PUSH HL ;save where this simp is
	LD C,(HL) ;get valtyp
	INC HL
	INC HL
	LD A,(HL) ;get common bit
	OR A ;set minus if common
	PUSH AF ;save indicator
	AND 177o ;clear common bit
	LD (HL),A ;save back
	INC HL
	CALL iadahl ;skip over rest of var name
	LD B,0 ;skip valtyp bytes
	ADD HL,BC
	POP AF ;get indicator whether to delete
	POP BC ;pointer to where var started
	JP M,clpslp
	PUSH BC ;this is where we will resume scanning vars later
	CALL vardls ;delete variable
	LD HL,(arytab) ;now correct arytab by # of bytes deleted
	ADD HL,DE ;add negative difference between old and new
	LD (arytab),HL ;save new arytab
	EX DE,HL ;to [d,e]
	POP HL ;get current place back in [h,l]
	JP clpslp
vardls:	EX DE,HL ;point to where var ends
	LD HL,(strend) ;one beyond last byte to move
dlsvlp:	CALL dcompr ;done?
	LD A,(DE) ;grab byte
	LD (BC),A ;move down
	INC DE ;increment pointers
	INC BC
	JP NZ,dlsvlp
	LD A,C ;get difference between old and new
	SUB L ;into [d,e] ([d,e]=[b,c]-[h,l])
	LD E,A
	LD A,B
	SBC H
	LD D,A
	DEC DE ;correct # of bytes
	DEC BC ;moved one too far
	LD H,B ;get new strend [h,l]
	LD L,C
	LD (strend),HL ;store it
	RET
dncmds:	EX DE,HL ;5.21: redundant swap
	LD HL,(strend) ;limit of array search
	EX DE,HL ;to [d,e]
clpakp:	CALL dcompr ;done?
	JP Z,dncmda ;yes
	PUSH HL ;save pointer to valtyp
	INC HL ;move down to common bit
	INC HL
	LD A,(HL) ;get it
	OR A ;set cc's
	PUSH AF ;save common indicator
	AND 177o ;clear common bit
	LD (HL),A ;save back
	INC HL ;point to length of array
	CALL iadahl ;add length of var name
	LD C,(HL) ;get length of array in [b,c]
	INC HL
	LD B,(HL)
	INC HL
	ADD HL,BC ;[h,l] now points after array
	POP AF ;get back common indicator
	POP BC ;get pointer to start of array
	JP M,clpakp ;common, dont delete!
	PUSH BC ;save so we can resume
	CALL vardls ;delete variable
	EX DE,HL ;put strend in [d,e]
	POP HL ;point to next var
	JP clpakp ;look at next array
; step 4 - copy literals into string space
; this code is very smilar to the string garbage collect code
dncmda:	LD HL,(vartab) ;look at simple strings
csvar:	EX DE,HL ;into [d,e]
	LD HL,(arytab) ;limit of search
	EX DE,HL ;start in [h,l], limit in [d,e]
	CALL dcompr ;done?
	JP Z,cayvar ;yes
	LD A,(HL) ;get valtyp
	INC HL ;point to length of long var name
	INC HL
	INC HL
	PUSH AF ;save valtyp
	CALL iadahl ;move past long variable name
	POP AF ;ge back valtyp
	CP 3 ;string?
	JP NZ,cskpva ;skip this var, not string
	CALL cdvars ;copy this guy into string space if nesc
	XOR A ;cdvars has already incremented [h,l]
cskpva:	LD E,A
	LD D,0 ;add length of valtyp
	ADD HL,DE
	JP csvar
cayva2:	POP BC ;adjust stack
cayvar:	EX DE,HL ;save where we are
	LD HL,(strend) ;new limit of search
	EX DE,HL ;in [d,e], limit in [h,l]
	CALL dcompr ;done?
	JP Z,dnccls ;yes
	LD A,(HL) ;get valtyp of array
	INC HL
	INC HL
	PUSH AF ;save valtyp
	INC HL
	CALL iadahl ;skip over rest of array name
	LD C,(HL) ;get length of array
	INC HL
	LD B,(HL) ;into [b,c]
	INC HL
	POP AF ;get back valtyp
	PUSH HL ;save pointer to array element
	ADD HL,BC ;point after array
	CP 3 ;string array?
	JP NZ,cayva2 ;no, look at next one
	LD (temp3),HL ;save pointer to end of array
	POP HL ;get back pointer to array start
	LD C,(HL) ;pick up number of dims
	LD B,0 ;make double with high zero
	ADD HL,BC ;go past dims
	ADD HL,BC
	INC HL ;one more to account for # of dims
caystr:	EX DE,HL ;save current position in [d,e]
	LD HL,(temp3) ;get end of array
	EX DE,HL
	CALL dcompr ;see if at end of array
	JP Z,cayvar ;get next array
	LD BC,caystr ;do next str in array
	PUSH BC ;save branch address on stack
cdvars:	LD A,(HL) ;5.21: get length from memory into A
	INC HL ;also pick up pointer into [d,e]
	LD E,(HL)
	INC HL
	LD D,(HL)
	INC HL ;[h,l] points after descriptor
	OR A ;5.21: test length
	RET Z ;ignore null strings
	PUSH HL ;save where we are
	LD HL,(vartab) ;is string in program text or disk buffers?
	CALL dcompr ;compare
	POP HL ;restore where we are
	RET C ;no, must be in string space
	PUSH HL ;save where we are again.
	LD HL,(txttab) ;is it in buffers?
	CALL dcompr ;test
	POP HL ;restore where we are
	RET NC ;in buffers, do nothing
	PUSH HL ;save where we are for nth time
	DEC HL ;point to start of descriptor
	DEC HL
	DEC HL
	PUSH HL ;save pointer to start
	CALL strcpy ;copy string into dsctmp
	POP HL ;destination in [h,l], source in [d,e]
	LD B,3 ;# of bytes to move
	CALL move1 ;move em
	POP HL ;where we are
	RET
; step 5 - move stuff up into string space!
dnccls:	CALL garba2 ;get rid of unused strings
	LD HL,(strend) ;load end of vars
	LD B,H ;into [b,c]
	LD C,L
	EX DE,HL ;5.21: redundant swap
	LD HL,(vartab) ;start of simps into [d,e]
	EX DE,HL
	LD HL,(arytab)
	LD A,L ;get length of simps in [h,l]
	SUB E
	LD L,A
	LD A,H
	SBC D
	LD H,A
	LD (temp9),HL ;save here
	LD HL,(fretop) ;destination of high byte
	LD (savfre),HL ;save fretop to restore later
	CALL bltuc ;move stuff up
	LD H,B ;now adjust top of memory below saved vars
	LD L,C
	DEC HL ;one lower to be sure
	LD (fretop),HL ;update fretop to reflect new value
	LD A,(mdlflg) ;merge w/ delete?
	OR A ;test
	JP Z,ntmdlt ;no
	LD HL,(cmsptr) ;start of lines to delete
	LD B,H ;into [b,c]
	LD C,L
	LD HL,(cmeptr) ;end of lines to delete
	CALL del ;delete the lines
	LD (arytab),HL ;5.21: store new arytab
	LD (strend),HL ;5.21: store new strend
	CALL linker ;re-link lines just in case
; step 6 - load new program
ntmdlt:	LD A,1 ;set chain flag
	LD (chnflg),A
	LD A,(mrgflg) ;mergeing?
	OR A ;set cc'S
	JP NZ,okgetm ;do merge
	LD A,(maxfil) ;save the number of files
	LD (lstfre+1),A ;since we make it look like zero
	JP chnent ;jump to load code
; step 7 - move stuff back down
chnret:	XOR A ;clear chain, merge flags
	LD (chnflg),A
	LD (mrgflg),A
	LD HL,(vartab) ;get current vartab
	LD B,H ;into [b,c]
	LD C,L
	LD HL,(temp9) ;get length of simps
	ADD HL,BC ;add to present vartab to get new arytab
	LD (arytab),HL
	LD HL,(fretop) ;where to start moving
	INC HL ;one higher
	EX DE,HL ;into [d,e]
	LD HL,(savfre) ;last byte to move
	LD (fretop),HL ;restore fretop from this
mvbkvr:	CALL dcompr ;done?
	LD A,(DE) ;move byte down
	LD (BC),A
	INC DE ;increment pointers
	INC BC
	JP NZ,mvbkvr
	DEC BC ;point to last var byte
	LD H,B ;[h,l]=last var byte
	LD L,C
	LD (strend),HL ;this is new end
	EX DE,HL ;5.21: save current DE
	LD HL,(chnlin) ;get chain line #
	EX DE,HL ;5.21: DE = chnlin, HL = old
	LD HL,(txttab) ;get prog start in [h,l]
	DEC HL ;point at zero before program
	LD A,D ;5.21: test DE (chnlin) for zero
	OR E
	JP Z,newstt ;line #=0, go...
	CALL fndlin ;try to find destination line
	JP NC,userr ;not there...
	DEC BC ;point to zero on previous line
	LD H,B ;make text pointer for newstt
	LD L,C
	JP newstt ;bye...
common:	JP data
	page
	subttl	write
write:
	LD C,md.sqo ;setup output file
	CALL filget
wrtchr:	DEC HL
	CALL chrgtr ;get another character
	JP Z,wrtfin ;done with write
wrtmlp:	CALL frmevl ;evaluate formula
	PUSH HL ;save the text pointer
	CALL getypr ;see if we have a string
	JP Z,wrtstr ;we do
	CALL fout ;convert to a string
	CALL strlit ;literalize string
	LD HL,(faclo) ;get pointer to string
	INC HL ;point to address field
	LD E,(HL)
	INC HL
	LD D,(HL)
	LD A,(DE) ;is number positive?
	CP ' ' ;test
	JP NZ,wrtneg ;no, must be negative
	INC DE
	LD (HL),D
	DEC HL
	LD (HL),E
	DEC HL
	DEC (HL) ;adjust length of string
wrtneg:	CALL strprt ;print the number
nxtwrv:	POP HL ;get back text pointer
	DEC HL ;back up pointer
	CALL chrgtr ;get next char
	JP Z,wrtfin ;end
	CP 59 ;semicolon?
	JP Z,wasemi ;was one
	CALL synchr
	db	54o ;only possib left is comma
	DEC HL ;to compensate for later chrget
wasemi:	CALL chrgtr ;fetch next char
	LD A,54o ;put out comma
	CALL outdo
	JP wrtmlp ;back for more
wrtstr:	LD A,34 ;put out double quote
	CALL outdo ;send it
	CALL strprt ;print the string
	LD A,34 ;put out another double quote
	CALL outdo ;send it
	JP nxtwrv ;get next value
wrtfin:
	PUSH HL ;save text pointer
	LD HL,(ptrfil) ;see if disk file
	LD A,H
	OR L
	JP Z,ntrndw ;no
	LD A,(HL) ;get file mode
	CP md.rnd ;random?
	JP NZ,ntrndw ;no
	CALL cmpfbc ;see how many bytes left
	LD A,L ;do subtract
	SUB E
	LD L,A
	LD A,H
	SBC D
	LD H,A
crlfsq	set	2 ;number of bytes in cr/lf sequence
	LD DE,0-crlfsq ;subtract bytes in <cr>
	ADD HL,DE
	JP NC,ntrndw ;not enough, give error eventually
nxtwsp:	LD A,' ' ;put out spaces
	CALL outdo ;send space
	DEC HL ;count down
	LD A,H ;count down
	OR L
	JP NZ,nxtwsp
ntrndw:	POP HL ;restore [h,l]
	CALL crdo ;do crlf
	JP finprt

;======================================================================
; Module: dskcom.mac
;======================================================================

	page
	title	dskcom - - common routines for disk basics


; revision history
;4/23/78	pga	allow # on close
;
;8/6/79  pga	if ^c on mbasic foo, dont return to system. see 'NOTINI'
;6/27/80	pga	fix input#1,d# so it uses findbl instead of fin
;		and thus avoids losing significance.
;
;%
	subttl	filinp and filget -- scan a file number and setup ptrfil

filinp:	LD C,md.sqi ;must be sequential input
filget:	CP '#' ;number sign there?
	RET NZ ;no, not disk reader
	PUSH BC ;save expected mode
	CALL filscn ;read and get pointer
	POP DE ;[e]=file mode
	CP E ;is it right?
	JP Z,gdfilm ;good file mode
	CP md.rnd ;allow stuff with random files
	JP NZ,derbfm ;if not, "BAD FILE MODE"
gdfilm:
	CALL synchr
	db	44 ;go past the comma
filset:	LD D,B ;5.21: copy BC to DE first
	LD E,C
	EX DE,HL ;[d,e]=text pointer, [h,l]=file ptr
	LD (ptrfil),HL ;setup ptrfil
	EX DE,HL ;text pointer back into [h,l]
	RET

	page
	subttl	filscn, filfrm, and filidx
;
; at this entry point [h,l] is assumed to be the text pointer and
; a file number is scanned
;
filscn:	DEC HL
	CALL chrgtr
	CP '#' ;make number sign optional
	CALL Z,chrgtr ;by skipping it if there
	CALL frmevl ;read the file number into the fac
;
; at this entry point the fac has the file number in it already
;
filfrm:	CALL conint ;get the file number into [a]
;
; at this point it is assumed the file number is in [a]
; the file number is returned in [e]
; [d] is set to zero. [h,l] is saved.
; [b,c] is set to point at the file data block for file [e]
; [a] give the mode of the file and zero is set  if the file is
; mode zero (not open).
;
filidx:	LD E,A ;get file number into [e]
filid2:	LD A,(maxfil) ;is this file # legal?
	CP E
	JP C,derbfn ;if not, "BAD FILE NUMBER"
	LD D,0 ;setup double-byte offset to get
					;pointer to file data block
	PUSH HL ;save [h,l]
	LD HL,filptr ;point at pointer table
	ADD HL,DE ;add on offset twice for double byte
	ADD HL,DE ;entries
	LD C,(HL) ;pick up pointer in [b,c]
	INC HL
	LD B,(HL)
	LD A,(BC) ;get mode of file into [a]
	OR A ;set zero if file not open
	POP HL ;retrieve [h,l]
	RET

; getptr is called from varptr(#<expression>)
getptr:	CALL filid2 ;index into file data block
	LD HL,datofc ;point to data block
	CP md.rnd ;random file?
	JP NZ,ntfivd ;no, use notrrmal fooffset
	LD HL,0+fd.dat ;yes
ntfivd:
	ADD HL,BC ;add start of file data block
	EX DE,HL ;return in [d,e]
	RET
	page

mki$:	LD A,2 ;value type for integer and number
					;of characters result will need
	db	1 ;skip next two bytes with "LXI	B,"
mks$:	LD A,4 ;value type of single precision
	db	1 ;skip next two bytes
mkd$:	LD A,8 ;value type of double-precision
	PUSH AF ;save the number of bytes of
					;string space we need
	CALL docnvf ;convert fac to proper type
	POP AF ;get the number of bytes needed
	CALL strini ;get a place for the string data
	LD HL,(dsctmp+1) ;point to the place to store the data
	CALL vmovmf ;move the fac value into the string creation
	JP finbck ;finish up these string functions

cvi:	LD A,1 ;set [a] to be valtyp-1
	db	1 ;skip the next two bytes with "LXI B,"
cvs:	LD A,3 ;also set [a] to number of characters required -1
	db	1 ;skip the next two bytes
cvd:	LD A,7 ;double precision value type -1
	PUSH AF ;save the valtyp
	CALL frestr ;make sure the argument is a string
					;and get a pointer to the descriptor
	POP AF ;get back number of characters required-1
	CP (HL) ;make sure the string is longer than that
	JP NC,fcerr ;if not, "ILLEGAL FUNCTION CALL"
	INC A ;[a]=true value type
	LD (valtyp),A ;5.21: setup value type first
	INC HL
	LD A,(HL) ;5.21: get low byte into A
	INC HL ;to be moved into the fac
	LD H,(HL)
	LD L,A ;5.21: put low byte into L
					;and for identification
	JP vmovfm ;move in the string data

	page
	subttl	setup to read a sequential item -- filind

filind:
	CALL getypr ;see if input is string or number
	LD BC,doasig ;return address to setup [fac]
con1	set	0+(44*256)+32
	LD DE,con1 ;setup terminators space and comma
	JP NZ,inpdor ;if numeric, go read the file
	LD E,D ;make both terminators comma
	JP inpdor ;go read the file
	page
	subttl	line input & read code for item fetching from sequential input files

dline:	CALL filinp ;get file number set up
	CALL ptrget ;read string to store into
	CALL frcstr ;make sure it was a string
	LD BC,finprt ;reset to console when done reading
	PUSH BC ;save on stack
	PUSH DE ;save pointer at variable
	LD BC,letcon ;good return address for assignment
	XOR A ;set a=0 for string value type
	LD D,A ;zero out both terminators
	LD E,A
inpdor:	PUSH AF ;save value type
	PUSH BC ;save return address
	PUSH HL ;save pointer at data coming in
					;a dummy pointer at bufmin
notnwt:	CALL indskc ;read a character
	JP C,derrpe ;read past end error if eof
	CP ' ' ;skip leading spaces
	JP NZ,notsp2 ;except for line input
	INC D ;check for lineinput
	DEC D
	JP NZ,notnwt ;skip any number
notsp2:	CP 34 ;quoted string coming in?
	JP NZ,notqte
	LD B,A ;save the quote
	LD A,E ;must be input of a string
	CP 44 ;which has [e]=44
	LD A,B ;quote back into [a]
	JP NZ,notqte
	LD D,B ;terminators are quotes only
	LD E,B
	CALL indskc ;read past quotation
	JP C,quitsi ;if eof, all done
notqte:
	LD HL,buf ;buffer for data
	LD B,255 ;maximum number of characters (255)
lopcrs:	LD C,A ;save character in [c]
	LD A,D ;check for quoted string
	CP 34
	LD A,C ;restore character
	JP Z,notqtl ;don'T IGNORE CR OR STOP ON LF
	CP 13 ;cr?
	PUSH HL ;save dest ptr. on stack
	JP Z,icaslf ;eat line feed if one
	POP HL ;restore dest. ptr.
	CP 10 ;lf?
	JP NZ,notqtl ;no, test other terminators
	LD C,A ;save current char
	LD A,E ;get terminator 2
	CP 54o ;check for comma (unquoted string)
	LD A,C ;restore orig char
	CALL NZ,strchr ;if not, store lf (?)
	CALL indskc ;get next char
	JP C,quitsi ;if eof, all done.
	CP 13 ;is it a cr?
	JP NZ,notqtl ;if not see if store normally
	LD A,E ;get terminator
	CP ' ' ;is it numeric input?
	JP Z,lpcrgt ;if so, ignore cr, dont put in buffer
	CP 44 ;is it non-quoted string (term=,)
	LD A,13 ;get back cr.
	JP Z,lpcrgt ;if so, ignore cr.
notqtl:	OR A ;is char zero
	JP Z,lpcrgt ;always ignore, as it is terminator
					;for strlit (see quit2b)
	CP D ;terminator one?
	JP Z,quitsi ;stop then
	CP E ;terminator two?
	JP Z,quitsi
	CALL strchr ;save the char
lpcrgt:	CALL indskc ;read another character
	JP NC,lopcrs ;if not, check as terminator
quitsi:	PUSH HL ;save place to stuff zero
	CP 34 ;stopped on quote?
	JP Z,morspc ;don'T SKIP SPACES THEN
					;but do skip following comma or
					;crlf though
	CP ' ' ;stopped on space?
	JP NZ,noskcr ;no, don'T SKIP SPACES
					;or any following commas or crlfs either
morspc:	CALL indskc ;read spaces
	JP C,noskcr ;eof, all done.
	CP ' '
	JP Z,morspc
	CP 44 ;comma?
	JP Z,noskcr ;ok, skip it
	CP 13 ;carriage return?
	JP NZ,bakupt ;back up past this character
icaslf:
	CALL indskc ;read another
	JP C,noskcr ;eof, all done.
	CP 10 ;line feed?
	JP Z,noskcr ;ok, skip it too
bakupt:	LD HL,(ptrfil) ;go to number of charaters
	LD BC,0+nmlofs
	ADD HL,BC
	INC (HL) ;back up by incrementing character count
noskcr:	POP HL ;get back place to store terminator
quit2b:	LD (HL),0 ;store the terminator
	LD HL,bufmin ;5.21: item is now stored at this point +1 (buf-1)
	LD A,E ;was it a numeric input?
	SUB ' ' ;if so, [e]=" "
	JP Z,numimk ;use fin to scan it
	LD B,D ;set [b]=44 if scanning unquoted string
	LD D,0
	CALL strlt2
	POP HL ;get back [h,l]
	RET ;do assignment

numimk:	CALL getypr ;get type of numeric variable being read
	PUSH AF ;save it
	CALL chrgtr ;read first character
	POP AF ;restore type of variable
	PUSH AF ;save back
	CALL C,fin ;single precision input
	POP AF ;get back type of var
	CALL NC,findbl ;double precision input
	POP HL ;get [h,l]
	RET ;do the assignment

strchr:	OR A ;trying to store null byte
	RET Z ;return, dont store it
	LD (HL),A ;store the character
	INC HL
	DEC B ;128 yet?
	RET NZ ;more space in buffer, return
	POP BC ;get rid of superfluous stack entry
	JP quit2b ;special quit

	page
prgfli:	LD D,md.sqi ;sequential input mode
prgfl2:	XOR A ;internal file number is always zero
	JP prgfil ;scan file name and disk nummer
					;and do the right thing using md.kil
					;as a flag

lrun:
lrun2::	db	366q ;set non zero to flag "RUN" command
load:	XOR A ;flag zero for "LOAD"
	PUSH AF ;save "RUN"/"LOAD" flag
	CALL prgfli ;find that file and setup for
					;using indskc subroutine
	LD A,(maxfil) ;save the number of files
	LD (lstfre+1),A ;since we make it look like zero
					;so ,r option can leave files
					;open
	DEC HL ;see if no run option
	CALL chrgtr
	JP Z,notrnl ;no, just load
	CALL synchr
	db	44 ;gotta have a comma
	CALL synchr
	db	'R' ;only option is run
	JP NZ,snerr ;and that better be the end
	POP AF ;get rid of "RUN"/"LOAD" flag
chnent:
	XOR A ;so files aren'T CLOSED
	LD (maxfil),A ;pretend there aren'T ANY
	db	366o ;flag run with non-zero
notrnl:	POP AF ;flag non-run with zero
	LD (lstfre),A
	LD HL,dirtmp
	LD (HL),0
	LD (filptr),HL ;mess up pointer at file zero
	CALL scrtch ;wipe out old stuff
	LD A,(lstfre+1) ;restore maxfil
	LD (maxfil),A ;that was kludged
	LD HL,(filpt1)
	LD (filptr),HL ;restore back to normal
	LD (ptrfil),HL ;ptrfil got zeroed so fix it too
; below is fix (to label notini) so that if ^c during mbasic foo, wont exit to system
	LD HL,(curlin) ;get line number
	INC HL ;see if in initialization
	LD A,H
	AND L
	INC A
	JP NZ,notini ;no
	LD (curlin),HL ;save direct line number
notini:
	CALL indskc ;read the first character
	JP C,main ;all done if nothing in file
	CP 254 ;is this a protected file?
	JP NZ,ntprol ;no
	LD (proflg),A ;set protected file
	JP binlod ;do binary load
ntprol:
	INC A ;is it a binary file?
	JP NZ,maingo ;no, since ptrfil is non-zero
					;inchr will use indskc instead of polling
					;the terminal
					;when eof is hit ptrfil will be restored
					;and lstfre will be used as a flag
					;to indicate whether to run the
					;loaded program
;
; time for a binary load.
; after the load, the file is linked together
; lstfre is used as a flag whether to run or not
;
binlod:	LD HL,(txttab) ;get place to start storing into
lpbldr:	EX DE,HL ;see if there is room to spare
	LD HL,(fretop)
	LD BC,0+65536-86
	ADD HL,BC
	CALL dcompr
	EX DE,HL
	JP C,outlod ;error and wipe out partial garbage
					;unlinked!! no zeroes at the end!!
	CALL indskb ;read the a data byte
					;this is semi-weak since memory
					;is left in a bad bad state
					;if an i/o error occurs
	LD (HL),A ;store byte
	INC HL ;incrment pointer
	JP NC,lpbldr ;read the next char
	LD (vartab),HL ;save end temp for decoding
	LD A,(proflg) ;is this a protected file?
	OR A ;set cc'S
	CALL NZ,prolod ;translate to good stuff
	CALL linker ;fix the links
	INC HL ;when linker returns, [h,l]
	INC HL ;points to double zero
	LD (vartab),HL ;update [vartab]
	LD HL,maxfil ;only close file zer0
	LD A,(HL)
	LD (lstfre+1),A
	LD (HL),0
	CALL runc ;setup arytab, strend
	LD A,(lstfre+1) ;restore number of files
	LD (maxfil),A
	LD A,(chnflg) ;chain in progress
	OR A ;test
	JP NZ,chnret ;yes, go back to chain code
	LD A,(lstfre) ;run or not?
	OR A
	JP Z,ready
	JP newstt

prgfin:	CALL finprt ;zero ptrfil
	CALL clsfil ;close file zero
	JP gtmprt ;refetch text pointer
outlod::	CALL scrtch
	JP omerr
merge:	POP BC ;eliminate newstt return
	CALL prgfli ;read the name and disk
	DEC HL ;must end there
	CALL chrgtr
	JP Z,okgetm ;read the file
	CALL prgfin ;close out time
	JP snerr ;and "SYNTAX ERROR"
okgetm:	XOR A ;no run option with "MERGE"
	LD (lstfre),A ;set up the flag
	CALL indskc ;read from [ptrfil] file
	JP C,main ;go back if eof
	INC A ;5.21: first check
	JP Z,derbfm ;5.21: check for 255
	INC A ;is it a binary file??
	JP Z,derbfm ;binary is wrong file mode
maingo:	LD HL,(ptrfil) ;get file pointer
	LD BC,nmlofc ;point to number of chars in buffer
	ADD HL,BC ;by adding offset
	INC (HL) ;back up file by incrementing count
	JP main

	page
	subttl	dispatch for direct statement
;
; make sure we'RE NOT READING A FILE IN
;
dirdo:
	PUSH HL
	LD HL,(ptrfil)
	LD A,H
	OR L ;is ptrfil zero so not file reading?
	LD DE,0+errfdr ;"DIRECT STATEMENT IN FILE"
	JP NZ,error ;note: lxi d, is used to
					;to make source conversions easier
	POP HL ;get back pointer at bufmin
	JP gone ;execute direct statement

	page
	subttl	save command -- ascii or binary

save:	LD D,md.sqo ;eliminate earlier version
					;and create empty file
	CALL prgfl2 ;read file name and disk number and
					;look it up
	DEC HL
	CALL chrgtr ;end of statement?
	JP Z,binsav ;binary save!!
	CALL synchr
	db	44 ;only option is ",A"
	CP 'P' ;protected save?
	JP Z,prosav ;do it
	CALL synchr
	db	'A' ;for ascii save
	JP list ;use the list code to do the output
					;control-cs are not allowed
					;and at the end ptrfil is zeroed
binsav:
	CALL sccptr ;get rid of pointers before saving
	CALL prochk ;dont allow binary saves of protected programs
	LD A,255 ;always start with 255
binpsv:	CALL filou3 ;send to file
	EX DE,HL ;5.21: redundant xchg
	LD HL,(vartab) ;get stop point
	EX DE,HL ;save in [d,e]
	LD HL,(txttab) ;get start point
bsavlp:	CALL dcompr ;reached the end?
	JP Z,prgfin ;reget text pointer and close file 0
	LD A,(HL) ;get line data
	INC HL ;point at next data
	PUSH DE ;save limit
	CALL filou3 ;send char to file
	POP DE ;restore limit
	JP bsavlp ;continue with line data

	subttl	driver code for close

close:	LD BC,clsfil ;service routine address
	LD A,(maxfil) ;highest possible argument
					;which means do all possible
rtallr:	JP NZ,rtloop ;not end of statement, so scan arguments
	PUSH HL ;save the text pointer
mrall:	PUSH BC ;save routine address
	PUSH AF ;save current value
	LD DE,retall ;return address
	PUSH DE ;save it to come back with
	PUSH BC ;dispatch to service routine
	RET
retall:	POP AF ;get back old argument
	POP BC ;get back service routine address
	DEC A ;decrement argument
	JP P,mrall ;loop on more values
	POP HL ;get back the text pointer
	RET

retrts:	POP BC ;get back service routine address
	POP HL ;get back the text pointer
	LD A,(HL) ;see if more arguments
	CP 44 ;delimited by comma
	RET NZ
	CALL chrgtr ;read first character of formula
rtloop:	PUSH BC ;save the service routine address
	LD A,(HL) ;get possble "#"
	CP '#' ;is it
	CALL Z,chrgtr ;skip it, its optional
	CALL getbyt ;read the argument
	EX (SP),HL ;save the text pointer on the stack
					;and set [h,l]=service address
	PUSH HL ;save the service address
	LD DE,retrts ;put a return address on the stack
	PUSH DE
	JP (HL) ;dispatch to do the function


clsall:	PUSH DE
	PUSH BC ;save [b,c] for stkini
	XOR A ;make it close all disks
	CALL close
	POP BC
	POP DE ;get back [d,e]
	XOR A ;return with [a]=0 and z on
	RET

	page
	subttl	"FIELD" statement for setting up i/o strings
field:	CALL filscn ;get data block pointer in [b,c]
	JP Z,derbfn ;"BAD FILE NUMBER" if file not open
	SUB md.rnd ;make sure its a random file
	JP NZ,derbfm ;if not, "BAD FILE MODE"
	EX DE,HL ;save text pointer
	LD HL,0+fd.siz ;point to record size
	ADD HL,BC
	LD A,(HL) ;get it
	INC HL
	LD H,(HL)
	LD L,A
	LD (tempa),HL ;store max allowed
	LD HL,0 ;zero max # of chars
	LD (tempb),HL
	LD A,H ;make [a]=0
	EX DE,HL ;get back text pointer
	LD DE,0+fd.dat ;point to 5.0 field buffer
lopfld:	EX DE,HL ;save text pointer in [d,e]
	ADD HL,BC ;add on data pointer so [h,l] now points
					;at the start of the data
	LD B,A ;setup count of characters past by
					;in data area, so total is never greater than 128
	EX DE,HL ;text pointer back into [h,l]
					;[d,e]=pointer into data area
	LD A,(HL) ;more "AS"s to scan?
	CP 44 ;comma starts the clause
	RET NZ ;back to newstt if not
	PUSH DE ;save the pointer into the data block
	PUSH BC ;save [b]=number of characters allocated
	CALL gtbytc ;read number into [a] from text
	PUSH AF ;save this number
	CALL synchr
	db	'A' ;scan the "AS"
	CALL synchr
	db	'S'
	CALL ptrget ;get a pointer at the string descriptor
	CALL frcstr ;into [d,e]
	POP AF ;get the number of characters
	POP BC ;get the number already used
	EX (SP),HL ;save the text pointer and
					;[h,l]=pointer into data block
	LD C,A ;save # of characters in [c]
	PUSH DE ;save [d,e]
	PUSH HL ;save [h,l]
	LD HL,(tempb) ;get total so far
	LD B,0 ;accumulate count
	ADD HL,BC
	LD (tempb),HL ;save total again
	EX DE,HL ;total to [d,e]
	LD HL,(tempa) ;get max allowed
	CALL dcompr ;in range?
	JP C,derfov ;no, give error
	POP HL ;restore [h,l]
	POP DE ;restore [d,e]
	EX DE,HL ;[h,l] point at string descriptor
	LD (HL),C ;store the length
	INC HL
	LD (HL),E ;store the pointer into the data block
	INC HL
	LD (HL),D
	POP HL ;get back the text pointer
	iff	datpsc-256
	JP NZ,lopfld ;if total added up to not 256, go back for more
	LD A,C ;see how much we added
	OR A ;test
	RET NZ
	endif ;just added up to 256, give syntax error if more
	JP lopfld ;continue scanning "AS" clauses if more
	page
	subttl	random non-i/o -- lset/rset/field

;lset/rset stringvar = stringexp
;
; if stringvar points to an i/o buffer, use the string size to
;justify string. if stringvar is a literal, make new var with length
;of literal. if stringvar points to string space, use it. if the
;length of the variable is zero, return the null string. if a copy
;must be created, and stringexp is a temporary, use this space over
;unless length stringvar greater than stringexp.

rset:	db	366o ;ori	<stc>
lset:	SCF ;set carry if lset
	PUSH AF ;save lset/rset flag
	CALL ptrget ;get pointer to stringvar
	CALL frcstr ;must be a string variable
	PUSH DE ;save pointer to descriptor
	CALL frmeql ;eat "=" and evaluate stringexp
	POP BC ; [b,c] = ptr to descr.
	EX (SP),HL ;text ptr on bottom of stack
	PUSH HL ;lset/rset flag next
	PUSH BC ;put descr. ptr back on
	CALL frestr ;error if not string, free temp.
	LD B,(HL) ;get length of stringexp
	EX (SP),HL ; [h,l] = descr. of var,save othr
	LD A,(HL) ;get length of stringvar
	LD C,A ;save in [c]
	PUSH BC ;save lengths of both
	PUSH HL ;save descriptor pointer
	PUSH AF ;psw zero if was temp.
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL) ;get ptr to stringvar text
	OR A ;stringvar null?
	JP Z,retcur ;yes, don't change
	LD HL,(txttab)
	CALL dcompr ;stringvar in disk buffer?
	JP NC,oldstr ;yes, use it
	LD HL,(vartab)
	CALL dcompr ;stringvar in program(literal)?
	JP C,oldstr ;no, in string space so use it
;need to make new string for result since stringvar points to a literal.
;if stringexp was a temporary, it has been freed. if the length of
;stringexp is greater than or equal to the length of stringvar, getspa
;can be called and no garbage collection can occur so temp. can be reused.
;if stringvar is greater, must get a temp. to point to stringexp if it
;was a temp. , then call getspa which in this case can garbage collect.
	LD E,C
	LD D,0 ;# bytes to allocate for result
	LD HL,(strend)
	ADD HL,DE
	EX DE,HL
	LD HL,(fretop)
	CALL dcompr ;will getspa garbage collect?
	JP C,makdsc ;yes, better have stringexp temp.
madesc:	POP AF
madsc1:	LD A,C ;5.21: entry point without pop psw
	CALL getspa ;get space for result
	POP HL ;get stringvar descr.
	POP BC ;get lengths off stack
	EX (SP),HL ;get what we wanted, stringexp descr.
	PUSH DE
	PUSH BC
	CALL frestr ;free temp if any
	POP BC
	POP DE
	EX (SP),HL
	PUSH BC ;restore stack to previous state
	PUSH HL
	INC HL
	PUSH AF ;5.21: push after first inx h
	LD (HL),E
	INC HL
	LD (HL),D ;set pointer to stringvar copy
oldstr:	POP AF
	POP HL ;get stringvar descr.
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL) ;get pointer to text area
	POP BC ;get lengths off stack
	POP HL ;get pointer to stringexp descr.
	INC HL ;5.21: load HL via A register
	LD A,(HL) ;get low byte
	INC HL
	LD H,(HL) ;get high byte into H
	LD L,A ;put low byte into L
	LD A,C ;get length of field(stringvar)
	CP B
	JP NC,fildok ;jump if field large enough for result
	LD B,A ;save # of bytes to copy
fildok:	SUB B
	LD C,A ;[c] = # blanks to fill
	POP AF ;get lset/rset flag
	CALL NC,blkfil ;fill leading if rset
	INC B ;in case zero
coplop:	DEC B ;decr. # to copy
	JP Z,lrstdn ;done when all copied
	LD A,(HL) ;get byte from stringexp
	LD (DE),A ;copy to stringvar
	INC HL
	INC DE
	JP coplop

retcur:	POP BC
	POP BC
	POP BC
	POP BC
	POP BC ;get garb off stack
lrstdn:	CALL C,blkfil ;fill trailing if lset
	POP HL ;restore text pointer
	RET

blkfil:	LD A,' ' ;fill with spaces
	INC C ;in case zero
blkfl1:	DEC C ;decr. # to fill
	RET Z ;return when done
	LD (DE),A ;store space
	INC DE
	JP blkfl1

; if stringexp was a temporary, create a new temporary to point to
; stringexp since old one was freed. this must be done since getspa
; will be called and garbage collection might occur. if stringexp is
; not a temporary, return.

makdsc:	POP AF ;get temp flag
	POP HL
	POP BC
	EX (SP),HL ;dig down to stringexp descr.
	EX DE,HL ;fretms wants [d,e]
	JP NZ,makds1 ;not a temp, don't reallocate
	PUSH BC
	LD A,B
	CALL strini ;make a temp point to stringexp
	CALL putnew ;get a temp to point to it
	POP BC
makds1:	EX (SP),HL
	PUSH BC
	PUSH HL ;restore stack to previous state
	JP madsc1 ;5.21: no push psw, skip pop psw
	page
	subttl	program i/o -- fixed length input

; format:
;		stringvar = input$(#bytes[,[#] file#])
;if no file # is given, characters will be read from the user's
; terminal. no echoing will be done and no editing will be allowed
; (i.e. rubout,@,_,^u are just input as characters).

fixinp:	CALL chrgtr
	CALL synchr
	db	'$' ;string function
	CALL synchr
	db	'('
	CALL getbyt ;get # of bytes to read
	PUSH DE ;save # of bytes to read
	LD A,(HL)
	CP 54o ;read from disk file?
	JP NZ,redtty ;no, from user's terminal
	CALL chrgtr
	CALL filscn ;set up file #
	CP md.sqo ;sequential output file?
	JP Z,derbfm ;then bad file mode
	CALL filset ;set up ptrfil
	XOR A ;set zero for flag
redtty:	PUSH AF ;non zero set if terminal i/o
	CALL synchr
	db	')' ;must have paren
	POP AF ;get flag off stack
	EX (SP),HL ;save text ptr, [l]=# to read
	PUSH AF ;save flag
	LD A,L
	OR A ;read no characters?
	JP Z,fcerr ;yes, error
	PUSH HL ;save #
	CALL strini ;get space for string
	EX DE,HL
	POP BC ;[c] = # to read
fixlop:	POP AF
	PUSH AF ;non-zero set if should read from tty
	JP Z,dskchr ;read from disk file
	CALL charcg ;get char if one
	JP NZ,charcw ;was one
	CALL inchri ;read a char from terminal
charcw:
;note : will check flag on interrupt ^c
	CP 3 ;control-c?
	JP Z,intctc ;yes, stop
putchr:	LD (HL),A ;put char into string
	INC HL
	DEC C ;read enough yet?
	JP NZ,fixlop ;no, read more
	POP AF ;get flag off stack
	CALL finprt ;clear ptrfil
	JP putnew ;return string as result
intctc:	LD HL,(savstk) ;get saved stack pointer
	LD SP,HL ;set [h,l] to it
	JP endcon ;stop program

dskchr:	CALL indskc ;get char from file
	JP C,derrpe ;if carry, read past eof
	JP putchr ;put char in string

;======================================================================
; Module: dcpm.mac
;======================================================================

	page
	subttl	disk parameters and documentation
	title	disk code for cpm/ontel/mostek/dmc/beehive: whg,pga,mbm


;external symbols







;internal symbols





;
;
;			revision history
;			-------- -------
;
;11/7/77		fixed eof() code to use ornofs instead of nmlofs, pga
;12/2/77  (4.41) fixed random access to close extents pga
;12/17/77	additional code to support ontel dos basic, p.zilber
;12/29/77 (4.42)	fixed bug where get, put w/o rec not inc curloc, pga
;1/5/78   (4.43) fixed another random bug, line printer ^c prob. pga
;7/23/79		add beehive interace and cleanup conditionals
;
;
;
;file information:
;
;	 1	mode of the file
;f.blk1	(n)	1st block of space, usually fcb( cpm: 33, ontel: 42,
;		mostek: 47 ). zero for others
;locofs	 2	curloc, # of sectors read or writeen for sequential.
;		for random files, it is the last record # +1.
;ornofs	 1/2	seq input: 	# of bytes in sector when read.
;		seq output:	# bytes in output sector( # written )
;		random:		set to datpsc by put and get, sometimes
;				zeroed by outsq2 setup for dskout code.
;nmlofs	 1/2	seq input:	# bytes left in input buffer
;		seq output:	position of imaginary print head
;f.blk2	(n)	2nd block of space( 6 byte chain links for ontel,
;		160 bytes for dmc, 10 bytes for beehiv )
;datofs	(n)	sector buffer, length = datpsc
;
;extra information for 5.0 version only:
;
;fd.siz	 2	variable length record size( default = 128 )
;fd.phy	 2	current physical record #
;fd.log	 2	current logical record #
;fd.chg	 1	future flag for across record prints, etc.
;fd.ops	 2	output print position for print, input, write
;fd.dat	(n)	data buffer for field, size is (fd.siz). fd.max is max.
;
;%

;file modes

md.000	set	0 ;the mode number for no file, internal
					;use only as an escape from open
md.rnd	set	3 ;the mode number for random files
md.sqi	set	1 ;the mode number for sequential input
					;files never written into a file
md.sqo	set	2 ;the mode for sequential output files
					;and program files

;disk code configuration switches

spc1st	set	1 or 0 or 0 or 0 or 0 or 0 ;1st block exists
spc2nd	set	0 or 0 or 0 ;2nd block exists
sw2byt	set	0 or 0 or 0 ;2 byte offsets (datpsc .gt. 255)
swlof	set	1 or 0 or 0 or 0 or 0 or 0 ;there is a lof function
swres	set	1 or 0 or 0 ;there is a reset statement
swfil	set	0 or 1 or 0 or 0 or 0 ;there is a files command
swdskf	set	(0 or 0) and (0-1) ;there is a dskf function

; offsets into file blocks for specific entries

locofs	set	34+3*1+9*0+14*0-10*0+267*0-30*0 ;offset to curloc bytes
ornofs	set	2+locofs ;offset to number of bytes
					;originally in the buffer
nmlofs	set	1+ornofs+0 ;offset to bytes remaining in the buffer
nmlofc	set	0+nmlofs
					;or the print position on output
nmlo.c	set	0+nmlofs


datofs	set	1+nmlofs+0+6*0+288*0+10*0 ;offset to buffer
datofc	set	0+datofs
dblksz	set	datofs+datpsc
dblk.c	set	0+dblksz

q	set	dblksz
;define	ent(sym,siz),<
;intern	sym
;sym=q
;q=q+siz>

fd.max	set	0 ;size of field buffer

;ent	fd.siz,2		;variable length record size default 128
fd.siz	set	q
q	set	q+2
;ent	fd.phy,2		;current physical record #
fd.phy	set	q
q	set	q+2
;ent	fd.log,2		;current logical record number
fd.log	set	q
q	set	q+2
;ent	fd.chg,1		;future flag for accross block prints etc.
fd.chg	set	q
q	set	q+1
;ent	fd.ops,2		;output print position for print, input, write
fd.ops	set	q
q	set	q+2
;5.21: fd.dm1 is fd.dat-1 for linker workaround
fd.dm1	set	q-1
;ent	fd.dat,fd.max		;actual field data buffer
fd.dat	set	q
q	set	q+fd.max
					;size is fd.siz bytes long

fnzblk	set	0+q

eofchr	set	26+2*0-22*0-23*0 ;end of file character

	subttl	operating system calls and other data



; cpm call identifiers

c.open	set	15
c.clos	set	16
c.dele	set	19
;c.writ==21
c.make	set	22
c.rena	set	23
c.buff	set	26 ;set dma address
c.gdrv	set	25 ;get currently selected drive
c.sdrv	set	14 ;set currently selected drive
c.rest	set	13 ;initialize bdos
c.sear	set	17 ;search for file

; offsets into cp/m fcb (file control block)
fcb.fn	set	1-0 ;file name
fcb.ft	set	9-0 ;extension
fcb.ex	set	12+20*0 ;file extent
fcb.rc	set	15+23*0 ;record count = current extent size
fcb.nr	set	32+8*0 ;next record number
fcb.rn	set	33 ;cp/m 2.x random record number





;special for cp/m testing

	subttl	eof function

eof::	CALL filfrm ;convert argument to file number
	JP Z,derbfn ;bad file number - not found !!!
					;and set [b,c] to point to file data block
	CP md.sqo ;is it a sequential output file?
	JP Z,derbfm ;then give bad file mode
ornchk:	LD HL,0+ornofs ;see if any bytes arrived in this buffer
	ADD HL,BC
	LD A,(HL) ;zero iff it is end of file
	OR A ;set cc'S
	JP Z,waseof ;no bytes left
	LD A,(BC) ;** 5.11 **  get file mode
	CP md.rnd ;is it a random file?
	JP Z,waseof ;** 5.11 **  (a) .ne. 0 - not eof
	INC HL ;point to number left in buffer
	LD A,(HL) ;get number of bytes in buffer
	OR A ;non-zero?
	JP NZ,chkctz ;then check for control-z
	PUSH BC ;save [b,c]
	LD H,B ;get fcb pointer in [b,c]
	LD L,C
	CALL readin ;read another buffer
	POP BC ;restore [b,c]
	JP ornchk ;have new buffer, use previous procedure
chkctz:	LD A,datpsc and 377o ;get # of bytes in full buffer
	SUB (HL) ;subtract left
	LD C,A ;put in [b,c] for dad
	LD B,0
	ADD HL,BC ;add to ornofs offset
	INC HL ;add one to point to byte in buffer
	LD A,(HL) ;get byte
	SUB eofchr ;if control-z, eof (control-\ is fs)
waseof:	SUB 1 ;map 0 to -1 and all others to 0
	SBC A
	JP conia ;convert to an integer and return

	subttl	outseq	-- sequential output for a data block

;
; [b,c] points at file data block
;
outseq:	LD D,B ;put file block offset in [d,e]
	LD E,C
	INC DE ;point to fcb
outsq2:	LD HL,0+ornofs ;point to number in buffer
	ADD HL,BC ;add start of file data block
	PUSH BC ;save file data pointer
	XOR A
	LD (HL),A ;zero out number in data buffer

;	output next record in file
;
;	(a) = 0
;	(hl) points to nmlofs-1
;	(de) points to file data block + 1 ( fcb if spc2nd=0)
;	(bc) points to file data block

	CALL setbuf ;set buffer address
	LD A,(cpmwri) ;get write code
	CALL accfil ;access file
	CP 255
	JP Z,dertmf ;too many files - 5.11
	DEC A ;error extending file? (1)
	JP Z,derioe ;yes
	DEC A ;disk full? (2)
	JP NZ,outsok ;no
	POP DE ;get back file pointer
	XOR A ;get zero
	LD (DE),A ;mark as closed
	LD C,c.clos ;close it
	INC DE ;point to fcb
	CALL cpment ;call cp/m
	JP derdfl ;give "DISK FULL" error message
outsok:	INC A ;too many files?
	JP Z,dertmf ;yes

	POP BC ;get pointer at curloc
	LD HL,0+locofs ;by adding offset to file pointer
	ADD HL,BC
	LD E,(HL) ;increment it
	INC HL
	LD D,(HL)
	INC DE
	LD (HL),D
	DEC HL
	LD (HL),E
	RET

	subttl	close a file
; file number is in [a]
; zero all information. if file is open, raise its disks head
; if file is sequential output, send final sector of data

clsfil:	CALL filidx ;get pointer to data
	JP Z,ntopnc ;return if not open
					;save file #
	PUSH BC ;save file pointer
	LD A,(BC) ;get file mode
	LD D,B ;put file block offset in [d,e]
	LD E,C
	INC DE ;point to fcb
	PUSH DE ;save [d,e] for later
	CP md.sqo ;seqential output?
	JP NZ,noforc ;no need to force partial output buffer
	LD HL,clsfl1 ;return here
	PUSH HL ;save on stack
	PUSH HL ;need extra stack entry
	LD H,B ;get file pointer
	LD L,C ;into [h,l]
	LD A,eofchr ;put out control-z (or fs)
	JP filou4 ;jump into char output code

clsfl1:	LD HL,0+ornofs ;chars in buffer
	ADD HL,BC ;test
	LD A,(HL) ;test ornofs
	OR A
	CALL NZ,outsq2 ;force out buffer


noforc:	POP DE ;get back fcb pointer

;	close file
;
;	(de) points to fcb
;	((sp)) points to file data block

	CALL setbuf ;set dma address
	LD C,c.clos ;the close
	CALL cpment ;call cpm
;*****	no check for errors





	POP BC ;restore file pointer
ntopnc:	LD D,datofs ;number of bytes to zero
	XOR A
morczr:	LD (BC),A
	INC BC
	DEC D
	JP NZ,morczr
	RET

	subttl	loc (current location) and lof (last record number)

loc:	CALL filfrm ;convert argument and point at data block
	JP Z,derbfn ;if not open, "BAD FILE NUMBER"
	CP md.rnd ;random mode?
	LD HL,0+locofs+1 ;assume not
	JP NZ,loc1 ;no, use curloc
	LD HL,0+fd.log+1 ;point at logical record number
loc1:
intred:	ADD HL,BC
intret:	LD A,(HL)
	DEC HL
	LD L,(HL)
	JP givint
	page
lof:	CALL filfrm ;convert argument and index
	JP Z,derbfn ;"BAD FILE NUMBER" if not open

;	(bc) points to file data block

	LD HL,0+fcb.rc+1 ;point to record number
	ADD HL,BC
	LD A,(HL) ;get rc
	JP sngflt ;float it
					;return with lof in (hl)
					;swlof

	subttl	filout -- put a character in an output buffer and output if necessary
;
; call at filout with [h,l] to be saved on the stack
; and the character in the high order byte below the [h,l]
; on the stack. the current data is output if there are 128
; character stuffed into the data area.
; filout is normally called from outdo (outchr)
;
filout:	POP HL ;get saved [h,l] off stack
	POP AF ;get save char off stack
filou3:	PUSH HL ;save the [h,l]
	PUSH AF ;save the character again
	LD HL,(ptrfil) ;get the pointer to the file
	LD A,(HL) ;what is the mode?
	CP md.sqi ;must be echoing or "EXTRA IGNORED"
					;during the reading of a file
	JP Z,popaht ;so ignore this outchr
	CP md.rnd ;random?
	JP Z,filofv ;yes, finish up in fivdk.mac
	POP AF ;take the character off
filou4:	PUSH DE
	PUSH BC
	LD B,H ;setup [b,c] for outseq
	LD C,L
	PUSH AF ;re-save output character
	LD DE,0+ornofs ;point at the number of characters in the
	ADD HL,DE ;buffer currently
	LD A,(HL)
	CP datpsc and 377o ;is the buffer full?
	PUSH HL ;save pointer at character count
	CALL Z,outseq ;output if full
	POP HL ;get back data block pointer
	INC (HL) ;increment the number of characters
	LD C,(HL) ;fetch for offset into data
	LD B,0
	INC HL ;point at print position
filupp:
	POP AF ;get the output character
	PUSH AF ;resave for output
	LD D,(HL) ;[d]=current position
	CP 13 ;back to zero position with return?
	LD (HL),B ;assume reset to zero since [b]=0
	JP Z,iscrds ;all done updating position
	ADD 224 ;set carry for spaces and higher
	LD A,D ;[a]=current position
	ADC B ;add on carry since [b]=0
	LD (HL),A ;update the position in the data block
iscrds:	ADD HL,BC
	POP AF ;get the character
	POP BC
	POP DE
	LD (HL),A ;save it in the data area
	POP HL ;get back saved [h,l]
	RET

	subttl	put and get statements

;	extern	get,put
fivdpt:
	DEC DE ;map record number 1=0 logical
	DEC HL
	LD (HL),E
	INC HL
	LD (HL),D ;setup curloc again
	INC HL ;point to orn
	LD (HL),datpsc and 377o ;set number in the buffer to datspc
	INC HL
	LD (HL),datpsc and 377o
	POP HL ;[h,l]=text pointer
	EX (SP),HL ;save text pointer, [h,l]=start of data block
	LD B,H
	LD C,L

;	random file access
;
;	(de) = physical block #
;	(bc) points to file data block
;	(hl) points to file data block

	PUSH HL ;save data block pointer
	LD A,(cpmvrn) ;get version number
	OR A
	JP Z,rndvr1 ;version 1.x

	LD HL,0+fcb.rn+1 ;offset to random record number
	ADD HL,BC
	LD (HL),E ;set new random record number
	INC HL
	LD (HL),D
	INC HL
	LD (HL),0
	JP rnddon ;finished setting record number

rndvr1:	LD HL,0+fcb.ex+1 ;point to extent
	ADD HL,BC ;add start of file control block
	LD A,E ;get low byte of offset
	RLA ;get high bit in carry
	LD A,D ;get high byte
	RLA ;rotate in high byte of low part
	LD D,(HL) ;put original extent in [d]
	CP D ;are new and old extent the same?
	JP Z,samext ;same extent, dont re-open
	PUSH DE ;save record number
	PUSH AF ;save new extent
	PUSH HL ;save pointer to extent
	PUSH BC ;save file pointer
	LD DE,dirtmp ;read directory in here for open
	LD C,c.buff ;set cpm buffer address
	CALL cpment
	POP DE ;get cpm fcb pointer
	PUSH DE ;save back
	INC DE ;point to fcb
	LD C,c.clos ;close previous extent (?!)
	CALL cpment ;call cp/m
	POP DE ;get back fcb pointer
	POP HL ;restore pointer to extent field
	POP AF ;get back new extent
	LD (HL),A ;store new extent
	PUSH DE
	INC DE ;point to fcb
	LD C,c.open ;open new extent
	PUSH DE ;save extent pointer
	CALL cpment ;by calling cp/m
	POP DE ;restore fcb pointer
	INC A ;does extent exist?
	JP NZ,rndok ;yes
	LD C,c.make ;make the extent exist
	CALL cpment ;call cp/m
	INC A ;room in directory?
	JP Z,dertmf ;no
rndok:	POP BC ;restore [b,c]
	POP DE ;restore record number
samext:	LD HL,0+fcb.nr+1 ;next record field
	ADD HL,BC ;point to it
	LD A,E ;get low 7 bits of record #
	AND 127
	LD (HL),A ;set record #

rnddon:
	POP HL ;[h,l] point at file data block

;	(bc) points to file data block
;	(hl) points to file data block

	LD A,(maxtrk) ;get flag for "PUT" or "GET"
	OR A
	JP NZ,putfin ;do the putting
	CALL readin ;perform the get
	POP HL ;get the text pointer
	RET

putfin:
	LD HL,0+fcb.nr+1 ;look at record #
	ADD HL,BC ;[h,l] points to it
	LD A,(HL) ;get it
	CP 127 ;last record in extent?
	PUSH AF ;save indicator
	LD DE,dirtmp ;save here
	LD HL,0+datofs ;point to data
	ADD HL,BC
	PUSH DE ;save dirtmp pointer
	PUSH HL ;save data pointer
	CALL Z,bufmov ;not last extent
	CALL outseq ;output the data
	POP DE ;restore data pointer
	POP HL ;restore pointer to dirtmp
	POP AF ;restore indicator
	CALL Z,bufmov ;move sector
	POP HL ;get the text pointer
	JP finprt ;zero ptrfil

bufmov:	PUSH BC ;save [b,c]
	LD B,datpsc ;# of bytes to move
bufslp:	LD A,(HL) ;get byte from buffer
	INC HL ;bump pointer
	LD (DE),A ;save in dirtmp
	INC DE ;bump pointer
	DEC B
	JP NZ,bufslp ;keep moving bytes
	POP BC ;restore [b,c]
	RET

	subttl	indskc, fillsq, and readin -- for reading characters and buffers

;
; get a character from a sequential file in [ptrfil]
; all registers except [d,e] smashed
;
;	'C' set if eof read
;
indskb:	PUSH BC ;save char counter
	PUSH HL ;save [h,l]
indsk3:	LD HL,(ptrfil) ;get data block pointer
	LD A,(HL) ;get file mode
	CP md.rnd ;random?
	JP Z,filifv ;do input
	LD BC,0+nmlofs ;see how many characters left
	ADD HL,BC
	LD A,(HL) ;get the number
	OR A
	JP Z,fillsq ;must go read some more -- if can
	DEC HL ;point at ornofs
	LD A,(HL) ;get original number
	INC HL ;point at number left again
	DEC (HL) ;decrement the number
	SUB (HL) ;subtract to give offset
	LD C,A ;[c]=offset
	ADD HL,BC
	LD A,(HL) ;get the data
	OR A ;reset carry flag for no eof
	POP HL ;restore [h,l]
popbrt:	POP BC ;restore
	RET

fillsq:	DEC HL ;back up pointer
	LD A,(HL) ;to ornofs
	OR A ;did we hit eof on previous read?
	JP Z,fills1 ;yes
	CALL read2 ;read a record
;	ora	a		;used to be - was it eof?
	JP NZ,indsk3 ;return with a char
fills1:	SCF ;carry is eof flag
	POP HL ;restore [h,l]
	POP BC ;eof detected
	LD A,eofchr ;return with char=control-z (or =fs)
	RET

read2:	LD HL,(ptrfil) ;get data pointer
readin:	PUSH DE
	LD D,H ;put fcb pointer in [d,e]
	LD E,L
	INC DE
	LD BC,0+locofs ;point to curloc
	ADD HL,BC
	LD C,(HL) ;update [curloc]
	INC HL
	LD B,(HL)
	INC BC
	DEC HL
	LD (HL),C
	INC HL
	LD (HL),B
	INC HL ;point to number read
	INC HL ;point to nmlofs
	PUSH HL ;save [h,l]
; zero out the buffer in case nothing read
	LD C,datpsc ;number of bytes/buffer
zrrnd:	INC HL ;increment buffer pointer
	LD (HL),0 ;zero it
	DEC C ;decrement count
	JP NZ,zrrnd ;keep zeroing

;	read specified record in file
;
;	(de) points to fcb
;
;	if sw2byt = 0,
;		(a) = number of bytes read
;	if sw2byt = 1,
;		(de) = number of bytes read
;
;	if eof, return with (a) or (de) zero and
;		jump to readi2
;
;	returns 'Z' set if eof

	CALL setbuf ;set cpm buffer address
	LD A,(cpmrea) ;get read code
	CALL accfil ;access file
	OR A ;eof?
	LD A,0 ;return 0 if eof
	JP NZ,readi2 ;assume eof if error
readi1:	LD A,datpsc ;otherwise, have 128 bytes
readi2:	POP HL ;point back to # read
	LD (HL),A ;store number read
	DEC HL ;point at number originally
	LD (HL),A ;store number read
	OR A ;test for eof
	POP DE ;get [d,e] back
	RET

setbuf:	PUSH BC ;save [b,c]
	PUSH DE ;save [d,e]
	PUSH HL ;save [h,l]
	LD HL,0+datofs-1 ;point to buffer
	ADD HL,DE ;add
	EX DE,HL ;put buffer address in [d,e]
	LD C,c.buff ;set up buffer address
	CALL cpment ;call cpm
	POP HL ;restore [h,l]
	POP DE ;restore [d,e]
	POP BC ;restore [b,c]
	RET

;
indskc:
	CALL indskb ;get char
	RET C ;if eof, return with end of file character
	CP eofchr ;was it a control-z (or fs)?
	SCF ;set carry
	CCF ;make sure carry reset
	RET NZ ;no
	PUSH BC ;save [b,c]
	PUSH HL ;save [h,l]
	LD HL,(ptrfil) ;get pointer to file data block
	LD BC,0+ornofs ;point to number originally in buffer
	ADD HL,BC
	LD (HL),0 ;force it to zero
	INC HL ;point to number in buffer
	LD (HL),0 ;force to zero.
	SCF ;set eof flag
	POP HL ;restore [h,l]
	POP BC ;restore [b,c]
	RET


	subttl	namfil -- scan a file name and name command

namfil:	CALL frmevl ;evaluate string
	PUSH HL ;save text pointer
	CALL frestr ;free up the temp
	LD A,(HL) ;get length of string
	OR A ;null string?
	JP Z,dernmf ;yes, error
	PUSH AF ;no "." seen
	INC HL ;pick up pointer to string
	LD E,(HL) ;by getting address
	INC HL ;out of descriptor
	LD H,(HL)
	LD L,E ;[h,l] points to string
	LD E,A ;save length

;	(hl) points to filename
;	(a) = length
;	(e) = length
;	((sp)) = no carry

	CP 2 ;can there be a device?
	JP C,nodev ;no, name too short
	LD C,(HL) ;[c]=possible device name
	INC HL ;point to next char
	LD A,(HL) ;get it
	DEC E ;decrement count for device name
	CP ':' ;colon for device name?
	JP Z,chkfil ;yes, so now get file name
	DEC HL ;back up pointer by one
	INC E ;compensate for dcr
nodev:	DEC HL ;back up pointer
	INC E ;increment char count to compensate for next decr
	LD C,'A'-1 ;use currently selected drive
chkfil:	DEC E ;decrment char count
	JP Z,nmflcl ;error if no filename
	LD A,C ;get drive #
	AND 337o ;5.21: convert to uppercase
	SUB 'A'-1 ;convert to logical number
	JP C,nmflcl ;not in range
	CP 27 ;bigger than 27
	JP NC,nmflcl ;not allowed
	LD BC,filnam ;where to put name
	LD (BC),A ;store disk # in fcb
	INC BC ;point to where first char of file name is stored
	LD D,11-2*0 ;length of name
filinx:	INC HL ;bump pointer
fillop:	DEC E ;end of string
	JP M,filspc ;yes, fill rest of field with blanks
	LD A,(HL) ;get char
	CP '.' ;extension?
	JP NZ,fillo1 ;no
fillo0:	CALL fillnm ;yes, fill name with blanks
	POP AF ;restore cc'S
	SCF ;flag "." seen
	PUSH AF ;save cc'S BACK
	JP filinx ;yes, ignore "."
fillo1:
	LD (BC),A ;copy char
	INC BC
	INC HL
	DEC D ;decrment possible count of chars
	JP NZ,fillop
gotnam:
	XOR A ;clear extent field
	LD (filnm12),A ;5.21: filnam+12
	POP AF ;restore condition codes
	POP HL ;get back text pointer
	RET

fillnm:	LD A,D ;get # of chars
	CP 11+8*0-2*0 ;initial position?
	JP Z,nmflcl ;dont allow null filename
	CP 3 ;filled field?
	JP C,nmflcl ;no, but 2nd "."
	RET Z ;yes, back to loop
filln1:	LD A,' ' ;fill with space
	LD (BC),A
	INC BC
	DEC D
	JP fillnm
filspc:	INC D ;chars left in file buffer
	DEC D ;test
	JP Z,gotnam ;no
filsp2:	LD A,' ' ;space
	LD (BC),A ;store
	INC BC
	DEC D ;filled whole field?
	JP NZ,filsp2 ;no, more spaces
	JP gotnam ;yes, make sure name ok
nmflcl:	JP dernmf ;5.21: local stub for error jumps
	page
name::
	CALL namfil ;pick up the old name to use
	PUSH HL ;save the text pointer
	LD DE,dirtmp ;read directory in here
	LD C,c.buff ;set buffer address
	CALL cpment ;call cp/m
	LD DE,filnam ;see if original name exists
	LD C,c.open ;by opening
	CALL cpment ;call cp/m
	INC A ;does it exist?
	JP Z,derfnf ;file not found
	LD HL,filna2 ;save file name in filna2
	LD DE,filnam
	LD B,12+3*0-2*0+2*0+3*0-3*0 ;set [c]=max file name length
namrmv:	LD A,(DE) ;get byte from file
	LD (HL),A ;save byte in "OLD" file name
	INC HL ;bump pointers
	INC DE
	DEC B
	JP NZ,namrmv
	POP HL ;get the text pointer back
	CALL synchr
	db	'A' ;make sure "AS" is there
	CALL synchr
	db	'S' ;
	CALL namfil ;read the new name
	PUSH HL ;save the text pointer
	LD A,(filnam) ;get disk # of file name
	LD HL,filna2 ;point to orig file
	CP (HL) ;compare
	JP NZ,fcerr ;disks must be the same
	LD DE,filnam ;see if original name exists
	LD C,c.open ;by opening
	CALL cpment ;call cp/m
	INC A ;does it exist?
	JP NZ,derfae ;yes
	LD C,c.rena ;rename operation
	LD DE,filna2 ;point at old name fcb
	CALL cpment ;call cpm
;	inr	a		;file found?
;****dont check error return, cp/m has problems****
;	jz	derfnf		;no
	POP HL ;restore text pointer
	RET



	subttl	open statement and all directory handling

open::	LD BC,finprt ;zero ptrfil when done
	PUSH BC
	CALL frmevl ;read the file mode
	PUSH HL ;save the text pointer
	CALL frestr ;free string temp & check string
	LD A,(HL) ;make sure its not a null string
	OR A
	JP Z,derbfm ;if so, "BAD FILE MODE"
	INC HL
	LD C,(HL) ;[b,c] point at mode character
	INC HL
	LD B,(HL)
	LD A,(BC) ;[a]=mode character
	AND 337o ;force to upper case (0DFH)
	LD D,md.sqo ;assume its "O"
	CP 'O' ;is it?
	JP Z,havmod ;[d] has correct mode
	LD D,md.sqi ;assume sequential
	CP 'I' ;is it?
	JP Z,havmod ;[d] says sequential input
	LD D,md.rnd ;must be random
	CP 'R'
	JP NZ,derbfm ;if not, no match so "BAD FILE MODE"
havmod:	POP HL ;get back the text pointer
	CALL synchr
	db	44 ;skip comma before file number
	PUSH DE ;save the file mode
	CP '#' ;skip a possible "#"
	CALL Z,chrgtr
	CALL getbyt ;read the file number
	CALL synchr
	db	44 ;skip comma before name
	LD A,E ;[a]=file number
	OR A ;make sure file wasn'T ZERO
	JP Z,derbfn ;if so, "BAD FILE NUMBER"
	POP DE ;get back file mode
prgfil:	LD E,A ;save file number in [e]
	PUSH DE ;save the mode in [d]
					;since program file [a]=0
	CALL filidx ;[b,c] point at file data block
	JP NZ,derfao ;if non zero mode, "FILE ALREADY OPEN"
	POP DE ;[d]=file mode
	PUSH BC ;save pointer at file data block
	PUSH DE ;save back file mode and number
	CALL namfil ;read the name
	POP DE ;restore file number
	POP BC ;get back file data block pointer
	PUSH BC ;save back
	PUSH AF ;save extension flag
	LD A,D ;5.21: get file mode from D
	CALL varecs ;scan record length field
	POP AF ;get back extension flag
	LD (temp),HL ;save the text pointer for a while
	JP C,prgdot ;if "." seen, dont default extension
	LD A,E ;get file number
	OR A ;set condition codes
	JP NZ,prgdot ;not file 0, dont default file name
	LD HL,filnm9 ;5.21: point to first char of extension (filnam+9)
	LD A,(HL) ;get it
	CP ' ' ;blank extension
	JP NZ,prgdot ;non-blank extension, dont use default
	LD (HL),'B' ;set default extension
	INC HL
	LD (HL),'A'
	INC HL
	LD (HL),'S' ;set ".BAS"
					;bascom
prgdot:	POP HL ;[h,l]=pointer at file data block
	LD A,D ;5.21: save mode
	PUSH AF ;5.21: save on stack
	LD (ptrfil),HL ;setup as current file
	PUSH HL ;save back file data block pointer
	INC HL ;point to fcb entry
	LD DE,filnam ;get pointer to scanned file name
	LD C,12+0+0*3+2*0+3*0 ;number of bytes to copy
opnlp:	LD A,(DE) ;get byte from filnam
	LD (HL),A ;store in file data block
	INC DE
	INC HL
	DEC C ;decrment count of bytes to move
	JP NZ,opnlp ;keep looping

;	open file
;
;	((sp)) points to file data block
;	((sp)+2) contains the file mode - dmc!x3200!r2e

	XOR A ;5.21: clear A first
	LD (HL),A ;make sure extent field is zero
	LD DE,0+20 ;point to nr field
	ADD HL,DE
	LD (HL),A ;set to zero (A already 0)
	POP DE ;get pointer to file data block back in [d]
	PUSH DE ;save again for later
	INC DE
	CALL setbuf ;set buffer address
	POP HL ;get back file data block ptr
	POP AF ;5.21: get mode from stack
	PUSH AF ;5.21: save it back
	PUSH HL ;save back
	CP md.sqo ;seqential output?
	JP NZ,opnfil ;no, do cpm open call
	PUSH DE ;save fcb pointer
	LD C,c.dele ;delete existing output file, if any
	CALL cpment ;call cp/m
	POP DE ;restore fcb pointer
makfil:	LD C,c.make ;create file
	CALL cpment ;call cpm
	INC A ;test for too many files
	JP Z,dertmf ;that was the case
	JP opnset ;finish setup of file data block
opnfil:	LD C,c.open ;cpm code for open
	CALL cpment ;call cpm
	INC A ;file not found
	JP NZ,opnset ;found
	POP DE ;get back file pointer
	POP AF ;5.21: get mode from stack
	PUSH AF ;5.21: save it back
	PUSH DE ;save back
	CP md.rnd ;random?
	JP NZ,derfnf ;no, seqential input, file not found
	INC DE ;make [d,e]=fcb pointer
	JP makfil ;make file

;	((sp)) points to file data block
;	((sp)+2) contains the file mode - dmc!x3200!r2e

opnset:	POP DE ;point to file info
	POP AF ;5.21: get mode from stack
	LD (DE),A ;5.21: store mode in file block
	PUSH DE ;save pointer back
	LD HL,0+locofs ;point to curloc
	ADD HL,DE
	XOR A ;zero curloc in case this file
					;was just killed
	LD (HL),A
	INC HL
	LD (HL),A
	INC HL
	LD (HL),A ;zero number of bytes in the buffer
	INC HL
	LD (HL),A ;zero print position
	POP HL ;get pointer at mode
	LD A,(HL) ;see what has to be done
	CP md.rnd ;is it random mode?
	JP Z,rndfin ;yes random finish up
	CP md.sqi ;if sequential all that is left to do
	JP NZ,gtmprt ;fetch text pointer and done

;
; finish up sequential input after finding file
;
	CALL read2 ;read first data block
opn000:
	LD HL,(temp) ;get back the text pointer
	RET

rndfin:	LD BC,0+datofs ;now advance pointer to data
	ADD HL,BC ;by adding proper offset
	LD C,datpsc ;# of bytes to zero
zrrndt:	LD (HL),B
	INC HL
	DEC C
	JP NZ,zrrndt
	JP gtmprt ;get text pointer

	subttl	system (exit) command - return to cpm (or exit to os)

system:
	RET NZ ;should terminate
	CALL clsall ;close all data files
systme:	JP cpmwrm ;warm start cp/m
					;bascom

	subttl	reset command - force directory re-read on all disks

reset:	RET NZ ;should terminate
	PUSH HL ;save text pointer
	CALL clsall ;close all files
	LD C,c.gdrv ;get drive currently selected
	CALL cpment ;get it in [a]
	PUSH AF ;save current drive #
	LD C,c.rest ;do the reset call
	CALL cpment
	POP AF ;get drive to select
	LD E,A ;into [e]
	LD C,c.sdrv ;set drive
	CALL cpment ;call cpm
	POP HL ;restore text pointer
	RET

	subttl	kill command

kill::
	CALL namfil ;scan file name
	PUSH HL ;save text pointer
	LD DE,dirtmp ;read directory in here
	LD C,c.buff ;set buffer address
	CALL cpment ;for cp/m
	LD DE,filnam ;try to open file
	PUSH DE ;save fcb pointer
	LD C,c.open
	CALL cpment
	INC A ;file found?
	POP DE ;get back pointer to fcb
	PUSH DE ;save back
	PUSH AF ;save found flag
	LD C,c.clos ;this may not be nesc.
	JP Z,kilpop ;5.21: skip close if not found
	CALL cpment ;close file
kilpop:	POP AF ;restore found indicator
	POP DE ;restore fcb pointer
	JP Z,derfnf ;yes
	LD C,c.dele ;code for delete
	CALL cpment ;call cpm
	POP HL ;get back text pointer
	RET

	subttl	files command - list the directory

; this is the files[<filename>] command
; which prints the files which match the <filename> wildcard specifier
; if <filename> is omitted, all the files on the currently selected drive
; are listed
files:
	JP NZ,filnb ;file name was specified
	PUSH HL ;save text pointer
	LD HL,filnam ;point to file name
	LD (HL),0 ;set current drive
	INC HL ;bump pointer
	LD C,11+8*0 ;match all files
	CALL filqst ;set file name and extension to question marks
	POP HL ;restore text pointer
filnb:	CALL NZ,namfil ;scan file name
	XOR A ;make sure extent is zero
	LD (filnm12),A ;5.21: filnam+12
	PUSH HL ;save text pointer
	LD HL,filnm1 ;5.21: get first char of file name (filnam+1)
	LD C,8 ;fill name with question marks
	CALL filqs
	LD HL,filnm9 ;5.21: point to extension (filnam+9)
	LD C,3 ;3 chars in extension
	CALL filqs ;fill it with qmarks
	LD DE,dirtmp ;set buffer to 80 hex
	LD C,c.buff
	CALL cpment
	LD DE,filnam ;point to fcb
	LD C,c.sear ;do initial search for file
	CALL cpment ;call cp/m
	CP 255 ;find first incarnation of file
	JP Z,derfnf ;no
filnxt:	AND 3 ;mask off low two bits
	ADD A ;multiply by 32
	ADD A
	ADD A
	ADD A
	ADD A
	LD C,A ;put offset in [b,c]
	LD B,0
	LD HL,dirtmp+1 ;point to directory buffer
	ADD HL,BC ;point to fcb entry in directory
	LD C,11+5*0+11*0 ;chars in name
mornam:	LD A,(HL) ;get file name char
	INC HL ;bump pointer
	CALL outdo ;print it
	LD A,C ;get  char posit
	CP 4+5*0 ;about to print extension?
	JP NZ,notext ;no
	LD A,(HL) ;get first char of extension
	CP ' ' ;if so, not space
	JP Z,prispa ;print space
	LD A,'.' ;print dot
prispa:	CALL outdo
notext:	DEC C ;decrement char count
	JP NZ,mornam ;more of name to print
	LD A,(ttypos) ;get current tty posit
	ADD 13+6*0+9*0+2*0 ;space for next name?
	LD D,A ;save in d
	LD A,(linlen) ;get length of terminal line
	CP D ;compre to current posit
	JP C,nwfiln ;need to force crlf
	LD A,' ' ;two spaces between file names
	CALL outdo
	CALL outdo
					;or three
nwfiln:
	CALL C,crdo ;type crlf
	LD DE,filnam ;point at fcb
	LD C,c.sear+1 ;search for next entry
	CALL cpment ;search for next incarnation
	CP 255 ;no more?
	JP NZ,filnxt ;more.
nwfil2:
	POP HL ;restore text pointer
	RET

filqs:	LD A,(HL) ;get char
	CP '*' ;wild card?
	RET NZ ;no, return
filqst:	LD (HL),'?' ;store question mark
	INC HL ;bump pointer
	DEC C ;decrement count of qmarks
	JP NZ,filqst ;keep saving qmarks
	RET
					;final cr/lf
					;swfil

	subttl	dskf function


	subttl	miscellaneous operating system i/o

accfil:	PUSH DE ;save fcb address
	LD C,A
	PUSH BC
	CALL cpment
	POP BC
	POP DE
	PUSH AF
	LD HL,0+fcb.rn ;point to random record number
	ADD HL,DE
	INC (HL)
	JP NZ,accfl1
	INC HL
	INC (HL)
	JP NZ,accfl1
	INC HL
	INC (HL)
accfl1:	LD A,C ;get back cpm call code
	CP 34 ;is it random write/
	JP NZ,accfl2 ;no

	POP AF ;get error code and map into 1.4 errors
	OR A
	RET Z
	CP 5
	JP Z,dertmf ;too many files
	CP 3
	LD A,1 ;turn into i/o error
	RET Z
	INC A ;default to disk space full (2)
	RET

accfl2:	POP AF
	RET



	subttl	bascom o.s. dependent data areas



;======================================================================
; Module: fivdsk.mac
;======================================================================

	page
	title	fivdsk 5.0 features - variable length records, protected files /p. allen
	.sall

;
;the 5.0 disk code is essentially an extra level of buffering
;for random disk i/o files. sequential i/o is not
;affected by the 5.0 code. great care has been taken to
;insure compatibility with existing code to support diverse
;operating systems. the 5.0 disk code has its
;own data structure for handling the variable length
;records in random files. this data structure sits right after
;the regular data block for the file and consumes an amount of 
;memory equal to  maxrec (the maximum allowed record size) plus
;9 bytes.
;
;here is the content of the data block:
;
;fd.siz size 2			;variable length record size default 128
;fd.phy size 2			;current physical record #
;fd.log size 2			;current logical record number
;fd.chg size 1			;future flag for accross block prints etc.
;fd.ops size 2			;output print position for print, input, write
;fd.dat size fd.zsiz		;actual field data buffer
;				;size is fd.siz bytes long
;
;date				fix
;----				---
;8/6/179				make put, get increment loc correctly
;8/14/1979			puuut in basic cococompiler switch (main source)
;%
	page
	subttl	varecs - variable record scan for open

;	enter varecs with file mode in [a]

varecs:	CP md.rnd ;random?
	RET NZ ;no, give error later if he gave record length
	DEC HL ;back up pointer
	CALL chrgtr ;test for eol
	PUSH DE ;save [d,e]
	LD DE,0+datpsc ;assume record length=datpsc
	JP Z,notsep ;no other params for open
	PUSH BC ;save file data block pointer
	CALL intidx ;get record length
	POP BC ;get back file data block
notsep:	PUSH HL ;save text pointer
	LD HL,(maxrec) ;is size ok?
	CALL dcompr
	JP C,fcerr ;no, give error
	LD HL,0+fd.siz ;stuff into data block
	ADD HL,BC
	LD (HL),E
	INC HL
	LD (HL),D
	XOR A ;clear other bytes in data block
	LD E,7 ;# of bytes to clear
zofivb:	INC HL ;increment pointer
	LD (HL),A ;clear byte
	DEC E ;count down
	JP NZ,zofivb ;go back for more
	POP HL ;text pointer 
	POP DE ;restore [d,e]
	RET
	page
	subttl	put and get statements

put:	db	366o ;"ORI"to set non-zero flag
get:	XOR A ;set zero
	LD (pgtflg),A ;save flag
	CALL filscn ;get pointer at file data block
	CP md.rnd ;must be a random file
	JP NZ,derbfm ;if not, "Bad file mode"
	PUSH BC ;save pointer at file data block
	PUSH HL ;save text pointer
	LD HL,0+fd.log ;fetch current logical posit
	ADD HL,BC
	LD E,(HL)
	INC HL
	LD D,(HL)
	INC DE ;compensate for "DCX D" when call intidx
	EX (SP),HL ;save data block pointer and get text pointer
	LD A,(HL)
	CP 44 ;is there a record number
	CALL Z,intidx ;read it if there, 1-indexed
	DEC HL ;make sure statement ends
	CALL chrgtr
	JP NZ,snerr
	EX (SP),HL ;save text pointer, get data block pointer
	LD A,D ;5.21: test high byte first
	OR E ;make sure its not zero
	JP Z,derbrn ;if so, "Bad record number"
	DEC HL
	LD (HL),E
	INC HL
	LD (HL),D
	DEC DE
	POP HL ;get back text pointer 
	POP BC
	PUSH HL ;save back text pointer 
	PUSH BC ;pointer to file data block
	LD HL,0+fd.ops ;zero output file posit
	ADD HL,BC
	XOR A
	LD (HL),A
	INC HL
	LD (HL),A
	LD HL,0+fd.siz ;get logical record size in [d,e]
	ADD HL,BC
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	EX DE,HL ;record size to [d,e], posit in [h,l]
	PUSH DE ;save record size (count of bytes)
; record size in [d,e]
; logical position in [h,l]
; this code computes physical record # in [h,l]
; offset into buffer in [d,e]
	PUSH HL ;save logical posit
	LD HL,0+datpsc ;get sector size
	CALL dcompr ;compare the two
	POP HL ;restore logical posit
	JP NZ,ntlsap ;if record size=sector size, done
	LD DE,0 ;set offset to zero
	JP donclc ;done with calculations
ntlsap:	LD B,D ;copy record size to [b,c]
	LD C,E
	LD A,20o ;16 by 16 multiply
	EX DE,HL ;put multiplier in [d,e]
	LD HL,0 ;set both parts of product to zero
	PUSH HL ;2nd part is on stack
frmul1:	ADD HL,HL
	EX (SP),HL
	JP NC,fnocry
	ADD HL,HL
	INC HL
	JP fnocy0
fnocry:	ADD HL,HL
fnocy0:	EX (SP),HL
	EX DE,HL
	ADD HL,HL ;rotate [d,e] left one
	EX DE,HL
	JP NC,fnocy2 ;add in [b,c] if ho=1
	ADD HL,BC
	EX (SP),HL
	JP NC,fnoinh
	INC HL
fnoinh:	EX (SP),HL
fnocy2:	DEC A ;are we done multiplying
	JP NZ,frmul1 ;no, go back for next bit of product
; now divide by the number of bytes in a sector
	iff	datpsc-256
	LD E,L ;remainder is just low byte
	LD D,0 ;of which ho is 0
	LD L,H ;annd record # is shifted down
	POP BC ;get most sig. byte of record #
	LD H,C ;set record # to it
	LD A,B ;make sure rest=0
	OR A
	JP NZ,fcerr
	endif ;uh-oh
	if	datpsc-128
	if	datpsc-256
	POP DE ;get high word of dividend in [d,e]
	LD BC,0 ;set dividend to zero.
kepsub:	PUSH BC ;save dividend
	LD BC,0-datpsc ;get divisor (# of bytes sector)
	ADD HL,BC ;subtract it
	JP C,guarcy ;carry from low bytes implies cary from high
	EX DE,HL ;subtract -1 from high byte
	LD BC,0-1
	ADD HL,BC
	EX DE,HL ;put result back where it belongs
guarcy:	POP BC ;restore dividend
	JP NC,dondiv ;finished
	INC BC ;add one to it
	LD A,B ;see if overflowed
	OR C
	JP NZ,kepsub ;keep at it till done
	JP fcerr ;yes give error
dondiv:	PUSH BC ;save dividend
	LD BC,0+datpsc ;correct for one too many subtraction
	ADD HL,BC ;by adding divisor back in
	POP DE ;dividend ends up in [d,e], remainder in [h,l]
	EX DE,HL
	endif
	endif ;put values in right regs for rest of code
	iff	datpsc-128
	LD A,L ;get low byte of result
	AND 127 ;get rid of high bit
	LD E,A ;this is it
	LD D,0 ;set high byte of remainder to zero
	POP BC ;get high word of product
	LD A,L ;get msb of low word
	LD L,H
	LD H,C
	ADD HL,HL ;make space for it
	JP C,fcerr ;uh-oh record # to big!
	RLA ;is it set?
	JP NC,doninh ;not set
	INC HL ;copy it into low bit
doninh:	LD A,B ;get high byte of record #
	OR A ; is it non-zero
	JP NZ,fcerr
	endif ;bad
donclc:
; at this point, record #is in [h,l]
; offset into record in [d,e]
; stack:
; count of bytes to read or write
; data block
; text pointer
; return address
	LD (record),HL ;save record size
	POP HL ;get count
	POP BC ;pointer to file data block
	PUSH HL ;save back count
	LD HL,0+fd.dat ;point to field buffer
	ADD HL,BC ;add start of data block
	LD (lbuff),HL ;save pointer to field buffer
nxtopd:	LD HL,0+datofs ;point to physical buffer
	ADD HL,BC ;add file block offset
	ADD HL,DE
	LD (pbuff),HL ;save
	POP HL ;get count
	PUSH HL ;save count
	LD HL,0+datpsc ;[h,l]=datpsc-offset
	LD A,L
	SUB E
	LD L,A
	LD A,H
	SBC D
	LD H,A
	POP DE ;get back count (destroy offset)
	PUSH DE ;save count
	CALL dcompr ;which is smaller, count or datpsc-offset?
	JP C,datmof ;the latter
	LD H,D ;copy count into bytes
	LD L,E
datmof:	LD A,(pgtflg) ;put or get
	OR A ;set cc's
	JP Z,fivdrd ;was read
	LD DE,0+datpsc ;if bytes .lt. datpsc then read(sector)
	CALL dcompr
	JP NC,nofvrd ;(idea-if writing full buffer, no need to read)
	PUSH HL ;save bytes
	CALL getsub ;read record.
	POP HL ;bytes
nofvrd:	PUSH BC
	LD B,H
	LD C,L
	EX DE,HL ;5.21: redundant xchg
	LD HL,(pbuff)
	EX DE,HL
	LD HL,(lbuff) ;get ready to move bytes between buffers
	CALL fdmov ;move bytes to physical buffer
	LD (lbuff),HL ;store updated pointer
	LD D,B ;count to [d,e]
	LD E,C
	POP BC ;restore fdb pointer
	CALL putsub ;do write
nxfvbf:	LD HL,(record) ;5.21: increment record first
	INC HL
	LD (record),HL
	POP HL ;count
	LD A,L ;make count correct
	SUB E
	LD L,A
	LD A,H
	SBC D
	LD H,A
	LD A,H ;5.21: explicit test
	OR L ;is count zero?
	LD DE,0 ;set offset=0
	PUSH HL ;save count
	JP NZ,nxtopd ;keep working on it
	POP HL ;get rid of count
	POP HL ;restore text pointer
	RET ;done

; read code
; [h,l]=bytes
; [d,e]=count
fivdrd:	PUSH HL ;save bytes
	CALL getsub ;do read
	POP HL ;get back bytes
	PUSH BC
	LD B,H
	LD C,L
	EX DE,HL ;5.21: redundant xchg
	LD HL,(lbuff) ;point to logical buffer
	EX DE,HL
	LD HL,(pbuff)
	CALL fdmov
	EX DE,HL ;get pointer to field buffer in [h,l]
	LD (lbuff),HL ;save back updated logical buffer
	LD D,B ;count to [d,e]
	LD E,C
	POP BC
	JP nxfvbf
putsub:	db	366q
getsub:	XOR A
	LD (maxtrk),A ;get/put fflag
	PUSH BC
	PUSH DE
	PUSH HL
	EX DE,HL ;5.21: redundant xchg
	LD HL,(record)
	EX DE,HL
	LD HL,0+fd.phy ;point to physical record #
	ADD HL,BC ;add offset to file buffer
	PUSH HL ;save this pointer
	LD A,(HL) ;get current phys. rec #
	INC HL
	LD H,(HL)
	LD L,A
	INC DE
	CALL dcompr ;do we already have record in buffer
	POP HL ;restore pointer
	LD (HL),E
	INC HL
	LD (HL),D ;store new record number
	JP NZ,ntreds ;curent and previos record numbers are different
	LD A,(maxtrk) ;trying to do read?
	OR A
	JP Z,subret ;if trying to read and record already
					;in buffer, do nothing
ntreds:	LD HL,subret ;where to return to
	PUSH HL
	PUSH BC ;file data block
	PUSH HL ;dummy text pointer
	LD HL,0+locofs+1 ;where [h,l] is expected to be
	ADD HL,BC
	JP fivdpt ;call old put/get
subret:	POP HL
	POP DE
	POP BC
	RET ;restore all regs and return to caller

; move bytes from [h,l] to [d,e] [b,c] times
fdmov:	PUSH BC ;save count
fdmov1:	LD A,(HL) ;get byte
	LD (DE),A ;store it
	INC HL
	INC DE
	DEC BC ;decrement count
	LD A,B ;gone to zero?
	OR C
	JP NZ,fdmov1 ;go back for more
	POP BC ;return with count in [d,e]
	RET

filofv:	POP AF ;get character off stack
	PUSH DE ;save [d,e]
	PUSH BC ;save [b,c]
	PUSH AF ;save back char
	LD B,H ;[b,c]=file data block
	LD C,L
	CALL cmpfps ;any room in buffer
	JP Z,iflcl ;5.21: no (via local stub)
	CALL setfpi ;save new position
	LD HL,0+fd.dm1 ;5.21:index into data buffer
	ADD HL,BC ;add start of file control block
	ADD HL,DE ;add offset into buffer
	POP AF ;get back char
	LD (HL),A ;store in buffer
	PUSH AF ;save char
	LD HL,0+nmlofs ;set up [h,l] to point at print posit
	ADD HL,BC
	LD D,(HL) ;get present position
	LD (HL),0 ;assume set it to zero
	CP 13 ;is it <cr>?
	JP Z,fiscr ;yes
	ADD 224 ;set carry for spaces & higher
	LD A,D ;add one to current posit
	ADC 0
	LD (HL),A
fiscr:	POP AF ;restore all regs
	POP BC
	POP DE
	POP HL
	RET
iflcl:	JP derfov ;5.21: local stub for error
filifv:	PUSH DE ;save [d,e]
	CALL cmpfbc ;compare to present posit
	JP Z,iflcl ;return with null 
	CALL setfpi ;set new position
	LD HL,0+fd.dm1 ;5.21:point to data
	ADD HL,BC
	ADD HL,DE
	LD A,(HL) ;get the byte
	OR A ;clear carry (no eof)
	POP DE ;restore [d,e]
	POP HL ;restore [h,l]
	POP BC ;restore [b,c]
	RET

getfsz:	LD HL,0+fd.siz ;point to record size
	JP getfp1 ;continue
getfps:	LD HL,0+fd.ops ;point to output position
getfp1:	ADD HL,BC ;add offset into buffer
	LD E,(HL) ;get value
	INC HL
	LD D,(HL)
	RET

setfpi:	INC DE ;increment current posit
setfps:	LD HL,0+fd.ops ;point to output position
	ADD HL,BC ;add file control block address
	LD (HL),E
	INC HL
	LD (HL),D
	RET
cmpfbc:	LD B,H ;copy file data block into [b,c]
	LD C,L
cmpfps:	CALL getfps ;get present posit
	PUSH DE ;save it
	CALL getfsz ;get file size
	EX DE,HL ;into [h,l]
	POP DE ;get back posit
	CALL dcompr ;see if were at end
	RET

	page
	subttl	protected files

prosav:	CALL chrgtr ;get char after "S"
	LD (temp),HL ;save text pointer
	CALL sccptr ;get rid of goto pointers
	CALL pencod ;encode binary
	LD A,254 ;put out 254 at start of file
	CALL binpsv ;do save
	CALL pdecod ;re-decode binary
	JP gtmprt ;back to newstt

n1	set	11 ;number of bytes to use from atncon
n2	set	13 ;number of bytes to use from sincon
pencod:	LD BC,0+n1+n2*256 ;initialize both counters
	LD HL,(txttab) ;starting point
	EX DE,HL ;into [d,e]
encdbl:	LD HL,(vartab) ;at end?
	CALL dcompr ;test
	RET Z ;yes
	LD HL,atncon ;point to first scramble table
	LD A,L ;use [c] to index into it
	ADD C
	LD L,A
	LD A,H
	ADC 0
	LD H,A
	LD A,(DE) ;get byte from program
	SUB B ;subtract counter for no reason
	XOR (HL) ;xor entry
	PUSH AF ;save result
	LD HL,sincon ;calculate offset into sincon using [b]
	LD A,L
	ADD B
	LD L,A
	LD A,H
	ADC 0
	LD H,A
	POP AF ;get back current byte
	XOR (HL) ;xor on this one too
	ADD C ;add counter for randomness
	LD (DE),A ;store back in program
	INC DE ;incrment pointer
	DEC C ;decrment first table index
	JP NZ,cntzer ;still non-zero
	LD C,n1 ;re-initialize counter 1
cntzer:	DEC B ;dedecrement counter-2
	JP NZ,encdbl ;still non-zero, go for more
	LD B,n2 ;re-initialize counter 2
	JP encdbl ;keep going until done
prolod:
pdecod:	LD BC,0+n1+n2*256 ;initialize both counters
	LD HL,(txttab) ;starting point
	EX DE,HL ;into [d,e]
decdbl:	LD HL,(vartab) ;at end?
	CALL dcompr ;test
	RET Z ;yes
	LD HL,sincon ;calculate offset into sincon using [b]
	LD A,L
	ADD B
	LD L,A
	LD A,H
	ADC 0
	LD H,A
	LD A,(DE) ;get byte from program
	SUB C ;subtract counter for randomness
	XOR (HL) ;xor on this one too
	PUSH AF ;save result
	LD HL,atncon ;point to first scramble table
	LD A,L ;use [c] to index into it
	ADD C
	LD L,A
	LD A,H
	ADC 0
	LD H,A
	POP AF ;get back current byte
	XOR (HL) ;xor entry
	ADD B ;add counter for no reason
	LD (DE),A ;store back in program
	INC DE ;increment pointer
	DEC C ;decrment first table index
	JP NZ,cntzr2 ;still non-zero
	LD C,n1 ;re-initialize counter 1
cntzr2:	DEC B
	JP NZ,decdbl ;decrement counter-2, still non-zero, go for more
	LD B,n2 ;re-initialize counter 2
	JP decdbl ;keep going until done

prodir:	PUSH HL ;save [h,l]
	LD HL,(curlin) ;get current line #
	LD A,H ;direct?
	AND L
	POP HL ;restore [h,l]
	INC A ;if a=0, direct
	RET NZ
prochk:	PUSH AF ;save flags
	LD A,(proflg) ;is this a protected file?
	OR A ;set cc's
	JP NZ,fcerr ;yes, give error
	POP AF ;restore flags
	RET

tempb:;used by field
record:	ds	2 ;record #
lbuff:	ds	2 ;logical buffer address
pbuff:	ds	2 ;physical buffer address
pgtflg:	ds	1 ;put/get flag (non zero=put)


;======================================================================
; Module: init.mac
;======================================================================

	page
	title	init initailization for basic 8080/z80 gates/allen/davidoff
swtchr	set	57o ;default switch character is slash

	page
	subttl	system initialization code
;this is the system initialization code
;it should be loaded at the end of the basic
;interpreter

initsa:
	CALL nodsks
	LD HL,(txttab)
	DEC HL
	LD (HL),0
	LD HL,(temp8) ;point to start of command line
	LD A,(HL) ;get byte pointed to
	OR A ;if zero, no file seen
	JP NZ,lrun ;try to run file
	JP ready
endio:	ds	2
init:
	LD HL,stk3f ;5.21: set up temp stack (tstack+63)
	LD SP,HL
	XOR A ;initialize protect flag
	LD (proflg),A
	LD (topmem),HL
	LD SP,HL ;5.21: set stack to topmem
	LD HL,cpmwri+1 ;5.21: point past cpmwri
	LD (HL),':' ;5.21: store terminator
	CALL stkini ;5.21: initialize stack
	LD (ttypos),A ;5.21: A is still 0
	LD (savstk),HL ;we restore stack when errors
	LD HL,(1) ;5.21: get BDOS address
	LD BC,0+4 ;csts
	ADD HL,BC ;add four
	LD E,(HL) ;pick up csts address
	INC HL
	LD D,(HL)
	EX DE,HL ;get csts address
	LD (const3+1),HL ;third control-c check
	LD (consts+1),HL ;save
	LD (const2+1),HL ;fast control-c check
	EX DE,HL ;pointer back to [h,l]
	INC HL ;point at ci address
	INC HL
	LD E,(HL) ;get low byte of ci address
	INC HL
	LD D,(HL) ;get high byte
	EX DE,HL ;input address to [h,l]
	LD (conin+1),HL ;save in console input call
	EX DE,HL ;pointer back to [h,l]
	INC HL ;skip "JMP" opcode
	INC HL ;bump pointer
	LD E,(HL) ;get output routine address
	INC HL
	LD D,(HL)
	EX DE,HL ;into [h,l]
	LD (conout+1),HL ;save into output routine
	EX DE,HL ;pointer back to [h,l]
	INC HL ;now point to printer output
	INC HL ;routine address
	LD E,(HL) ;pick it up
	INC HL
	LD D,(HL)
	EX DE,HL ;get address into [d,e]
	LD (lptout+1),HL ;set print routine address

;	check cp/m version number


	LD C,12 ;version test
	CALL cpment
	LD (cpmvrn),A ;[a] = version number (0 = 1.x)
	OR A ;test version number
	LD HL,21*256+20+0 ;1.x read / write
	JP Z,cpmvr1
	LD HL,34*256+33+0 ;2.x read / write
cpmvr1:	LD (cpmrea),HL ;save read/write codes
	LD HL,0+65534 ;say initialization is executing
	LD (curlin),HL ;in case of error message
	XOR A
	LD (cntofl),A
	LD (endbuf),A ;make sure overruns stop
	LD (chnflg),A ;make sure chains and merges
	LD (mrgflg),A ;dont try to happen
	LD (errflg),A ;don'T ALLOW EDIT TO BE CALLED ON ERRORS
	LD HL,0 ;get 0
	LD (lptpos),HL ;zero flag and position
	LD HL,0+128 ;default max rec size
	LD (maxrec),HL
	LD HL,tempst
	LD (temppt),HL
	LD HL,prmstk ;initialize parameter block chain
	LD (prmprv),HL
	LD HL,(cpment+1) ;get last loc in memory
	LD (memsiz),HL ;use as default
;
;
; the following code scans a cp/m command line for basic.
; the format of the command is:
;
; basic <file name>[/m:<topmem>][/f:<files>]
;
;*
	LD A,3 ;default files
	LD (maxfil),A ;by setting maxfil=3
	LD HL,zerob ;point at zero byte
	LD (temp8),HL ;so if re-initailize ok
	LD A,(comagn) ;have we already read command line
	OR A ;and got error?
	JP NZ,errcmd ;then default
	INC A ;make non-zero
	LD (comagn),A ;store back non-zero for next time
tbuff	set	cpmwrm+128 ;where cp/m command buffer is located

	LD HL,tbuff ;point to first char of command buffer
	LD A,(HL) ;which contains # of chars in command
	OR A ;is there a command?
	LD (temp8),HL ;save pointer to this zero
	JP Z,doncmd ;nothing in command buffer
	LD B,(HL) ;and [b]
	INC HL ;point to first char in buffer
tbflp:	LD A,(HL) ;get char from buffer
	DEC HL ;back up pointer
	LD (HL),A ;store char back
	INC HL ;now advance char to one place
	INC HL ;after previous posit.
	DEC B ;decrement count of chars to move
	JP NZ,tbflp ;keep moving chars
	DEC HL ;back up pointer
endcmd:	LD (HL),0 ;store terminator for chrget (0)
	LD (temp8),HL ;save pointer to new zero (old destroyed)
	LD HL,tbuff-1 ;point to char before buffer
	CALL chrgtr ;ignore leading spaces
	OR A
	JP Z,doncmd ;end of command
	CP swtchr ;is it a slash
	JP Z,fndslh ;yes
	DEC HL ;back up pointer
	LD (HL),34 ;store double quote
	LD (temp8),HL ;save pointer to start of file name
	INC HL ;bump pointer
isslh:	CP swtchr ;option?
	JP Z,fndslh ;yes
	CALL chrgtr ;skip over char in file name
	OR A ;set cc'S
	JP NZ,isslh ;keep looking for option
	JP doncmd ;thats eit
fndslh:	LD (HL),0 ;store terminator over "/"
scansw:	CALL chrgtr ;get char after slash
scns1a:	CALL makupl ;5.21: convert to uppercase (jump here to skip chrgtr)
scans1:
	CP 'S' ;is it /s: ? (set max record size)
	JP Z,wass ;yes
	CP 'M' ;memory option
	PUSH AF ;save indicator
	JP Z,wasm ;was memory option
	CP 'F' ;files option
	JP NZ,snerr ;not "M" or "F" error
wasm:	CALL chrgtr ;get next char
	CALL synchr
	db	':' ;colon should follow
	CALL cnsget ;get value following colon
	POP AF ;get back m/f flag
	JP Z,mem ;was memory option
	LD A,D ;files cant be .gt. 255
	OR A ;set cc'S
	JP NZ,fcerr ;function call error
	LD A,E ;get low byte
	CP 16 ;must be .lt. 16
	JP NC,fcerr
	LD (maxfil),A ;store in # of files
	JP fok ;done
mem:	EX DE,HL ;put value in [d,e]
	LD (memsiz),HL ;save into memsize
	EX DE,HL ;get back text pointer
fok:	DEC HL ;rescan last char
	CALL chrgtr ;by calling chrget
	JP Z,doncmd ;end of command
	CALL synchr
	db	swtchr ;slash should follow
	JP scns1a ;5.21: scan next switch (include makupl)
wass:	CALL chrgtr ;get char after "S"
	CALL synchr
	db	':' ;make sure colon follows
	CALL cnsget ;get value following colon
	EX DE,HL ;save it
	LD (maxrec),HL
	EX DE,HL
	JP fok ;continue scanning
zerob:	db	0 ;zero byte
comagn:	db	0 ;we havent scanned command yet
errcmd:
doncmd:
askmem:
usedef:	DEC HL
	LD HL,(memsiz) ;get size of memory
	DEC HL ;5.21: always leave top byte unused because
					;val(string) makes byte in memory
					;beyond last char of string=0
	LD (memsiz),HL ;save in real memory size
	DEC HL ;one lower is stktop
	PUSH HL ;save it on stack



					;keep all functions

;
; disk initialization routine
; setup  file info blocks
; the number of each and information for
; getting to pointers to each is stored. no locations are
; initialized, this is done by nodsks, first closing all files.
; the number of files is the file pointer table
;
dskdat	set	endio ;start data after all code
asksk:
	LD A,(maxfil) ;get highest file #
	LD HL,dskdat ;get start of memory
	LD (filpt1),HL
	LD DE,filptr ;point to table to set up
	LD (maxfil),A ;remember how many files
	INC A ;always file 0 for internal use
	LD BC,dblk.c ;size of a file info block plus $code
lopflb:	EX DE,HL ;[h,l] point into pointer block
	LD (HL),E ;store the pointer at this file
	INC HL
	LD (HL),D
	INC HL
	EX DE,HL
	ADD HL,BC ;[h,l] point to next info block
	PUSH HL ;save [h,l]
	LD HL,(maxrec) ;get max record size
	LD BC,fnzblk ;get size of other stuff
	ADD HL,BC
	LD B,H
	LD C,L ;result to [b,c]
	POP HL ;restore [h,l]
	DEC A ;are there more?
	JP NZ,lopflb
havfns:;text always preceded by zero
					;store it
	INC HL ;increment pointer
	LD (txttab),HL ;save bottom of memory
	LD (savstk),HL ;we restore stack when errors
	POP DE ;get  current memsiz
	LD A,E ;calc total free/8
	SUB L
	LD L,A
	LD A,D
	SBC H
	LD H,A
	JP C,omerr
	LD B,3 ;divide by 2 three times
shflf3:	OR A
	LD A,H
	RRA
	LD H,A
	LD A,L
	RRA
	LD L,A
	DEC B
	JP NZ,shflf3
	LD A,H ;see how much
	CP 2 ;if less than 512 use 1 eighth
	JP C,smlstk
	LD HL,0+512
smlstk:	LD A,E ;subtract stack size from top mem
	SUB L
	LD L,A
	LD A,D
	SBC H
	LD H,A
	JP C,omerr
	LD (memsiz),HL
	EX DE,HL
	LD (topmem),HL
	LD (fretop),HL ;reason uses this...
	LD SP,HL ;set up new stack
	LD (savstk),HL
	LD HL,(txttab)
	EX DE,HL
	CALL reason
	LD A,L ;subtract memsiz-txttab
	SUB E
	LD L,A
	LD A,H
	SBC D
	LD H,A
	DEC HL ;since two zeros exist between
	DEC HL ;txttab and strend, adjust
	PUSH HL ;save number of bytes to print
	LD HL,heding ;get heading ("BASIC VERSION...")
	CALL strout ;print it
	POP HL ;restore number of bytes to print
	CALL linprt ;print # of bytes free
	LD HL,words ;type the heading
	CALL strout ;"BYTES FREE"
	LD HL,strout
	LD (repini+1),HL
	CALL crdo ;print carriage return
	LD HL,readyr
	JP initsa


auttxt:	db	13
	db	10
	db	10
	dc	'Owned by Microsoft'
	db	13
	db	10
	db	0


words:	dc	' Bytes free'
	db	0
heding:
	dc	'BASIC-80 Rev. 5.21'
	db	13
	db	10
	dc	'[CP/M Version]'
	db	13
	db	10
	dc	'Copyright 1977-1981 (C) by Microsoft'
	db	13,10
	dc	'Created: 28-Jul-81'
	db	13,10
	db	0
lastwr::;last word of system code+1
	ds	7 ;space for temp stack (5.21 uses only 7 bytes)
tstack:
stk3f	equ	tstack+63 ;5.21: for initial stack pointer
stk40	equ	tstack+64 ;for txttab initial value
stka3	equ	tstack+163 ;for topmem initial value
					;make sure last word punched is ok

;======================================================================
; End of concatenated source
;======================================================================

	end	start
