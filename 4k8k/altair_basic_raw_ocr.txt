
============================================================
Page 1
============================================================
alrair S800 basic

c REPERENCE MANUAL

Cowsis, nine. ig?7
Reprinted July, 1977.

4 subsidiary of Pertac Camputar Carporation

2450 Aiamo $.€. /Albuquerque. New Mexico 87106 :


============================================================
Page 2
============================================================

============================================================
Page 3
============================================================
BASIC Reference Manual
Addenda, Aprii, 1977
Page 33, sub-paragraph b:
LINE INPUT ["<prompt string>'',]; <string variable name>

CHANGE TO:

LINE INPUT ["<prompt string>";] <string variable>

Page 40, Paragraph S~3b, line 9:

The of the <integer expression> is the starting address of .

CHANGE TO:

The <integer expression> is the starting address of . . .

Page 41. Insert the following paragraphs between Paragraphs 3 and 4.
ADDITION:

The string returned by a call to USR with a string argument is that
string the user's routine sets up in the descriptor. Modifying [D,E] does
not affect the returned string. Therefore, the statement:

C$eUSR(A$)

results in A$ also being set to the string assigned to C$. To avoid
modifying A$ in this statement, we would use:

C$=USR(AS+"" '}

50 that the user's routine modifies the descriptor of a string temporary
instead of the descriptor for A$,

A string returned by a user's routine should be completely within
the bounds of the storage area used by the original string. Increasing
a string's length in a user routine is guaranteed to cause problems.

Page 49, last paragraph, line 7:

. leading $ signs, nor can negative numbers be output unless the sign
is forced to be trailing.

CHANGE TO:

- . + leading $ signs.

============================================================
Page 4
============================================================

============================================================
Page 5
============================================================
10,

BASIC Reference Manual Addenda, April, 1977
Page 2

Page 59, last line:
520 CLOSE #1
CHANGE TO:
520 CLOSE 1
Page 70, CLEAR [<expression>] explanation:
Same as CLEAR but sets string space to the value...
CHANGE TO;
Same as CLEAR but sets string space (see 4-1) to the value. .
Page 70, CLOAD <string expression> explanation, second line:
. . . character of STRING expression> to be. . .

CHANGE TO:

+ + « Character of <STRING expression> to be...

Page 71:

CSAVE*<array name> 8K (cassette), Disk

CHANGE TO:

CSAVE*<array name> 8K (cassette), Extended, Disk

Page 75. Insert the following after LET and before LPRINT.

ADDITION:
LINE INPUT LINE INPUT "prompt string’; string variable name

Extended, Disk

LINE INPUT prints the prompt string on the terminal and assigns all
input from the end of the prompt string to the carriage return to
the named string variable. No other prompt is printed if the prompt
string is omitted. LINE INPUT may not be edited by Control/A.

Page 76, POKE explanation, second line:

. . . If I is negative, address is 65535+T, ...

CHANGE TO:

. If I is negative, address is 655364I, . .

============================================================
Page 6
============================================================

============================================================
Page 7
============================================================
li.

12.

13.

14.

15.

16.

17.

BASIC Reference Manual Addenda, April, 1977

Page 3
Page 80, OCT$:
OCT$ OCTS$ (X) 8K, Extended, Disk
CHANGE TO:
OCT$ ocT$ (xX) Extended, Disk
Page 81:
SPACE$ SPACE${I) 8K, Extended, Disk
CHANGE TO: .
SPACE$ SPACE$ (I) Extended, Disk

Page 91, line 4:
+ « + Question (see Appendix £).
CHANGE TO:
+ « « question (see Appendix H).
Page 95, first paragraph, line 3:

. For instructions on loading Disk BASIC, see Appendix E.
CHANGE TO:

. « For instructions on loading Disk BASIC, see Appendix H.

Page 103, line 11: :
C (in extended) retains CONSOLE function.
CHANGE TO:
C (in Extended and Disk) retains CONSOLE and all other functions.
Page 112, Paragraph 4, Line 3:

USRLOC for 4K and 8K Altair BASIC version 4.0 is 111 decimal.
CHANGE TO:

USRLOC for 4K and 8K Altair BASIC version 4.0 is 111 octal.
Page 114, third paragraph, line 2:

. by the first character of the STRING expression>.

CHANGE TO:

============================================================
Page 8
============================================================

============================================================
Page 9
============================================================
C

18.

ig,

20.

21.

22.

BASIC Reference Manual Addenda, April, 1977
Page 4

. . by the first character of the <string expression>. Note that the
program named A is saved by CSAVE"A",

Page 119, last sentence before the NOTE:

File numbers are calculated by multiplying the sector number of the direc-
tory track the file is in by 16 and adding the position of the slot in the
sector (0-8) pilus 1.

CHANGE TO:

File numbers are calculated by multiplying the sector number of the direc-
tory track the file is in by 8 and adding the position of the slot in the

sector (0-7) plus 1.
Page 122, Step 1, line 3:
. location 22116 octal . ,

CHANGE TO:

+ « location 2=077 octal. .
Page 126, line 6:
*COP#,2 FROM @ TO 1? YCARRIAGE return> DONE*
CHANGE TO:
*COPG,1
FROM § TO 1? Y<carriage return>
DONE
*
Page 126, lines 13 through 15:

. . . Exampie: *DAT# (DAT is equivalent} TRACK? SECTOR? 9 666 908 pap
POD PPD DAA POP PHD BOP HPP HH HOP HAP etc.

CHANGE TO:

*DAT#

TRACK? §

SECTOR? §

PDB POA BAD DAD BAD DAD ADD ADP DAS POP BPP BOP APG etc.
Page 131, line 1 of program: ©

ORG 7Q1

CHANGE TO:

ORG 71g


============================================================
Page 10
============================================================

============================================================
Page 11
============================================================
C

23.

24.

BASIC Reference Manual Addenda, April, 1977

Page 5

Page 135, Step 7, line 2:
. . . the board type-ig IOCHNL, .
CHANGE TO:

» « the board address is IOCHNL
Index, line 12:
ADDITION:

NULL. «2 2 ee eee

*

wee 72

============================================================
Page 12
============================================================

============================================================
Page 13
============================================================
PREFACE

The Altair BASIC language is a high~level programming
language specifically designed for interactive computing
systems. Its simple English-like instructions are easily
understood and quickly learned and its interactive nature
allows instant feedback of results and diagnostics. Despite
its simplicity, however, Altair BASIC has evolved into a
powerful language with provisions for editing and string
processing as well as numerical computation.

The Altair BASIC interpreter reads the instructions of
the BASIC language and directs the ALTAIR 8886 series
microcomputer to execute them. Altair BASIC includes many
useful diagnostic and editing features in all versions. The
@xtended versions provide additional features including
comprehensive file input/output procedures in the disk
version.

This manual will explain the features of the BASIC
language and the special provisions of the 4K, 8K, Extended
and Disk Extended Altair BASIC interpreters, release 4.0.
For quick reference, a table of Altair BASIC instructions,
diagnostics and functions are provided in Section 6. A
complete index is at the end of the manual. In addition to
this reference manual, the programmer should have a good
BASIC text book on hand. A list of some suggested texts is
given in Appendix J.

============================================================
Page 14
============================================================
fanuary, 1977

1.
1-1

as
Wh

2-2

CONTENTS

Some Introductory Remarks.

Introduction to this manual
a. conventions

b. definitions
Modes of Operation

Formats

a. lines-AUTO and RENUM

ob. REMarks

¢. ecror messages

Editing - elementary provisions
a. single characters

b. lines

c. whole programs

Expressions and Statements

Expressions
a. constants
b. variables
1) names
2) typing
¢. arrays ~- the DIM statement
d. operators and order of precedence
e. logical operations
f. the LET statement
Branching and Loops
a. branching
1} GOTO
2) IF...THEN... [ELSE]
3) ON...GOTO
b. loops - FOR,NEXT
c. subroutines - GOSUB,RETURN statements
d. memory limitations
Input/Output, Data Handling
a. INPUT
b. PRINT
ec. DATA, READ, RESTORE
1) DATA
2) READ
3) RESTORE
ad. CSAVE, CLOAD
e. miscellaneous
1) WAIT
2) PEEK,POKE
3) OUT, INP

Functions

Page 2

============================================================
Page 15
============================================================
January, 1977 Page 3

Intrinsic Functions
User-defined Functions - the DEP statement

CU

1 String data
-2 String operations
a. comparisons
b. LET statements
¢. input/output
1} INPUT, PRINT
2) DATA, READ
String Functions

3
3
4. Strings
4
4

rs
b
Ww

Extended Features

Extended Statements
Extended Operators
Extended Functions
EDIT Command

PRINT USING Statement
Disk Operations

|
AMeWwnNrH

Tables and Directories

Commands

Statements
Intrinsic Functions
Special Characters
Error Messages
Reserved Words
Index

Ppaidsgs
SAU & whe

ADMAAGHA a Muiininiw wn
‘

Appendices

A. ASCII Character Codes
B. Loading Altair BASIC
C. Speed and Space Hints
D. Mathematical Functions
E. Alitair SASIC and Machine Language
F. Using the ACR Interface
G. Converting BASIC Programs Not Written for the Altair Computer
a. Disk Information
I. The PIP Utility Program
J. BASIC Texts
K. Using Altair BASIC on the
Intellec* 8/Mod 88 and MDS Systems
L. Patching Altair BASIC's I/O Routines
M. Using Disk Altair BASIC: An Example

Index

============================================================
Page 16
============================================================
January,

1977 Page 4

iw

- SOME INTRODUCTORY REMARKS

|

as

-1 Introduction to this Manual.

|

a. Conventions, For the sake of simplicity, some
conventions will be followed in discussing the features of
the Aitair BASIC language.

1. Words printed in capital letters must be written exactly
as shown. These are mostly names of instructions and
commands.

2. Items enclosed in angle brackets {<>} must be supplied
as explained in the text. Items in square brackets ([]) are
optional. Items in both kinds of brackets, [<W>], for
example, are to be supplied if the optional feature is used.
Items followed by dots {...} may be repeated or deleted as
necessary.

3. Shift/ or Control/ followed by a letter means the
character is typed by holding down the Shift or Control key
and typing the indicated letter.

4. All indicated punctuation must be supplied.

b, Definitions. Some terms which will become
important are as follows:

Alphanumeric character: all letters and numerals taken
together are called alphanumeric characters.

Carriage Return: Refers both to the key on the
terminal which causes the carriage, print head or cursor to
move to the beginning of the next line and to the command
that the carriage return key issues which terminates a BASIC
line.

Command Level: After Altair BASIC prints OK, it is at
the command level. This means it is ready to accept
commands.

Commands and Statements: Instructions in Altair BASIC
are loosely divided into two classes, Commands and
Statements. Commands are instructions normally used only in
direct mode {see Modes of Operation, section 1-2). Some
commands, such as CONT, may only be used in direct mode since
they have no meaning as program statements. Some commands,
such as DELETE, are not normally used as program statements
because they cause a return to command level. But most
commands will find occasional use as program statements.
Statements are instructions that are normally used in
indirect mode. Some statements, such as DEF, may only be
used in indirect mode.

============================================================
Page 17
============================================================
January, 1977 Page 5

Edit: The process of deleting, adding and substituting
Cc, lines in a program and that of preparing data for output
according to a predetermined format will both be referred to
as “editing.” The particular meaning in use will be clear
from the cantext.

Integer Expression: An expression whose value is
truncated to an integer. The components of the expression
need not be of integer type.

Reserved Words: Some words are reserved by BASIC for
use as statements and commands. These are called reserved
words and they may not be used in variable or function
names.

Special Characters: some characters appear differently
on different terminals. Some of the most important ef these
are the following:

(caret) appears on some terminals as } (up-arrow)
ev (tilde) does not appear on some terminals and prints
as a blank
_ (underline) appears on some terminals as ~» (back~arrow).

String Literal: A string of characters enclosed by
quotation marks. {") which is to be input or output exactly
CC: as it appears. The quotation marks are not part of the
String literal, nor may a string literal contain quotation
marks. (““HI, THERE“"is not legal.) ;

Type: While the actual device used to enter
information into the computer differs from system to system,
this manual will use the word “type” to refer to the process
of entry. The user types, the computer prints. Type also
refers to the classifications of numbers and strings.

1-2 Modes of Operation.

Altair BASIC provides for operation of the computer in
two different modes. In the direct mode, the statements or
commands are executed as they are entered into the computer.
Results of arithmetic and logical overations are displayed
and stored for later use, but the instructions themselves
are lost after execution. This mode is useful for debugging
and for using Altair BASIC in a "calculator" mode for quick
computations which do not justify the design and coding of
complete programs.

In the indirect mode, the computer executes
instructions from a program stored in memory. Program lines
are entered into memory if they are preceded by a line

Cc number, Execution of the program is initiated by the RUN


============================================================
Page 18
============================================================
January, To77 Page 6

In the indirect mode, the computer executes |
instructions from a program stored in memory. Program lines
are entered into memory if they are preceded by a _ line |
number, Execution of the program is initiated by the RUN é
commands.

1-3 Formats.

a. Lines. The line is the fundamental unit of an
Altair BASIC program. The format for an Altair BASIC line
is as follows:

nnnnn <BASIC statement>[:<BASIC statement>...]

Each Altair BASIC line begins with a number. The number
corresponds to the address of the line in memory and
indicates the order in which the statements in the line will
be executed in the program. It also provides for branching
linkages and for editing. Line numbers must be in the range
8 to 65529. A gecd programming practice is to use an
increment of § or 18 between successive line numbers’ to
ailow for insertions.

1) Line numbers may be generated automatically in the
Extended and Disk versions of Altair BASIC by use of the
AUTO and RENUM commands. The AUTO command provides for .
automatic insertion of line numbers when entering program 4
lines. The format of the AUTO command is as follows:

AUTO[{<initial line>{,{<increment>] ]
Example;

AUTO 189,19

148 INPUT X,Y

118 PRINT SQR(X7*2+Y7 2)

129 “c

OK

AUTO will number every input line until Control/c is typed,
If the <initial Line> is omitted, it is assumed to be 16 and
an increment of 14 is assumed if <increment> is omitted. If
the <initial line> is followed by a comma but no increment
is specified, the increment last used in an AUTO statement
is assumed.

T£ AUTO generates a line number that already exists in
the program currently in memory, it prints the number
followed by an asterisk. This is to warn the user that any
input will replace the existing line.


============================================================
Page 19
============================================================
a a 5 eas

2) The RENUM command allows program lines to he "spread
out" so that a new line or lines may be inserted between
existing lines. The format of the RENUM command is as
follows:

C RENUM [<NN>[<MM>[,<II>]]]

where NN is the new number of the first line to be
resequenced. Tf omitted, NN is assumed to be 18. Lines
less than HM will not be renumbered. If MM is omitted, the
whole program will be resequenced. II is the increment
between the lines to be resequenced. If II is omitted, it
is assumed to be 18. Examples:

RENUM Renumbers the whole program to start at line
18 with an increment of 16 between the new line numbers.

RENUM 184,,104 Renumbers the whole program to start
at line 109 with an increment cf 1486,

RENUM 6000,5008,1000 Renumbers the lines from 5906
up so they start at 6#08 with an inerement of 10090.

NOTE

RENUM cannot be used to change the order of program
lines (for example, RENUM 15,38 when the program has
three lines numbered 18, 28 and 30) nor to create

CT line numbers greater than 65529. An ILLEGAL
PUNCTION CALL error will result.

All line numbers appearing after a GOTO, GOSU8, THEN,
ON...GOTO, ON...GOSUB and ERL<relational operator> will be
properly changed by RENUM to reference the new line numbers.
Tf a line number appears after one of the statements above
but does not exist in the program, the message “UNDEFINED
LINE XXXXX IN YYYYY" will be printed. This line reference
(XXXXX)} will not be changed by RENUM, but line number YYYYY
may be changed.

3) In the Extended and Disk versions, the current line
number may be designated by a period (.) anywhere a line
number reference its required. This is particularly useful
in the use of the EDIT command. See section 5-4,

4) Following the line number, one or more BASIC
Statements are written. The first word of a statement
identifies the operations to be performed. The list of
arguments which follows the identifying word serves several
purposes. It can contain (or refer symbolically to} the


============================================================
Page 20
============================================================
fanuary, 1977 Page 8

important instructions, the operation to he performed
depends upon conditions or options specified in the list.

Each type of statement will be considered in detail in
sections 2, 3 and 4.

More than one statement can be written on one line if
they are separated by colons {:}. Any number of statements
can be joined this way provided that the line is no more
than 72 characters long in the 4K and 8K versions, or 255
characters in the Extended and Disk versions. In the
Extended and Disk versions, lines may be broken with the
LINE FEED key. Example:

1990 IP xX<¥+37<line feed>
THEN 5 <line feed>
ELSE PRINT(X)<carriage return>

The line is shown broken into three lines, but it is input
as one BASIC line,

b. REMarks. In many cases, a program can be more
easily understood if it contains remarks and explanations as
well as the statements of the program proper. In Altair
BASIC, the REM statement allows such comments to be included 4
without affecting execution of the program. The format of
the REM statement is as follows: .

REM <remarks> :

A REM statement is not executed by .BASIC, but branching
statements may iink into it. REM statements are terminated
by the carriage return or the end of the line but not by a
colon. Example:

189 REM DO THIS LOOP:FOR [=1TO19 “the FOR statement
will not be executed
181 FOR I=1 TO 18: REM DO THIS LOOP -this FOR statement will

be executed.

In Extended and Disk versions, remarks may be added to the
end of a program line separated from the rest of the line by
@ single quotation mark ('). Everything after the single
guote will be ignored.

¢. Errors. When the BASIC interpreter detects an
error that will cause the program to be terminated, it
prints an error message. The error message formats in
Altair BASIC are as follows:

Direct statement ?XX ERROR q

1
1
4
j
data which is to be operated upon by the statement. In some é |
{

============================================================
Page 21
============================================================
Anuary,

CU

1977 Page 9

Indirect statement ?XX ERROR IN nnnnvan

XX is the error code or message (see section 6-5 for a List
of error codes and messages) and nnnnn is the line number
where the error occurred. Each statement has its own
particular possible errors in addition to the general errors
in syntax. These errors will be discussed in the
@escription of the individual statements.

1-4 Editing - elementary provisions.

Editing features are provided in Altair BASIC so that
Mistakes can be corrected and features can be added and
deleted without affecting the remainder of the program. If
Necessary, the whole program may be deleted. Extended and
Disk Altair BASIC have expanded editing facilities which
will be discussed in section 5.

a. Correcting single ‘characters. If an ineorrect
character is detected in a line as it is being typed, it can
be corrected immediately with the backarrow ( underline on
some terminals) or ,except in 4K, the RUBOUT key. Each
Stroke of the key deletes the immediately preceding
character. If there is no preceding character, a carriage
return is issued and a new line is begun, Once the unwanted
characters are removed, they can be replaced simply by
typing the rest of the line as desired. . ;

When RUBOUT is typed, a backslash (\) is printed and
then the character to be deleted. Each successive RUBOUT
prints the next character to be deleted. Typing a new
character prints another backslash and the new character.
All characters between the backsiashes are deleted.

Example:

198 X=\=X\¥s10 Typing two RUBOUTS deleted the 'a'
and 'X' which were subsequently
replaced by y=.

b. correcting lines. A line being typed may be
deleted by typing an atesign (@) instead of typing a
carriage return. A carriage return is printed automatically
after the line is deleted, Except in 4K, typing Control/U
has the same effect.

In the Extended and Disk versions, typing Control/A
instead of the carriage return will allow all the features
of the EDIT command (except the A command) to be used on the


============================================================
Page 22
============================================================
fanuary, 1977 Page 16

line currently being typed. See section 5-4.

e. correcting whole programs. The NEW command causes
the entire current program and all variables to be deleted.
NEW is generally used to clear memory space preparatory to
entering a new program.

2. STATEMENTS AND EXPRESSIONS.

2-1. Expressions.

The simplest BASIC expressions are single constants,
variables and function calls.

a. Constants. Altair BASIC accepts integers or
floating point real numbers as constants. All but the 4K
version of Altair BASIC accept string constants as well.
See section 4-1. Some examples of acceptable numeric
constants follow:

123
3.141
4.6436
1.25E+985

Data input from the terminal or numeric constants in a
Program may have any number of digits up to the length of a
line {see section 1-3a). In 4K and 8K Altair BASIC,
however, only the first 7 digits of a number are significant
and the seventh digit is rounded up. Therefore, the command

PRINT 1.234567890123
produces the following output:

1.23457
OK

In Extended and Disk versions of Altair BASIC, double
precision format allows 17 significant digits with the 17th
digit rounded up.

The format of a printed number is determined by the
following rules:

1. If the number is negative, a minus sign (-) is printed
to the left of the number. If the number is positive, a
space is printed.


============================================================
Page 23
============================================================
knuary, 1977 Page ll

2. If the absolute value of the number is an integer in
CC the range @ to 9399999, it is printed as an integer.

3. If the absolute value of the number is greater than or
equal to .81 and less than or equal to 999999, it is
printed in fixed point notation with no exponent.

4. In Extended and Disk versions, fixed point values up to
9999999999999959 are possible.

5. If the number does not fall into categories 2, 3 or 4,
scientific notation is used.

The formats of scientific notation are as follows;
SX.XXXXXESTT single precision
SX .XXXXXXXXXXXXXXXOSTT double precision

where S stands for the signs of the mantissa and the
exponent (they need not be the same, of course), X for the
digits of the mantissa and T for the digits of the exponent.
E and D may be read *...times ten to the power....”
Non-significant zeros are suppressed in the mantissa, but
two digits are always printed in the exponent. The sign
convention in rule 1 is followed for the mantissa. The

Cc exponent must be in the range ~38 to +38. The largest
number that may be represented in Altair BASIC is
1.74141£38, the smallest positive number is 2.93878-38. The
following are examples of numbers as input and as output by
Altair BASIC:

Number Altair BASIC Output
+1 1

-1 ~l

6523 6523

1220 1E29 :
-12.34567E-19 ~1.234568-09
1.2345675-7 1.23457E-97
12664004 1E+66

al ol

«61 ~61

- 868123 1,23E-94
~25.466 -25.46

The Extended and Disk versions of Altair BASIC allow

numbers to he represented in integer, single precision or

C double precision form. The type of a number constant is
determined according to the following rules:


============================================================
Page 24
============================================================
anuary, 1977 Page 12

1. A constant with more than 7 digits or a 'D' instead of
‘Et in the exponent is double precision.

2. A constant outside the range -32768 to 32767 with 7 or
fewer digits and a decimal point or with an 'E' exponent
is single precision.

3. A constant in the range -32768 to 32767 and no decimal
point is integer.

4. A constant followed by an exclamation point ({!) is
single precision; a constant followed by a pound sign
(#) is double precision.

Two additional types of constants are allewed in
Extended and Disk versions of Altair BASIC. Hexadecimal
{base sixteen) constants may be explicitiy designated by the
symbol &H preceding the number, The constant may not
contain any characters other than the digits @ - 9 oar
letters A - FP, ocr a SYNTAX ERROR wiil occur. Octal
constants may be designated either by 6&0 or just the & sign.

In alk formats; a space is printed after the number.
In all but the 4K version, Altair BASIC checks to see if the
entire number will fit on the current line. If not, it
issues a carriage return and prints the whole number on the
next line. . .

b. Variables

1) A variable represents symbolically any number which
is assigned to it. The value of a variable may be assigned
explicitly by the programmer or may be assigned as the
cesult of calculations in a program. Before a variable is
assigned a value, its value is assumed to be zero, In 4K ,
a variable name consists of one or two characters. The
first character is any letter. The second character must be
a numeral. In other versions of Altair BASIC, the variable
name may be any length, but any alphanumeric characters
after the first two are ignored. The first character must
be a letter. No reserved words may appear as variable names
oc within variable names. The following are examples of
legal and illegal Altair BASIC variables:

Legal Illegal
In 4K and 8K Altair SASIC:
A $A (first character must
be alphabetic.)
21 Z1A (variable name is too

long for 4K)
Other versions:


============================================================
Page 25
============================================================
o

january, 1977 Page 13

TP TO {variable names cannot
be reserved words}

PSTGS

COUNT RGOTO (variable names can-
not contain reserved
words.)

In ail but 4K Altair BASIC, a variable may also
represent ai string. Use of this feature is discussed in
section 4,

2) Extended and Disk versions of Altair BASIC allow the
use of Integer and Double Precision variables as well as
Single Precision and Strings. The type of a variable may be
explicitly declared in Extended and Disk versions of Altair
BASIC by using one of the symbols in the tahie below as the
last character of the variable name.

Type Symbol
Strings (@ to 255 characters} $
Integers (-32768 to 32767} %
Single Precision (up to 7 digits, exponent between
-38 and +38) {
Double Precision (up to 16 digits, exponent between
-38 and +38)

Internally, BASIC handles ali numbers in binary. Therefore,
some 8 digit single precision and 17 digit double precision
numbers may be handled correctly, If no type is explicitly
declared, type is determined by the first letter of the
variable name according to the type table. The table of
types may be modified with the following statements.

DEFINT cr Integer
DEFSTR c String
DEPSNG r Single Precision
DEFDBL r Double Precision

where r is a letter or range of letters to be designated.
Examples:

15 OEFINT I=N Variable names beginning with the let~-
ters I=N are to be of integer type.

28 DEFDaL DO Variable names beginning with D are to
be of double precision type.

If no type definition statements are encountered, BASIC
proceeds as if it had executed a DEFSNG A=-2 statement.

============================================================
Page 26
============================================================
famuary, 1977 Page 14

3) Integer variables should be used wherever possible
since the take the least amount of space in memory and
integer arithmetic is much faster than single precision
arithmetic.

Care must be exercised when single precision and double
precision numbers are mixed. Since single precision numbers
can have more significant digits than will be printed, a
Gouble precision variable set to a single precision value
May not print the same as the single precision variable.

16 A=1.81 single precision value

20 B¢=A*19:C¥=CDAL (A) *18% convert to double precision
30 PRINTA; BS ;C#;CDBL(A) in various ways

RON

1.01 16.16096638146973 14.99999999463257 1.899999990463257

OR

In order to assure that double precision numbers will print
the same as single precision, the VAL and STRS functions
should be used. For example:

19 A=1.01
20 BE*VAL (STRS (A) ) :CH=Bs*15F
38 PRINT A;Ba;C#
RON
1.91 1.81 18.1
OK

c. Array Variables. It is often advantageous to refer
to several variables by the same name. In matrix
calculations, for example, the computer handles each element
of the matrix separately, but it is convenient for the
programmer to refer to the whole matrix as a unit. For this
Purpose, Altair BASIC provides subseripted variables, or
arrays. The Form of an array variable is as follows:

VV (<subscript>[{,<subscript>...])

where VV is a variable name and the subscripts are integer
expressions. Subscripts may be enclosed in parentheses or
square brackets. An array variable may have only one
dimension in 4K, but in all other versions of Altair BASIC
it may have as many dimensions as will fit on a single line.
The smallest subseript is zero. Examples:

A(5} The sixth element of array A. The first
element is A(9).

ARRAY (I,2*J) The address of this element in a two-
dimensional array is determined by
evaluating the expressions in parenthe+
ses at the time of the reference to the

============================================================
Page 27
============================================================
knuary,

CU

1977 Page 15

array and truncating to integers. If
Is3 and J=2.4, this refers to ARRAY(3,4).

The DIM statement allocates storage for array variables and
sets all array elements to zero. The form of the DIM
statement is as follows:

DIM VVi<subscript>[{,<subscript>...])

where VV is a legal variable name. Subscript is an integer
expression which specifies the largest possible subscript
for that dimension. Each DIM statement may apply to more
than one array variable. Some examples follow:

113 DIM A(3), D$(2,2,2)

114 DIM R2%({4), B(1@)

115 DIM QL(N), 2#(2+12) Arrays may be dimensioned dy-
namically during program
execution, At the time the
DIM is executed, the expression
within the parentheses is e-
vyaluated and the results trun-
cated to integer.

If no DIM statement has been executed before an array
variable is found in a program, BASIC assumes the variable
to have a maximum subscript of 18 (11 elements) for each
dimension in the reference. A BS or SUBSCRIPT OUT OF RANGE
etror message will be issued if an attempt is made to
reference an array element which is outside the space
allocated in its associated DIM statement. This can occur
when the wrong number of dimensions is used in an array
element reference. For example:

3@ LET A(1,2,3)=X when A has been dimensioned by
19 DIM A(2,2)

A OD or REDIMENSIONED ARRAY error occurs when a DIM
Statement for an array is found after that array has been
dimensioned. This often occurs when a& DIM statement appears
after an array has been given its default dimension of 14.

d. Operators and Precedence. Altair BASIC provides a
full range of arithmetic and (except in 4K) logical
operators. The order of execution of operations in an
expression is always according to their precedence as shown
in the table below. The order can be specified explicitly
by the use of parentheses in the normal algebraic fashion.

Table of Precedence

============================================================
Page 28
============================================================
January, 1977 Page 16

Operators are shown here in decreasing order of precedence.
Operators listed in the same entry in the table have the 4
Same precedence and are executed in order from left to right
in an expression.
l. Expressions enclosed in parentheses (}
2. “ exponentiation (net in 4K). Any number to the zero
power is 1. Zero to a negative power causes a /@ or
DIVISION BY ZERO error.
3. ~ negation, the unary minus cperator
4. *,/ multiplication and division

5. \ integer division {available in Extended and Disk
versions, see section 5~2}

6. MOD {available in Extended and Disk versions. See
section 5-2)

7. +,- addition and subtraction

8, relational operators
= equal
<> not equal ;
< less than q
> greater than
<a,*< less than or equal to
>=,=> greater than or equal to

{the logical operators below are not available in 4X)

9. NO? logical, bitwise negation
19. AND logical, bitwise disjunction
ll. OR logical, bitwise conjunction
(The logical operators below are available only in
Extended and Disk versions.)
12. XOR logical, bitwise exclusive OR
13. EQV logical, bitwise equivalence
14. IMP logical, bitwise implication

In 4K Altair BASIC, relational operators may be used only
once in an IF statement. In all other versions, relational q


============================================================
Page 29
============================================================
Rnuary,

C,

1977 : Page 17

operators may be used in any expressions. Relational
expressions have the value either of True (-1} or False (9).

@. Logical Operations. Logical operators may be used
for bit manipulation and Boolean algebraic functions. The
AND, OR, NOT, XOR, EQVY and IMP operators convert their
arguments into sixteen bit, signed, two's complement
integers in the range ~32768 to 32767. After the operations
are performed, the result is returned in the same form and
range. If the arguments are not in this range, an FC or
ILLEGAL FUNCTION CALL error message will be printed and
execution will be terminated. Truth tables for the logical
operators appear below. The operations are performed
bitwise, that is, corresponding bits of each argument are
examined and the result computed one bit at a time. In
binary operations, bit 7 is the most significant bit of a
byte and bit @ is the least significant.

AND

~
o
«

aearre »*
rar H
enere

OR

*
o

See?
K

maAQHEH K
Qe Re K

NOT

Or x.
i}

XOR
X XOR Y

eRe eK
RBrerkK
Baers

EQV

BMerrer
@erarK

IMP

Berrys
Serarnrt


============================================================
Page 30
============================================================
fanuary, 1977 Page 18

Some examples will serve to show how the logical operations

work:

63 AND 16#16 63*binary 111111 and 16=binary 19669,
so 63 AND 16316 :

15 AND 14=14 15= binary 1111 and l4=binary 11146,
so 15 AND 14=binary 1116214.

-1 AND 9=8 -l=binary 11111111111131111 and 8=binary
1889, so -1 AND 828.

4 OR 226 4abinary 198 and 2=binary 198 s0
4 OR 2sbinary 112=6.

18 OR 10=18 binary 1919 OR'd with itself is 1810=
18.

~1 OR +2s-1 “l=binary 11111211111111111 and -2=

, 1111111111111118, so -2 OR -2=-1,
NOT g=-1 the bit complement of sixteen zeros

is sixteen ones, which is the two's
complement representation of -l.

NOT X2-(X+1) the two's complement of any number is
the bit complement plus one.

A typical use of legical operations is '‘masking', testing a
binary mumber for some predetermined pattern of bits. Such
numbers might come from the computer's input ports and would
then reflect the condition of some external device. Further
applications of logical operations will be considered in the
discussion of the IF statement.

f. The LET statement. The LET statement is used to
assign a value to a variable. The form is as follows:

LET <VV>=<expression>

where VV is a variable name and the expression is any valid
Altair BASIC arithmetic or, except in 4K, logical or string
expression. Examples:

1699 LET V=X
118 LET I=I41 the '=' sign heremeans ‘is replaced
by .-..'

The word LET in a LET statement is optional, so algebraic
equations such as:

126 V=.5*(X+#2)
are legal assignment statements.

A SN or SYNTAX ERROR message is printed when BASIC
detects incorrect form, illegal characters in a line,
incorrect punctuation or missing parentheses. An OV ofr
OVERFLOW error occurs when the result of a calculation is


============================================================
Page 31
============================================================
anuary, 1977 Page 19

too large to be represented by Altair BASIC's number
formats. All mumbers must be within the range 1LE=-38 to
Cc 1.7@141E38 or -1E-38 to -1.70141E38. An attempt to divide
by zero results in the /@ or DIVISION BY ZERO error message.

For a discussion of strings, string variables and
string operations, see section 4,

2-2. Branching, Loops and Subroutines.

@. Branching. In addition to the sequential execution
of program tines, BASIC provides for changing the order of
execution. This provision is called branching and is the
basis of programmed decision making and loops. The
statements in Altair BASIC which provide for branching are
the GOTO, IF...THEN and ON...GOTO statements.

1} GOTO is an unconditional branch. Its form is as
follows:

GOTO<mmmmm>

After the GOTO statement is executed, execution continues at
line number mmmmm.

C 2) If...THEN is a conditional branch. Its form is as
follows: .

IF<expression>THEN<mmmmm>

where the expression is a valid arithmetic, relational or,
except in 4K, logical expression and mmmmm is a line number.
If the expression is evaluated as non-zero, BASIC continues
at line mmmmn. Otherwise, execution resumes at the next
line after the IF...THEN statement.

An alternate form of the IF...THEN statement is as
follows:

IF<expression>THEN<statement>

where the statement is any Altair BASIC statement.
Examples:

19 IF A=10 THEN 42 If the expression A=19 is
true, BASIC branches to line 44. Otherwise,
execution proceeds at the next Line.

15 IF AcB+C OR X THEN 194 The expression after IF is
evaluated and if the value of the expression is
non-zero, the statement branches to line 126.


============================================================
Page 32
============================================================
Bnuary,

1977 Page 20

Otherwise, execution continues on the next line.

28 IF X THEN 25 If X is not zero, the statement
branches to line 25.

30 IP X#¥ THEN PRINT X If the expression X=Y is true
{its value is non-zero), the PRINT statement is
executed. Otherwise, the PRINT statement is not
executed. -In either case, execution continues with
the line after the IF...THEN statement.

35 IP X#¥+3 GOTO 39 Equivalent to the corresponding
IP..-TREN statement, except that GOTO must be
followed by a line number and not by another
statement.

Extended and Disk versions of Altair BASIC provide an
expanded [F...THEN statement of the form

IF<expression>THEN<YY>ELSE<22>

where YY and 22 are valid line numbers or Altair BASIC
statements. Examples:

IF X>¥ THEN PRINT "GREATER? ELSE PRINT "NOT GREATER"

If the expression X>¥ is true, the statement after THEN is
executed; otherwise, the statement after ELSE is executed.

IF xX=2*Y THEN 5 ELSE PRINT "ERROR"
If the expression X=2*Y is true, BASIC branches to line 5;
otherwise, the PRINT statement is executed. Extended and
Disk Altair BASIC allow a comma before THEN.

IF statements may be nested in the Extended and Disk
versions. Nesting is limited only by the length of the
line, Thus, for example: :

IF X>¥ THEN PRINT “GREATER" ELSE IF Y>X
THEN PRINT "LESS THAN" ELSE PRINT "EQUAL"

and

IF xX=¥ THEN IF Y>Z THEN PRINT "X>Z" ELSE PRINT "Y¥<=2"
ELSE PRINT "X<>Y"

are legal statements. If a line does not contain the same
number of ELSE and THEN clauses, each ELSE is matched with
the closest unmatched THEN. Example:

IF A=B THEN IF B=C THEN PRINT "A=C" ELSE PRINT "A<>C"

will not print "A<>C" when A<>B.

============================================================
Page 33
============================================================
anuary,

C

C.

1977 Page 21

3) ON..,.GOTO {not in 4K) provides for another type of
conditional branch. Its form is as follows:

ON<expression>GOTO<list of line numbers>

After the value of the expression is truncated to an
integer, say I, the statement causes BASIC to branch to the
line whose number is Ith in the list. The statement may be
followed by as many line numbers as will fit on one line.
If I=G or is greater than the number of lines in the list,
execution will continue at the next Line after the ON...GOTO
Statement. I must not be less than zero or greater than
255, or an FC or ILLEGAL FUNCTION CALL error will result.

b. Loops. It is often desirable to perform the same
calculations on different data or repetitively on the same
data. For this purpose, Altair BASIC provides the FOR and
NEXT statements. The form of the FOR statement is as
follows:

FOR<variable>2<X>TO<¥> (STEP <2>]

where X,Y and 2 are expressions. When the FOR statement is
encountered for the first time, the expressions are
evaluated. The variable is set to the value of X which is
called the initial value. BASIC then executes the
statements which follow the FOR statement in the usual
manner. When a NEXT statement is encountered, the step 2 is
added to the variable which is then tested against the final
value ¥Y. If @, the step, is positive and the variable is
less than or equal to the final value, or if the step is
negative and the variable is greater than or equal to the
final value, then BASIC branches back to the statement
immediately following the FOR statement. Otherwise,
execution proceeds with the statement following the NEXT.
If the step is not specified, it is assumed to be 1.
Examples:

10 FOR Ia2 TO 11 The loop is executed 19 times with
the variable I taking on each in-
tegral value from 2 to ll.

26 FOR Veil TO 9.3 This loop will execute 9 times un-
til V is greater than 9.3

34 FOR V=10*N TO 3.4/2 STEP SQR(R) The initial, final
and step expressions need not be
integral, but they will be eval-
uated only ance, before loop-
ing begins,

48 POR V=9 TO 1 STEP -] This loop will be executed 9
times.

FOR...NEXT loops may be nested. That is, BASIC will execute

============================================================
Page 34
============================================================
January,, 1977 Page 22

a FOR...NEXT loop within the context of another loop. An
example of two nested loops follows:

188 FOR I=1 TO 14
120 FOR J=1 TO I

238 PRINT A(I,J)

14a NEXT J

159 NEXT I

Line 139 will print 1 element of A for I=1, 2 for I=@2 and so
on. If loops are nested, they must have different loop
variable names. The NEXT statement for the inside loop
variable (J in the example} must appear before that for the
outside variable (I). Any number of levels of nesting is
allowed up to the limit of available memory.

The NEXT statement is of the form:
NEXT [(<variable>(,<variable>...}]

where each variable is the loop variable of a FOR loop for
which the NEXT statement is the end point. In the 4K
version, the only form allowed is NEXT with one variable.
In all other versions, NEXT without a variable will match
the most recent FOR statement. In the case of nested loops
which have the game end point, a single NEXT statement may
be used for all of them, except in 4K. The first variable
in the list must be that of the most recent loop, the second
‘of the next most recent, and so on. If BASIC encounters a
NEXT statement before its corresponding FOR statement has
been executed, an NF or NEXT WITHOUT FOR error message is
issued and execution is terminated,

c. Subroutines. If the same operation or series of
Operations are to be performed in several places ina
program, storage space requirements and programming time
will be minimized by the use of subroutines. A subroutine
is a series of statements which are executed in the normal
fashion upon being branched to by a GOSUB statement.
Execution of the subroutine is terminated by the RETURN
statement which branches back to the statement after the
most recent GOSUB. The format of the GOSUB statement is as
follows:

GOSUB<line number>

where the line number is that of the first line of the
subroutine. A subroutine may be called from more than one
Place in a program, and a subroutine may contain a call to
another subroittine. Such subroutine nesting is limited only
by available memory.

============================================================
Page 35
============================================================
anuary,

C

1977 Page 23

Except in the 4K version, subroutines may be branched
to conditionally by use of the ON...GOSUB statement, whose
form is as follows:

ON <expression> GOSUB <list of line numbers>

The execution is the same as ON...GOTO except that the line
numbers are those of the first lines of subroutines.
Execution continues at the next statement after the
ON...GOSUB upon return from one of the subroutines.

d. OUT OF MEMORY errors. While nesting in loops,
subroutines and branching is not limited by BASIC, memory
size limitations restrict the size and complexity of
programs. The OM or OUT OF MEMORY error message is issued
when a program requires more memory than is available. See
Appendix c¢ for an explanation of the amount of memory
required to run programs.

2-3. Input/Output

a. INPUT. The INPUT statement causes data input to be
requested from the terminal, The format of the INPUT
statement is as follows:

INPUT<list of variables>

The effect of the INPUT statement is to cause the values
typed on the terminal to be assigned to the variables in the
list. When an INPUT statement is executed, a question mark
{?}) is printed on the terminal signalling a request for
information. The operator types the required numbers or
strings (or, in 4K, expressions) separated by commas and
types a carriage return. If the data antered is invalid
{strings were entered when numbers were requested, etc.)
BASIC prints 'REDO FROM START?' and waits for the correct
data to be entered. If more data was requested by the INPUT
Statement than was typed, ?? is printed on the terminai and
execution awaits the needed data. If more data was typed
than was requested, the warning "EXTRA IGNORED' is printed
and execution proceeds. After all the requested data is
input, execution continues normally at the statement
following the INPUT. Except in 4K, an optional prompt
string may be added to an INPUT statement,

INPUT("<prompt string>";]<variable list>

Execution of the statement causes the prompt string to be
printed before the question mark. Then all operations
Proceed as above. The prompt string must be enclosed in
double quotation marks [(") and must be separated from the

============================================================
Page 36
============================================================
lanuary,

1977 Page 24

variable list by a semicolon (;}). Example:

149 INPUT "WHAT'S THE VALUE";X,¥ causes the following
outputs:

WHAT'S THE VALUE?

The requested values of X and Y are typed after the ?
Except in 4K, a carriage return in response to an INPUT
statement will cause execution to continue with the values
of the variables in the variable list unchanged. [In 4K, a
SN error results,

b. PRINT. The PRINT statement causes the terminal to
print data. The simplest PRINT statement is:

PRINT

which prints a carriage return. The effect is to skip a
line. The more uSual PRINT statement has the following
form:

PRINT<list of expressions>

which causes the values of the expressions in the list to be
printed, String literals may be printed if they are
enclosed in double quotation marks (").

The position of printing is determined by the
punctuation used to separate the entries in the list.
Altair BASIC divides the printing line into zones of 14
spaces each. A comma causes printing of the value of the
next expression to begin at the beginning of the next 14
column zone. A semicolon (;} causés the next printing to
begin immediately after the last value printed. If a comma
or semicolon terminates the list of expressions, the next
PRINT statement begins printing on the same line according
to the conditions above. Otherwise, a carriage return is
printed,

c. DATA, READ, RESTORE

1) the DATA statement. Numerical or string data needed
in a program may be written into the program statements
themselves, input from peripheral devices or read from DATA
statements. The format of the DATA statement is as follows:

DATA<list>

where the entries in the list are numerical or string
constants separated by commas. In 4K, expressions may also

============================================================
Page 37
============================================================
AILUary,

CU

1977 Page 25

appear in the list. The effect of the statement is to store
the list of values in memory in coded form for access by the
READ statement, Examples:

18 DATA 1,2,-1E3,.94

28 DATA ” £00", MITS Leading and trailing spaces in
string values are suppressed unless the string is
enclosed by double quotation marks.

2) The READ statement. The data stored by DATA
statements is accessed by READ statements which have the
following form:

READ<list of variables>

where the entries in the list are variable names separated
by commas. The effect of the READ statement is to assign
the values in the DATA lists to the corresponding variables
in the READ statement list. This is done one by one from
left to right until the READ iist is exhausted. Tf there
are more names in the READ list than values in the DATA
lists, an OD or OUT OF DATA error message is issued. Té
there are more values stored in DATA statements than are
read by a READ statement, the next READ statement to be
executed will begin with the next unread DATA list entry. A
single READ statement may access more than one DATA
statement, and more than one READ statement may access the
data in a single DATA statement. '

An SN or SYNTAX ERROR message can result from an
improperly formatted DATA list. In 4K Altair BASIC, such an
error message will refer to the READ statement which
attempted to access the incorrect data. in other versions,
the line number in the error message will refer to the
actual line of the. DATA statement in which the error
occurred,

3) RESTORE statement. After the RESTORE statement is
executed, the next piece of data accessed by a READ
statement will be the first entry of the first DATA list in
the program. This allows re~-READing the data.

d. CSAVEing and CLOADing Arrays (8K cassette, Extended
and Disk versions only). Numeric arrays may be saved on
cassette or loaded from cassette using CSAVE* and CLOAD* The
Formats of the statements are:

CSAVE*<array name>

and

============================================================
Page 38
============================================================
anuary,

1977 Page 26

CLOAD*<array name>

The array is written out in binary with four octal 219
header bytes to indicate the start of data. These bytes are
searched for when CLOADing the array. The number of bytes
written is four plus:

8*<number of elements> for a double precision array
4*<number of elements> for a single precision array
2*<number of elements> for an integer array

When an array is written out or read in, the elements of the
array are written out with the leftmost subscript varying
most quickly, the next leftmost second, ete:

DIM A(1@)
CSAVE*A

writes out A(@),A{i),...A(18)

DIM A(18,18)
CSAVE*A

writes out A(4,4), A(1,8)...A(19,8) ,A(10,1)...A(16,10)

Using this fact, it is possible to write out an array as a
two dimensional array and read it back in as a <aingle
dimensional array, etc. .

NOTE

Writing out a double precision array and reading it
back in as a single precision or integer array is
not recommended. Useless values will undoubtedly be
returned.

e. Miscellaneous Input/Output

1) WAIT (not in 4K). The status of input ports can be
monitored by the WAIT command which has the following
format:

WAIT<I,3>[,<K>]
where I is the number of the port being monitored and J and

K are integer expressions. The port status is exclusive ORd
with K and the result is ANDed with J. Execution is


============================================================
Page 39
============================================================
Anuary, 1977 . Page 27

© suspended until a non-zero value results. J picks the bits
of port I to be tested and execution is suspended until
those bits differ from the corresponding bits of kK.
Execution resumes at the next statement after the WAIT. If
K is omitted, it is assumed to be zero. I, J and K must be
in the range 9 to 255. Examples:

WAIT 24,6 Execution stops until either bit 1 or bit
2 of port 29 are equal to 1. (Bit @ is
least significant bit, 7 is the most sig-
nificant.) Execution resumes at the next
statement.

WAIT 18,255,7 Execution stops until any of the most significant
5 bits of port 19 are one or any of the least
Significant 3 bits are zero. Execution
resumes at the next statement,

2} POKE, PEEK {not in 4K). Data may be entered into
memory in binary form with the POKE statement whose format
is as follows:

POKE <I,J>

where I and J are integer expressions. POKE stores the byte
I into the location specified by the value of I. In 8K, f
must be less than 32768. In Extended and Disk versions, f
may be in the range @ to 65536. J must be in the range @ to
255. In 8K, data may be POKEd into memory above location
32768 by making I a negative number. In that case, I is
computed by subtracting 65536 from the desired address. To
POKE data into location 45696, for example, I is
45899-65536=-20536. Care must be taken not to POKE data
into the storage area occupied by Altair BASIC or the system
may be POKEd to death, and BASIC will have to be loaded
again.

The complementary function to POKE is PEEK. The format
for a PEEK call is as follows:

PEEK {<I>}

where I is an integer expression specifying the address from
which a byte is read. I is chosen in the same way as in the
PORE statement. The value returned is an integer between @
and 255. A major use of PEEK and POKE is to pass arguments
and results to and from machine language subroutines.

Cc 3)0UT, INP (not in 4K}. The format of the ouUT
Statement is as follows:


============================================================
Page 40
============================================================
january, 1977 Page 28

out <I,J>

where I and J are integer expressions. OUT sends the byte
Signified by J to output port I, I and J must be in the
range @ to 255.

The INP function is called as follows:
INP (<I>)

INP reads a byte from port I where I is an integer
expression in the range @ to 255, Example:

'2@ IF INP(J}=16 THEN PRINT “ON"

3. FUNCTIONS

Altair BASIC allows functions to be referenced in
mathematical function notation. The format of a function
cail is as follows:

<name> (<argument>[,<argument>...])

where the name is that of a previously defined function and
the arguments are one or more expressions, separated by
commas. Only one argument is allowed in 4K and 8K.
Punction calls May be components of expressions, 90
Statements like

1@ LET T=(P*SIN(T)}/P and
20 C=SQR(A” 2+B” 2+2*A*B*COS (T) )

are legal.

3-1. Intrinsic Functions

Altair BASIC provides several frequently used functions
which may be called from any program without further
definition. A procedure is provided, however, whereby
unneeded functions may be deleted to save memory space. See
Appendix B. For a list of intrinsic functions, see section
6-3,

3-2. User~Defined Functions (not in 4K).


============================================================
Page 41
============================================================
AMUALY,

C

1977 Page 29

a. The DEF statement. The programmer may define
functions which are not included in the list of intrinsic
functions by means of the DEF statement. The form of the
DEF statement is as follows:

DEF<function name>(<variable list>)=<expression>

where the function name must be FN followed by a legal
variable name and the entries in the variable list are
‘dummy’ variable names. The dummy variables represent the
argument variables or values in the function call, In &K
Altair BASIC, only one argument is allowed for a
user-defined function, but in the Extended and Disk
versions, any number of arguments is allowed. Any
expression may appear on the right side of the equation, but
it must be limited to one line. User-defined functions may
be of any type in Extended and Disk versions, but
user-defined string functions are not allowed in SK If a
type is specified for the function, the value of the
expression is forced to that type before it is returned to
the calling statement. Examples:

1A DEF FNAVE(V,W)=(V+W) /2

Il DEF PNCONS (V$,WS)=RIGHTS(VS+WS,5) Retucns the right
most 5 characters of the concat-
enation of V$ and WS.

12 DEF FNRAD{DEG)=3.14159/18@*DEG When called with the
measure of an angle in degrees,
returns the radian equivalent.

A function may be redefined by executing another DEP
Statement with the same name. A DEP statement must be
executed before the function it defines may be called.

b. USR. The USR function allows calls to assembly
language subroutines. See appendix E.

3-3. Errors.

An FC or ILLEGAL FUNCTION CALL error results when an
improper call is made to a function. Some places this might
oceur are the following:

1. & negative array subscript. LET A(-1})=0, for example.
2. an array subscript that is too large (>32767)

3. negative or zero argument for LOG

============================================================
Page 42
============================================================
anuary, 1977 Page 34

4. Negative argument for SOR
5. A*B with A negative and B not an integer

6. a call to USR with no address patched for the machine
language subroutine.

7. improper arguments to MIDS, LEFTS ,RIGHTS, INP, OUT,
WAIT, PEEK, POKE, TAB, SPC, INSTR, STRINGS, SPACES or
ON. ..GOTO,

b. An attempt to call a user-defined function which
has not previously appeared in a DEF statement will cause a
UF or UNDEFINED USER FUNCTION error,

c. ATM or TYPE MISMATCH error will occur if a
function which expects a string argument is given a numeric
value or vice-versa.

4. STRINGS

In all Altair BASIC versions except 4K, expressions may
either have numeric value or may be strings of characters,
Altair BASIC provides a complete complement of statements
and functions for manipulating string data. Many ef the
statements have already heen discussed so only their
particular application to strings will be treated in this
section.

4-1. String Data.

A string is a list of alphanumeric characters which may
be from @ to 255 characters in length. Strings may be
stated explicitly as constants or referred to symbolically
by variables. String constants are delimited by quotation
marks at the beginning and end. A string variable name ends
with a dollar sign ($}. Examples:

A$="ABCD" Sets the variable AS to the four character
string "ABCD"

B9OS="14A4/56" Sets the variable B9S to the six character
string “14A/56"

FOOFOOS@"ES" Sets the variable FOOFOOS to the two charac-
ter string "ES"

Strings input to an INPUT statement need not be surrounded


============================================================
Page 43
============================================================
hilary,

c

1977 i Page 31

by quotation marks.

String arrays may be dimensioned exactly as any other
kind of array by usa of the DIM atatement. Hach element of
a String array is a string which may be up to 255 characters
long. The total number of string characters in use at any
point in the execution of a program must not exceed the
total allocation of string space or an OS or OUT OF STRING
SPACE error will result. String space is allocated by the
CLEAR command which is explained in section 6-2.

4-2. String operations.

a. Comparison Operators. The comparison operators for
strings are the same as those for numbers:

= equal

<> not equal

< less than

> greater than

#<,<= less than or equal to
=>,>=™ greater than or equal to

Comparison is made character by character en the basis of
ASCII codes until a difference is found. If, while
comparison is proceeding, the end of one string is reached,
the shorter string is considered to be smaller. ASCII codes
may be found in Appendix B. Examples: ’

A<Z ASCII A is 965, Z is 496

I<A ASCII 1 is 8493

" A™>"A" Leading and trailing blanks are significant
in string literals.

b. String Expressions. String expressions are
composed of string literals, string variables and string
function calls connected by the + or concatenation operator.
The effect of the catenation operator is to add the string
on the right side of the operator to the end of the string
on the left, If the result of concatenation is a string
more than 255 characters long, an LS or STRING TOO LONG
error message will be issued and execution will be
terminated,

¢c. Input/Output. The same statements used for input
and output of normal numeric data may be used for string
data, as well.

============================================================
Page 44
============================================================
tanuary, 1977 _ Page 32

1) INPUT, PRINT. The INPUT and PRINT statements read
and write strings on the terminal. Strings need not be
enciosed in quotation marks, but if they are not, leading
blanks will be ignored and the string will be terminated
when the first comma or colon is encountered. Examples:

18 INPUT ZO00$,FOOS Reads two strings

20 INPUT x$ Reads one string and assigns
it to the variable x$,.

34 PRINT X$,"HI, THERE*® Prints two strings, including
all spaces and punctuation
in the second.

2) DATA, READ. DATA and READ statements for string
data are the same as for numeric data. For format
conventions, see the explanation of INPUT and PRINT above.

4-3. String Functions.

The format for intrinsic string function calls is the
Same as that for numeric functions. For the list of string
functions, see section 6-3. Special user-defined string
functions are allowed in Extended and Disk versions and may
be defined by the use of the DEF statement {see section
3-2}. String function names must end with a dollar sign.

5. EXTENDED VERSIONS.

The Extended and Disk versions of Altair BASIC provide
several statements, operators, functions and commands which
are not available either in the 4K or &K versions. For
clarity, these features are grouped together in this.
section. Some modifications to existing 4K and 8K features,
such as the IF...THEN...ELSE statement and number typing
facilities, have been discussed in conjunction with the
ether versions. Check the index for references to those
features.

5-1. Extended Statements

a. ERASE. The ERASE statement eliminates arrays from
a program and allows their space in memory to be used for
other purposes. The format of the ERASE statement is as
follows:


============================================================
Page 45
============================================================
AITRALY,

C

1977 Page 33

ERASE<array variable list>

where the entries in the list are valid array variable names
separated by commas. ERASE will only operate on arrays and
not array elements. If a name appears in the list which is
not used in the program, an ILLEGAL FUNCTION CALL error will
occur. The arrays deleted in an #RASE statement may be
dimensioned again, but the old values are lost. Example:

18 DIM A(5,5) etc.

608 ERASE A
70 DIM A(190}

b. LINE INPUT. It is often desirable to input a whole
line to a string variable without use of quotation marks and
other delimiters. LINE INPUT provides this facility. The
format of the LINE INPUT statement is as follows:

LINE INPUT ["<prompt string>”,]:<string variable name>

The prompt string is a string literal that is printed on the
terminal before input is accepted. A question mark is not
printed unless it is contained in the prompt string. All
input from the end of the prompt string to the carriage
return is assigned to the string variable. A LINE INPUT may
be escaped by typing Control/c. At that point, BASIC
returns to command level and prints OK. Execution may be
resumed at the LINE INPUT by typing CONT. LINE INPUT
destroys the input buffer, so the command may not be edited
by Control/A for re-execution.

c. SWAP. The SWAP statement allows the values of two
variables to be exchanged. The format is as follows:

SWAP <variable,variable>

The value of the second variable is assigned to the first
variable and vice-versa. Either or both of the variables
may be elements of arrays. If one or both of the variables
are non-artay variables which have not had values assigned
to them, an ILLEGAL FUNCTION CALL error will result, Both
variables must be of the same type or a TYPE MISMATCH error
will result. Example:

if INPOT FS,4L$
28 SWAP FS,LS$

38 PRINT FS,L$
RUN


============================================================
Page 46
============================================================
lanuary, 1977 Page 34

?FIRST, LAST Data input
LAST FIRST Computer prints

ad. TRON, TROFF. As a debugging aid, two statements
are provided to trace the execution of program instructions.
When the trace flag is turned on by the TRON statement, the
number of each line in the program is printed as it is
executed. The numbers appear enclosed in square brackets
({]). The funetion is disabled by execution of the TROFF
statement. Example:

TRON executed in direct mode

OK printed by computer

10 PRINT 1:PRINT "A" typed by programmer

28 STOP

RUN

(19) 1 line numbers and output printed by
A computer.

[28]

BREAK IN 28

The NEW command will also turn off the trace flag.
@, QIF.«.THEN...ELSE. See section 2-2.
f. DEFINT, DEFSNG, DEFDBL, DEFSTR. See section 2-1

g. CONSOLE, WIDTH. CONSOLE allows the console
terminal ta be switched from one I/O part to another. The
format of the statement is:

CONSOLE <I/O port number>,<switch register setting>

The <I/O port number> is the hardware port number of the low
order (Status} port of the new 1/0 board. This value must
be a numeric expression between § and 255 inclusive. If it
is not in this range, an ILLEGAL FUNCTION CALL error will
occur. The <switch register setting> is also a value
between % and 255 inclusive which specifies the type of 1/0
port (SIO, PIO, 4PIO etc) being selected. Appropriate
values of the <switch register setting> may be found in
Appendix B in the table of sense switch settings or in the
table below.


============================================================
Page 47
============================================================
R ‘TY.

1977 Page 35

Table of values for <switch register setting>:

I/O Board Sense Switch
Setting
2SIO with 2 stop bits 4]
2810 with 1 stop bit 1
$10 2
ACR 3
4PIO 4
PIO 5
HSR 6
non-standard terminal 14
no terminal 1s

WIDTH Statement

The WIDTH statement sets the width in characters of the
printing terminal line. The format of the WIDTH statement
is as follows: .

WIDTHS <integer expression>
Example:

WIDTH 84
WIDTH 32

The <numeric formula> must have a value between 15 and 255
inclusive, or an ILLEGAL PUNCTION CALL error will occur.

h. Error Trapping. Extended and Disk Altair BASIC
make it possible for the user to write error detection and
handling routines which can attempt to recover from errors
or provide more complete explanation of the cause of errors
than the simple error messages, This facility has been
added to Altair BASIC through the use of the ON ERROR GOTO,
RESUME and ERROR statements and with the ERR and ERL
variables.

1} Enabling Error Trapping. The ON ERROR GOTO
Statement specifies the line of the Altair BASIC program on
which the error handling subroutine starts. The format is
as follows:

ON ERROR GOTO <line number>

============================================================
Page 48
============================================================
lanuary,

1977 Page 36

The ON ERROR GOTO statement should be executed before the
user expects any errors to occur. Once an ON ERROR GOTO
statement has been executed, all errors detected will cause
BASIC to start execution of the specified error handling
routine. If the <line number> specified in the ON ERROR
GOTO statement does not exist, an UNDEFINED LINE error will
occur,

Example:

18 ON ERROR GOTO 1004

2) Disabling the Error Routine. ON ERROR GOTO 4@
disables trapping of errors so any subsequent error will
cause BASIC to print an erroc message and stop program
execution. If an ON ERROR GOTO @ statement appears in an
error trapping subroutine, it will cause BASIC to stop and
print the error message which caused the trap. it is
recommended that all error trapping subroutines execute an
ON ERROR GOTO @ subroutine if an error is encountered for
which they have no recovery action.

NOTE

If an error occurs during the execution of an error
trap routine, the system error message will be
printed and execution will be terminated. Error
trapping does not trap errors within the error trap
routine, :

3) The ERR and ERL Variables. When the error handling
subroutine is entered, the variable ERR contains the error
code for the error. The error codes and their meanings are
listed below. See section 6-5 for a detailed discussion of
each of the errors and error messages.

ode Error
NEXT WITHOUT FOR
SYNTAX ERROR
RETURN WITHOUT GOSUB
OUT OF DATA
ILLEGAL FUNCTION CALL
OVERFLOW
OUT OF MEMORY
UNDEFINED LINE
SUBSCRIPT OUT OF RANGE

WO~AIHinwBwVeHO


============================================================
Page 49
============================================================
Bouary,

oe

1977 Page 37

16 REDIMENSIONED ARRAY

11 DIVISION BY ZERO

12 ILLEGAL DIRECT

13 TYPE MISMATCR

14 QUT OF STRING SPACE

15 STRING TOO LONG

16 STRING FORMULA TOO COMPLEX
17 CAN'T CONTINUE

18 DNDEFINED USER FUNCTION

19 UNPRINTABLE ERROR

20 NO RESUME © :

21 RESUME WITHOUT ERROR
22: MISSING OPERAND

23 LINE BUFFER OVERFLOW

Disk Errors

5a PIELD OVERFLOW

Si INTERNAL ERROR

52 BAD PILE NUMBER

53 FILE NOT FOUND

54 BAD FILE MODE

35 FILE ALREADY OPEN

56 DISK NOT MOUNTED

57 DISK I/O ERROR

538 FILE ALREADY EXISTS

59 SET TO NON-DISK STRING
68 DISK ALREADY MOUNTED
61 DISK FULL

62 INPUT PAST END

63 BAD RECORD NUMBER

64 BAD FILE NAME

65 MODE-MISMATCE

66 DIRECT STATEMENT IN FILE
67 TOO MANY FILES

68 OUT OF RANDOM BLOCKS

The BERL variable contains the line number of the line
where the error was detected. For instance, if the error
occured in line 1840, ERG will be equal to 10486. If the
statement which caused the error was a direct mode
Statement, ERL will be equal to 65535 decimal. To test if
an error occurred in a direct statement, use

IF 65535SERL THEN ...
In all other cases, use

IF ERL=<line number> THEN...


============================================================
Page 50
============================================================
january,

1977 Page 38

If the line number is on the left of the equation, it cannot
be renumbered by RENUM (see section l-la).

4) Disk Error Values - The ERR function. The ERR
function returns the parameters of a DISK I/O ERROR. ERR({Q}
returns the number of the disk, ERR(1) returns the track
number (0-76) and ERR(2) returns the sector number {8-31}.
ERR(3) and ERR(4) contain the low and high order bytes,
respectively, of the cumulative error count since BASIC was
loaded.

NOTE

Neither ERL nor ERR may appear to the left of the =
sign in a LET or assignment statement.

5) The RESUME statement. The RESUME statement is used
to continue execution of the BASIC program after the error
recovery procedure has been performed. The user has three
options. The user may RESUME execution at the statement
that caused the error, at the statement after the one that
caused the error or at some other line. To RESUME execution
at the statement which caused the error, thé user should
use:

RESUME
or
RESUME @

To RESUME execution at the statement immediately after the
one which caused the error, the user should use:

RESUME NEXT

To RESUME execution at a line dfferent than the one where
the error occurred, use:

RESUME <line number>
Where <line number> is not equal to zero.

6} Errore Routine Example. The following example shows
how a simple error trapping subroutine operates.


============================================================
Page 51
============================================================
[naary,

C

1977 Page 39

19@ ON BRROR GOTO 598

268 INPUT “WHAT ARE THE NUMBERS TO DIVIDE";X,¥
219 2=X/¥

220 PRINT "QUOTIENT IS";z

238 GOTO 29¢

5@@ IF ERR=1] AND ERL=21% THEN 526

51@ ON ERROR GOTO §

52@ PRINT “YOU CANT HAVE A DIVISOR OF ZERO!"
530 RESUME 20d

7) The ERROR statement. In order to force branching to
an error trapping routine, an ERROR statement has been
provided. The primary use of the ERROR statement is to
allow the user to define his own error codes which can then
conveniently be handled by a centralized error trap routine
as described above. The format of the ERROR statement is:

ERROR <integer expression>

When defining error codes, values should be picked which are
greater than the ones used by Altair BASIC. Since more
error messages may be added to Altair BASIC, user-defined
error codes should be assigned the highest possible numbers
to assure future compatibility. If the <numeric expression>
used in an ERROR statement is less than zero or greater than
255 decimal, an ILLEGAL FUNCTION CALL error will occur. Of
course, the ERROR statement may also be used to force SYNTAX
er other standard Altair BASIC errors. Use of an ERROR
statement to force printout of an error message for which no
error text is defined will cause an UNPRINTASLE ERROR
message to be printed out.

5-2. Extended Operators.

Two operators are provided that are exclusive to the
Extended and Disk versions.

a. Integer Division. Integer division, denoted by \
(backslash), forces its arguments to integer form and
truncates the quotient to an integer. More precisely:

A\B= FIX(INT(A) /IWT(B))
Its precedence is just after multiplication and floating

point divison. Integer division is approximately eight
times as fast as standard floating point division.


============================================================
Page 52
============================================================
fanuary,

1977 Page 40

b. Modulus Arithmetic - the MOD operator. 4&4 MOD B
gives the 'remainder‘' as A is divided by B. More precisely:

A MOD B=INT (A) -(INT(B)} * (A\B) ) q

If B=9, a DIVISION BY ZERO error occurs. The precedence of
MOD is just below that of integer division.

5-3, Extended Functions

a. Intrinsic Functions. Extended and Disk Altair
BASIC provide several intrinsic functions which are not
available in the other versions. For a list of these
functions and a description of their use, see section 6-3.

b. The DEFUSR statement. Up to ten assembly language
Subroutines may be defined by means of the DEFUSR statement
whose form is as follows:

DEFUSR[<digit 9 through 9>]<integer expression>
Example:

DEFUSR1=4100000
DEFUSR2231896
DEFUSR9=ADR

The of the <integer expression> is the starting address of q
the USR routine specified. When the USR subroutine is

entered, the A register contains the type of the argument

which was given to the USR function. This is also the

length of the descriptor for that argument type:

Value in A Meaning

2 Two byte signed two's complement integer.

3 String.

4 Singie precision four byte floating point number.
8 Deuble precision floating point number.

When the USR subroutine is entered, the [H,&] register pair
contains a pointer to the floating point accumulator (FAC).
The [E,L] registers contain the address of FAC-3.

If the value in the FAC is a single precision floating point
number, it is stored as follows:

PAC=3: Lowest 8 bits of mantissa.
FAC=-2: Middle 8 bits of mantissa.
PAC-1: Highest 7 bits of mantissa with hidden (implied)

leading one. Bit 7 is the sign of the number (9
positive, 1 negative).


============================================================
Page 53
============================================================
anuary,

C

1977 Page 41

PAC: Exponent excess 200 octal. If the contents of FAC is 200,
the exponent is @. If contents of FAC is O,the number is

ZErO.

If the argument is double precision floating point, the
FAC77 to FAC-4 contain four more bytes of mantissa, low
order byte in FAC-7, etc. If the argument is an integer,
FAC-3 contains the low order byte and FAC~2 contains the
high order byte of the signed two's complement value, If
the argument is a string, [D,E] points to a string
descriptor of the argument, whose form is:

Byte Use

a Length of string 8-255 decimal.

1-2 Sixteen bit address pointer to first byte of
strings text in memory (Caution - may point into
program text if argument is a string literal).

Normally, the value returned by a USR function will be the
same type (integer, string, single cor double precision
floating point) as the argument which was passed to it.
However, calling the MAKINT routine whose address is stored
in location 6 will return the integer in [H,L] as the value
of the function, forcing the value returned by the function
to be integer. Execute the following sequence to return
from the function:

PUSH R +SAVE VALUE TO BE RETURNED

LELD 6 ;GET ADDRESS OF MAKINT ROUTINE
&THL 7SAVE RETURN ON STACK &

. ;GET BACK [H,L]
RET + RETURN

The argument of the function may be forced to an integer, no
Matter what its type by calling the FRCINT routine whose
address is lecated in location 4 to get the integer value of
the argument in [H,L]: ;

LXI 8,SUB1 ;GET ADDRESS OF SUBROUTINE
; CONTINUATION

PUSH H ;PLACE ON STACK

LHLD 4 :GET ADDRESS OF FRCINT

PCHL 7;CALL FRCINT

SUB1: ..4..

5-4. The EDIT Command.


============================================================
Page 54
============================================================
fanuacy,

1977 Page 42

The EDIT command allows modifications and additions to
be made to existing program lines without having to retype
the entire line each time. Commands typed in the EDIT mode
are, as a fcule, not echoed. That is, they usually do not
appear on the terminal screen orc printout as they are typed.
Most commands may be preceded by an optional numeric
repetition factor which may be used to repeat the command a
number of times. This repetition factor should be in the
cange @ to 255 (§@ is equivalent to 1), If the repetition
factor is omitted, it is assumed to be 1. In the following
examples, a lower case "n” before the command stands for the
repetition factor. In the following description of the EDIT
commands, the “cursor” refers to a pointer which is
positioned at a character in the line being edited.

To EDIT a line, type EDIT followed by the number of the
line and hit the carriage return. The line number of the
line being EDITed will be printed followed by a space. The
cursor will now be positioned to the left of the first
character in the line.

NOTE

The best way of getting the “feel” of the EDIT
command is to try EDITing a few lines yourself.

If a command not recognized as an EDIT command is entered,
the computer prints a bell (control/G) and the command is
ignored.

In the following examples, the lines labelled “computer
prints” show the appearance of the line after each command.

a. Moving the Cursor, Typing a space moves the cursor
to the right and causes the character passed over to be
printed. A number preceding the space (n<space>) will cause
the cursor to pass over and print out n characters. Typing
a Rubeut causes the immediately previous character to be
printed effectively backspacing the cursor.

b. Inserting Characters

WARNINGS:

============================================================
Page 55
============================================================
anuary,

C

1977

Page 43

Character insertion is stopped by typing Escape
(or Altmode on some terminalis). Controi/c will not
interrupt the EDIT command while it is in Insert
mode, but will be inserted into the edited line.
Therefore, Control/C should not be used in the EDIT
command.

It is possible using EDIT to create a line
which, when listed with its line number, is longer
than 72 characters. Punched paper tapes containing
such lines will not read properly. However, such
lines may be CSAVEd and CLOADed without error.

I Inserts new characters into the line being edited.

Each character typed after the I is inserted at
the current cursor position and printed on the
terminal. Typing Escape (or Altmode on some
terminals) stops character insertion, If an
attempt is made to insert a character that will
make the line longer than 255 characters, a
Control/G {bell} is sent to the terminal and
the character is not printed.

A backarrow (or Rubout) typed during an insert
command {or=—) will delete the character to the left

of the cursor, Characters up to the beginning

the line may be deleted in this manner, and a
backarrow will be echoed for each character

deleted. However, if there are no characters to
the left of the cursor, a bell is echoed instead of

backarrow. If a carriage return is typed during

an insert command, it is as if an escape and then
carriage return were typed, That is, all
characters to the right of the cursor will be
printed and the EDIfed line will replace the
original line.

X is similar to I, except that all characters to

the right c£ the cursor are printed, and the cursor
moves to the end of the line. At this point, it
will automatically enter the insert mode { see I

command). xX is most useful when new statements are

to be added to the end of an existing line.

example:
User types EDIT 5@ (carriage return)
Computer prints 5¢
User types x
Computer prints 5@ X=X+1
User types :Y¥*Y+1(CR)
Computer prints 59 XaxX+1:Y=aYr+1

============================================================
Page 56
============================================================
January,

1977

Page 44

In the above example, the original line #56 was:
56 XeX+1

The new Line #58 now reads:

5@ XeX+1:Y2Y+1

H is the same as X, except that all characters to
the right of the cursor are deleted (they will not
be printed). The insert mode (see I command} will
then automatically be entered. H is most useful
when the last statements on a line are to be
teplaced with new ones.

Deleting Characters

nD deletes n characters to the right of the

cursor. [fn is ommitted, it defaults to 1. If
there are less than n characters to the right of
the cursor, characters will be deleted only to the
end of the line. The cursor is positioned to the
right of the last character deleted. The
characters deleted are enclosed in backslashes ({\).
For example:

User types 26 X=X+1:REM JUST INCREMENT X
User types EDIT 26 (carriage return)
Computer prints 28

User types 6D (carriage return)

Computer prints 28 \X=X+i:\REM JUST INCREMENT X

The new line #28 will no longer contain the characters

which are enclosed by the backslashes.

Searching.

The nSy command searches for the nth occurrence of the

character y in the line. WN defaults to 1. The
search skips over the first character to the right
of the cursor and begins with the second character
to the right of the cursor. All characters passed
over during the search are printed. If the
character is not found, the cursor will be at the
end of the line. If it is found, the cursor will
stop to the right of the character and ail of the
characters to its left will have been printed. For
example

User types
User types

+o te

EDIT 58

59 REM INCREMENT X

============================================================
Page 57
============================================================
hnuacy,

C

1977

£.

Carriage

Page 45

Computer prints 54
User types : 2SE
Computer prints 58 REM INCR

nKky is equivalent to S except that all of the
characters passed over during the search are
deleted. The deleted characters are enclosed in
backslashes. For example:

User types 18 TEST LINE
User types EDIT 18%
Computer prints 1a

User types RL
Computer prints 1@ \TEST \

Text Replacement.

A character in a line may be changed by the use of
the command Cy which changes the character to the
right of the cursor to the character y. Y is
printed on the terminal and the cursor is advanced

one position. nCy may be used to change non
characters in a line as they are typed in from the
terminal. (See example below.} If an attempt is

made to change a character which does not exist,
the change mode will be exited. Example:

User types 16 FOR I=1 TO 188
User types EDIT 19

Computer prints 12

User types 281

Computer prints 18 FOR Is] TO

User types 3C256
Computer prints 14 FOR I=1 TO 256

Ending and Restarting

Return Terminates editing and prints the re-
mainder of the line. The edited line replaces the
original line.

E ig the same as a carriage return, except the
remainder of the line is not printed.

Q restores the original line and causes BASIC to
return to command level. Changes do not take
effect until an E or carriage return is typed, 50 Q
allows the user to restore the original line
without any changes which may have been made.

L causes the remainder of the line to be printed, and
then prints the line number and restarts editing at


============================================================
Page 58
============================================================
anuary,

1977 Page 46

the beginning of the line. The cursoc will be
positioned to the left of the first character in
the line. L allows monitering the effect of
changes on a line. Example:

User types 5@ REM INCREMENT X
User types EDIT 56
Computer prints 58
User types 25M
Computer prints 5@ REM INCRE
User types L
Computer prints 50 REM INCREMENT X
58
A A causes the original line to be restored

and editing to be restarted at the beginning of the
line. For example:

User types 14 TEST LINE

User types EDIT 16

Computer prints 14

User types 18D

Computer prints 19 \TEST LINE\

User types

Computer prints 18 \TEST LINE\
1¢

In the above example, the user made a mistake when

he deleted TEST JCINE. Suppose that he wants to

type "15" instead of 18D, As a resuit of the A

command, the. original line 18 is reentered and is
_veady for further editing.

IMPORTANT
Whenever a SYNTAX ERROR is discovered during the execution
of a source program , BASIC will automatically begin EDITing
the line that caused the error as if an EDIT command had
been typed. Example:

16 APPLE

RUN

SYNTAX ERROR IN 19
18

Compiete editing of a line causes the line edited to be
reinserted. Reinserting a line causes all variable values
to be deleted. To preserve those values for examination,
the EDIT command mode may be exited with the Q command after
the line number is printed. If this is done, BASIC will
return to command level and all variable yalues will be
preserved.


============================================================
Page 59
============================================================
anuary,

Cc

1977 Page 47

The features of the EDIT command may be used on the
line currently being typed. To do this, type Control/A
instead of Carriage Return. The computer will respond with
a carriage return, an exclamation point (1) and a space.
The cursor will be positioned at the first character of the
line. At this point, any of the EDIT subcommands except
Control/A may be used to correct the line. Example:

User types 16 IF X GOTO #"/A
Computer prints {

User types St 2C12
Computer prints 1! 16 IF X GOTO 12

The current line number may be designated by a period
{.) in any command requiring a line number. Examples:

User types 16 FOR I= 1 TO 18

User types EDIT ,
Computer prints 16

5-5. PRINT USING statement.

The PRINT USING statement can be employed in situations

where a specific output format is desired. This situation.

might be encountered in such applications as printing
payroll checks or accounting reports. The general format
for the PRINT USING statement is as follows:

PRINT USING <string>;<value list>

The <string> may be a string variable , string expression or
a string constant which is a precise copy of the line to be
Printed. All of the characters in the string will be
printed just as they appear, with the exception of the
formatting characters. The <value list> is a list of the
items to be printed. The string will be repeatedly scanned
until: 1} the string ends and there are no values in the
value list or, 2) a fieid is scanned in the string, put the
value list is exhausted. The string is constructed
according to the following rules:

a. String Fields.

! specifies a single character string field.
(The string itself is specified in the value list.)
\n spaces\ Specifies a string field consisting of 2+n char-
acters, Backslashes with no spaces between them


============================================================
Page 60
============================================================
January,

1977 Page 48

would indicate a field of 2 characters width, one
Space between them would indicate a field 3
characters wide, etc.

In both cases above, if the string has more characters than
the field width, the extra characters will be ignored. I€
the string has fewer characters than the field width, extra
spaces will be printed to fill out the entire field. ‘Trying
to print a number in a string field will cause a TYPE
MISMATCH error to occur. Example:

18 AS="ABCDE" ;BS="FGH"
28 PRINT USING "1";AS;B$
38 PRINT USING "\ \";BS;AS

(the above would print out)

AP
FGE ABCD

Note that where the "!" was used only the first letter of
each string was printed. Where the backslashes enclosed two
spaces, four letters from each string were printed {an extra
space was printed for BS which has only three characters).
The extra characters in the first case and for A$ in the
second case were ignored,

b. Numeric Fields. With the PRINT USING statement,
numeric printouts may be altered to suit almost any
application. Strings for formatting numeric fields are
constructed from the following characters:

t ., Numeric fields are specified by the # sign, each of

; which will represent a digit position. These digit
positions are always filled. The numeric field
will be right justified; that is, if the number
printed is too smali to fill ail of the digit
positions specified, leading spaces will be printed
as necessary to fill the entire field.

° The decimal point may be specified in any position
in the field. Rounding is performed as necessary.
If the field format specifies that a digit is to
precede the decimal point, the digit will always be
printed (as O if necessary).

The following program will help illustrate these rules:


============================================================
Page 61
============================================================
anuary,

Cc

1977

$$

Page 49

1g INPUT AS,A
26 PRINT USING AS;A
38 GOTO 14
RUN
? #3,12
12

? $#%,12
12

2 $8832 ,12
12
PHE. FH, 12
12.88
? $3%.,12
12.
? F.883, 82
4.929
Pet. F, 2.36
2.4
2382 ,-12
-12
PR .FE ~~ 12
~.12
PHERE 12
“12

The + sign may be used at either the beginning or
end of the numeric field, If the number is
positive, the + sign will be printed at the
specified end of the number. If the number is
negative, a - sign will be printed at the specified
end of the number,

The - sign, when used to the right of the numeric
field designation, will force the minus sign to be
printed to the right of the number if it is
negative. If the number is positive, a space is
printed.

The ** placed at the beginning of a numeric field
designation will cause any unused spaces in the
leading portion of the number printed out to be
filled with asterisks. The ** also specifies
positions for 2 more digits. (Termed “asterisk
£ill*)

When the $$ is used at the beginning of 42 numeric

field designation, a $ sign will be printed in the
space immediately preceding the number printed.
Note that $$ also specifies positions for two more
digits, but that the $ itself takes up one of these
Spaces. Exponential format cannot be used with
leading $ signs, nor can negative numbers be output

============================================================
Page 62
============================================================
Anuary,

1977

RS

AAAA

Page 56

unless the sign is forced to be trailing.

The **§ used at the beginning of a numeric field
designation causes both of the above (** and $$} to
be performed on the number being printed cut. All
of the previous conditions apply, except that **$
allows for 3 additional digit positions, one of
which is the $ sign.

A comma appearing to the left of the decimal point
in a numeric field, designation will cause a comma
to be printed to the left of every third digit to
the left of the decimal point in the number being
printed. The comma also specifies another digit
position. A comma to the right of the decimal
point in a numeric field designation is considered
a part of the string itself and is treated as a
printing character.

(hb ddon some terminals) Exponential Format.

If exponential format is desired in the printout,
the numeric field designation should be followed by
“ee* (allows space for E+XX). Any decimal point
arrangement is allowed. The significant digits are
left justified and the exponent is adjusted.
Uniess a leading + or a trailing + or - is used,
one position to the left of the decimal point will
be used to print a space or minus sign. Examples: -

PRINT USING “[##7°"*]"; 13,17,-8

{ LE+G1}[ 22+91] [-8E+02]

OK

PRINT USING "[.###844°°** =]; 12345,-123456
[-123459E+05 ][.1234566+06-]

OK

PRINT USING "{+.9#°°**}"; 123,~-126
[+.12E+93] [-.138+23]

OK

If the number to be printed out is larger than the
specified numeric field, a % character will he
printed followed by the number itself in standard
Altair BASIC format. (The user will see the entire
number.) If rounding a number causes it to exceed
the specified field, the % character will be
printed followed by the rounded number. If, for
example, A=.999, then

PRINT USING ".#2",A

will print


============================================================
Page 63
============================================================
Anuary,

C.

1977 : Page Sl

$1.86,

Tf the number of digits specified exceeds 24, an
ILLEGAL FUNCTION CALL error will occur.

The following program will help illustrate the
preceding rules.

Program: 10 INPUT AS,A
28 PRINT USING AS;A
36 GOTO 18
RUN

The computer will start by typing a ?. The numeric field
designator and value list are entered and the output is
displayed as follows:

2 +#,9

+9

? +#,10
$+10

? t#,-2

~2

? +#,-2

=2

? #,-2

9~2

2 +.9##,-82

+.025

2? ##2% .$,18G
192.9

2? t#+,2

2+

? THIS IS A NUMBER ##,2
THIS IS A NUMBER 2
? BEFORE #$ AFTER,12
BEFORE 12 AFTER

? $4#2,44444

344444

? **##,1

eee)

2 **HS,12

*#*T2

2 **$2,123

*123

? **##,1234

1234

? **#2,12345

$12345

2? ¥**,1

x1

P **,22


============================================================
Page 64
============================================================
Anuacy, 1977 Page 52
22
? **.33,12
12.08
? **eeee,1
eee)
(mete: not floating $) 2? S#$ee.##,12.34
$ 12.34
(note: floating $) ? SS#oee.##,22.56
$12.56
? $$.##,1.23
$1.23
? $$.##,12.34
%$12.34
? $S###,8.23
$6
2? SStheh. FF, 0
$0.88
? **S$8¢.$#,1.23
weeeST. 23
2 **5.$4,1.23
*$1.23
? **$$3,1
weet]
? #,6.9
7
? #.$,6.99
7.8
2
? t#~,~2
3-
? €9+,2
2+
P Ft4-~-2
2-
ra: ry
ZE+88
2 3g°°**,12
LE+@1
2 $Rthh.899°°7", 2.45678
2456. 7808-83
? ¢.###°°**,123
@.123E+03
2 #9877", 123
-.12E+63
2? “Hdeee FEF. #",1234567.89
1,234,570.
Typing Control/c will stop the program.
5-6. Disk file operations.


============================================================
Page 65
============================================================
january,

1977 Page 53

AS many as sixteen floppy disks may be connected to a
single ALTAIR disk controller. These disks have been
assigned the physical disk numbers @ through 15. Users with
one drive should address the drive at zero, and users with
two drives should address them at zero and one, etc.

In the following descriptions, <disk number> is an
integer expression whose value is the physical number of one
of the disks in the system. If the <disk number> is omitted
from a statement other than MOUNT or UNLOAD, the <disk
number> defaults to @. If the <disk number> is omitted from
a MOUNT or UNLOAD statement, disks @ through the highest
disk number specified at initialization are affected.

a. Opening, Closing and Waming Files. To initialize
disks for reading and writing, the the MOUNT command is
issued as follows:

MOUNT [<disk number>[,<disk number>...]]
Example:

MOUNT @
Mounts the disk on drive zero, and

MOUNT @,1
Mounts the disks on drives zero and one. Tf there is
already a disk MOUNTed on the specified drive(s) a
DISK ALREADY MOUNTED message will be printed. Before
removing a disk which has been used for reading and writing
by- Disk Altair BASIC, the user should give an UNLOAD
command:

UNLOAD [<disk number>[,<disk number>...]]
UNLOAD closes all the files open on a disk, and marks the

disk as not mounted. Before any further I/O is done on an
UNLOADed disk, a MOUNT command must be given.

NOTE

MOUNT, UNLOAD or any other disk command may be used
aS a@ program Statement.

All data and program files on the disk have an associated
file name, This name is the result of evaluating a string


============================================================
Page 66
============================================================
fanuary,

1977 Page 54

expression and must be one to eight characters in length.
The first character of the file name cannot be a null (6) Jd
byte or a byte of 255 decimal. An attempt to use a null

file name {zero characters in length) , a file name over 8
characters in length or containing a @ or 255 in the first
character position will cause a BAD FILE NAME error. Any

other sequence of one to eight characters is acceptabie.

Examples of valid file names:

ABC

abc {Not the same as ABC)
filename

file.ext

12345678

INVNTORY

FILE#$22

NOTE

Commands that require a file name will use <file
name> in the appropriate position. Remember that a

<file name> can be any string expression as long as
the resulting string follows the rules given above.

b. The FILES Command. The FILES command is used to
print out the names of the files residing on a particular
disk. The format of the FILES command is:

FILES <disk number>

Example:
FILES {prints directory of files on disk @}
STRTRK PIP CURFIT CISASM

Execution of the FILES command may be interrupted by typing
Controi/c. A more complete listing of the information
stored in a particular file may be obtained by running the
PIP utility program (see Appendix I}.

c. SAVEing and LOADing programs. Once a program has
been written, it is often desirable to save it on a disk for
use at a later time. This is accomplished by issuing a SAVE
command: q


============================================================
Page 67
============================================================
anuary,

CU

1977 Page 55

SAVE <file name>[,<disk number>[,A]}]

Example:

SAVE "TEST",@
or

SAVE "TEST"

would save the program TEST on disk zero. Whenever a
program is SAVEd, any existing copy of the program
previously SAVEd will be deleted, and the disk space used by
the previous program is made available. See section 5-64
for a discussion of saving with the 'A' option.

The LOAD statement reads a file from disk and loads it
into memory. The syntax of the LOAD statement is:

LOAD <file name>[,<disk number>[,R] ]
Correspondingly:
LOAD "TEST*,@ of LOAD "TEST"

loads the program TEST from disk zero. If the file does not
exist, a FILE NOT FOUND error will occur. :

LOAD “TEST",G,R
OK

LOADs the program TEST from disk zero and runs it. The LOAD
command with the "R" option may be used to chain or segment
programs into small pieces if the whole program is too large
to fit in the computer's memory. All variables and program
lines are deleted by LOAD, Sut all data files are kept
OPEN{see below} if the “R" option is used. Therefore,
information may be passed between programs through the use
of disk data files. If the "R" option is not used, all
files are automatically CLOSEd (see below} by a LOAD.

Example:

NEW
16 PRINT "FOO1":LOAD "FOO2",4,R
SAVE "FOO1",@

OK
14 PRINT *FOO2":LOAD "FOO1",9,-R
SAVE “FOO2",8

============================================================
Page 68
============================================================
january,

1977 Page 56

OK

RUN
FOO2
FOOL
FOO2
FOOL
o2.@tc,

({Control/c may be used to stop execution at this point)

In this example, program FOO2 is RUN. FOO2 prints the
message "FOO2" and then calls the program FOO1 on disk.
FOO] prints *POOl" and calls the program FOO2 which prints
"FOO2" and so on indefinitely.

RUN may also be used with a file name to load and run a
Program. The format of the command is as follows:

RUN<file name>[{,<disk number>[,R]]

All files are closed uniess ,R is specified after the disk
number,

d. SAVEing and LOADing Program Files in ASCII. Often
it is desirable to save a program in a form that allows the
program text to be read as data by another program, such as
a text editor or resequencing program. Unless otherwise
specified, Altair BASIC saves its programs in a compressed
binary format which takes a minimum of disk space and loads
very guickly. To save a program in ASCII, specify the "A"
option on the SAVE command:

SAVE "TEST",4,A
OK
LOAD "TEST",@
OK
Information in the file tells the LOAD command the

format in which the file is to be loaded. The first
character of an ASCII file is never 255, and a binary
program file always starts with 255 (377 octal). Remember,
loading an ASCII file is much slower than loading a binary
file.


============================================================
Page 69
============================================================
Inuary,s

Cc

1977 Page 57

e. The MERGE Command. Sometimes it is very useful to
put parts of two programs together to form a new program
combining elements of both programs. The MERGE command is
provided for this purpose. As soon as the MERGE command has
been executed, BASIC returns to command level. Therefore it
is more likely that MERGE would be used as a direct command
than as a statement in a program. The format of the MERGE
statement is as follows:

MERGE <file name>[,<disk number>]
Example:

MERGE “PRINTSUB",1
ORK

The <file name> specified is merged into the program already
in memory. The <file name> must specify an ASCII format
saved program orf a BAD FILE MODE error will occur. If there
are lines in the program on disk which have the same line
numbers as lines in the program in memory, the lines from
the file on dGisk will replace the corresponding program
lines in memory. It is as if the program lines of the file
on disk were typed on the user terminal.

£. Deleting Disk Files. The KILL statement deletes a
file from disk and returns disk space used by the file to
free disk space. The format of the KILL statement is ag
folicws:

KILL <file name>[(,<disk number>]
If the file does not exist, a FILE NOT FOUND error will
occur. If a KILL statement is given for a file that is

currently OPEN (see below), a FILE ALREADY OPEN error
oceurs,

g. Renaming Files - the NAME Statement. The NAME
statement is used to change the name of a file:

NAME <old file name> AS <new file name>[,<disk number>]
Example:
NAME “OLDFILE" AS “WNEWPILE”
The <old file name> must exist, or a FILE NOT FOUND error
will occur. A file with the same name as <new file name>

must not exist or a FILE ALREADY EXISTS error will occur.
After the NAME statement is executed, the file exists on the

============================================================
Page 70
============================================================
fanuary,

1977 Page 58

same disk in the same area of disk space. Only the name is
changed.

h. OPENing Data Files. Before a program can read or
write data to a disk file, it must first OPEN the file on
the appropriate disk in one of several modes. The general
form of the OPEN statement is:

OPEN <mode>, [#}]<file number>,<file name>[,<disk number>]

<mode> is a string expression whose first character is one
of the following:

Specifies sequential output mode
Specifies sequential input mode
Specifies random Input/Output mode

WHO

A sequential file is a stream of characters that is read or
written in order much like INPUT and PRINT statements read
Erom and write to the terminal. Random files are divided
into groups of 128 characters called records. The nth
record of a file may be read or written at any time, Random
files have other attributes that will be discussed later in
more detail.

<file number> is an integer expression between one and
fifteen. The number is associated with the file being
OPENed and is used to refer to the file in later I/0
operations,

Examples:

OPEN "0",2,"°OUTPUT",9
OPEN "I",1,"INPUT”

The above two statements would open the file OUTPUT for
sequential output and the file INPUT for sequential input on
disk zero.

OPEN MS$,N,FS,D

The above statement would open the file whose name was in
the string F$ in mode M$ as File number N on disk D.

i. Sequential ASCII file I/O Sequential input and
Output Files are the simplest form of disk input and output
since they involve the use of the INPUT and PRINT statements


============================================================
Page 71
============================================================
Anuary,

C

1977 Page 59

with a file that has been previously OPENed.
INPUT is used to cead data from a disk file as follows:

INPUT #<file number>,<variabls list>

where <file mumber> represents the number of the file that
was OPENed for input and <variable list> is a list of the
variables to be read, as in a normal INPUT statement. When
data is read from a sequential input file using an INPUT
Statement, mo question mark (7) is printed on the terminal.
The format of data in the file should appear exactly as it
would be typed to a standard INPUT statement to the
terminal. When reading numeric values, leading spaces,
carriage returns and line feeds are ignored. When a
non-space, non-carriage return, non-line-feed character is
found, it is assumed to be part of a number in Altair BASIC
format, The number terminates on a space, a carriage return
, line~feed or a comma.

When scanning for string items, leading blanks,
carriage returns and line-feeds are also ignored. When a
character which is not a leading blank, carriage return or
line~feed is found, it is assumed to be the start of a
string item.If this first character is a quotation mark (")
the item is taken as being a quoted string, and all
characters between the first double quote (") and a matching
double guote are returned as characters in the string value.
This means that a quoted string in a file may contain any
characters except double quote. If the first character of a
string item is not a quotation mark, then it is assumed to
be an unquoted string constant. The string returned will
terminate on a comma, carriage return or line feed. The
string is immediately terminated after 255 characters have
been read.

For both numeric and string items, if. end of file (EOF)
is reached when the item is being INPUT, the item is
terminated regardless of whether or not a closing quote was
seen.

Sequential I/O commands destroy the input buffer so
they may not be edited by Control/A for re-execution.

Example of sequential [/0O (numeric items):

598 OPEN *O",1,"“FILE",9
516 PRINT #1,X,Y¥,2Z
520 CLOSE #1

============================================================
Page 72
============================================================
fanuary,

1977 Page 6@

538 OPEN *I",1,*FILE",9
540 INPUT #1",X,Y¥,Z

Note that CLOSE is used so that a file which has just been
written may be read. When FILE is re-OPENed, the data
pointer for that file is set back to the beginning of the
file so that the first INPUT on the file will read data from
the start of the file.

2) PRINT and PRINT USING statements are used to write
data into a sequential output file. Their formats are as
follows:

PRINT ¢<file number>,<expression list>

or

PRINT #<file number>,
USING <string expression>;<expression list>

Example of sequential I/0 (quoted string items):

588 OPEN "0",1,°FILE"

512 PRINT #1,CHRS$ (34) ;X$;CHRS{34);

515 PRINT #1,CHRS {34) ;¥$;CHRS (34) ;CHRS (34) ;}2$;CHRS (34)
52@ CLOSE 1

534 OPEN "I",2,"PILE",6

546 INPUT #1,XS$,Y$,258

In this example, the strings being output (X$, Y$, 2S) are
surrounded with double quotes through the use of the CHRS
function to generate the ASCII value for a double quote.
This technique must be used if a string which is being
output to a sequential data file contains commas, carriage
returns, line-feeds or leading blanks that are significant.
When leading blanks are not significant and there are no
commas, carriage returns or line-feeds in the strings to be
output, it is sufficient to insert commas between the
strings being output as in the following example:

59% OPEN “O",1,"FILE"

514 PRINT #1,X$;",";¥S7",%728
52a CLOSE 1

$38 OPEN "I",1,'FILE",@

540 INPUT #1,X$,%$,2$

3} CLOSE. The format of the CLOSE statement is as
follows:

CLOSE [<file number>{,<file number>...]]


============================================================
Page 73
============================================================
inuary,

C

1977 Page 61

CLOSE is used to finish I/O to a particular Altair BASIC
data file. After CLOSE has been executed for a file, the
file may be rceOPENed for input or output on the same or
different <file number>. A CLOSE for a sequential output
file writes the final buffer of output. A CLOSE to any OPEN
file finishes the connection between the <file number> and
the <file name> given in the OPEN for that file. [It allows
the <file number> to be used again in another OPEN
statement.

A CLOSE with no argument CLOSEs all OPEN files.

NOTE

A FILE can be OPENed for sequential input or random
accesS on more than one <file number> at a time but
may be OFEN for output on only one <file number> at
a time.

END and NEW always CLOSE all disk files automatically. STOP
does not CLOSE disk files. ;

4) LINE INPUT. Often it is desirable to read a whole
line of a file into a string without using quotes, commas or
other characters as delimiters. This is especially true if
certain fields of each line are being used to contain data
items, or if a BASIC program saved in ASCII mode is heing
read as data by another program. The facility provided to
perform this function is the LINE INPUT statement:

LINE INPUT #<file number>,<string variable>

A LINE INPUT from a data file will return all characters up
to a carriage return in <string variable>. LINE INPUT then
skips over the following carriage return/line-feed sequence
so that a subsequent LINE INPUT from the file will return
the next line.

5) End@ of File {EOF) Detection. When reading a
sequential data file witn INPOT statements it is usually
desirable to detect when there is no more data in the disk
file. The mechanism for detecting this condition is the EOF
function:

X=EOP(<file number>}

EOF returns TRUE (-1) when there is no more data in the file
and FALSE (@#) otherwise. If an attempt is made ta INPUT

============================================================
Page 74
============================================================
anuary,

1977 Page 62

past the end of a data file, an INPUT PAST END error will
occur.

Example:

186 OPEN "I°,1,"DATA",@
119 {t=6

120 IF EOF(1) THEN 1686
138 INPUT #1,A(1)

146 [=I+1

158 GOTO 129

16GB wceuee

In this example, numeric data from the sequential input file
DATA is read into the array A. When end of file is
detected, the IF statement at line 128 branches to line 160,
and the variable I "points" one beyond the last element of A
that was INPUT from the file.

The following is a program that will calculate the
number of lines in a BASIC program file that has been SAVEd
in ASCII mode:

10 INPUT "WBAT IS THE NAME OF THE PROGRAM"; PS
29 OPEN "1I",1,P$,9

39 I=g

“49 IF EOF(1) THEN 74

58 I=I+]:LINE INPUT #1,L$

68 GOTO 44
70 PRINT "PROGRAM ";P$;" IS ";1;"% LINES LONG”
88 END

This example uses the LINE INPUT statement to read each line
of the program into the "dummy" string L$ which is used just
to INPUT and ignore that part of the file.

6) Finding the Amount of Free Disk Space (DSKF). It is.

sometimes necessary to determine the amount of free disk
space remaining on a particular disk before allocating
(writing) a file. The DSKF function provides the user with
the number of free groups left on a given disk, after the
disk has been MOUNTed. A group is the fundamental unit of
file allocation. That is, files are always allocated in
groups of eight sectors at a time. Each sector contains 128
characters (bytes). Therefore, the minimum size for a file
ts 1824 bytes.

Syntax for the DSKF function:
DSKF{<disk number>)

Example:

============================================================
Page 75
============================================================
AnuUary,

CL

1977 Page 63

PRINT DSKF(#)
209

The above example shows that there are 200*1824=204800
characters (bytes) that can still be stored on disk zero.

}. RANDOM FILE I/O. Previously, we have discussed how
data may be PRINTed or INPUT from sequential data files.
However, it is often desirable to access data in a random
fashion, for instance to retrieve information on a
particular part number or customer from a large data base
stored on a floppy disk. If sequential files were used, the
whole file would have to be scanned from the start until the
particular item was found. Random files remove this
restriction and allow a program to access any record from
the first to the last in a speedy fashion. Also, random
files transfer data from variables to the disk ouput records
and vice versa in a much faster, more efficient fashion than
sequential files. Random file I/0 is mere complex than
sequential I/0, and it is recommended that beginners try
sequential 1/0 first.

1) OPENing a FILE for Random I/O. Random I/O files are
OPENed just like sequential files. . .

OPEN “R",1,"RANDON", @

When a file is OPENed for random 1/0, it is always OPEN for
both input and output simultaneously.

2) CLOSING Random Files, Like sequential files, random
files must be closed when I/0 operations are finished. To
CLOSE a random fiie, use the CLOSE command as described
previously.

CLOSE <file number>(,<file number>...]

3) Reading and writing data to a random file ~ GET and
PUT. Each random file has associated with it a “random
buffer" of 128 bytes. When a GET or PUT operation is
performed, data is transferred directly from the buffer to
the data file or from the data file to the buffer. The
syntax of GET and PUT is as follows;


============================================================
Page 76
============================================================
1977 Page 64

PUT (#}<£ile number>[,<record number>]
GET [#]<£ile number>[,<record number>])

If <record number> is omitted from a GET or PUT statement,
the record number that is one higher than the previous GET
or PUT is read into the random buffer. Initially a GET or
PUT without a record number will read or write the first
record. The largest possible record number is 2946. If an
attempt is made to GET a record which has never heen PUT,
all zeroes are read into the record, and no error occurs,

4) LOC and LOF. LOC is used to determine what the
current record number is for random files. In other words,
it returns the record number that will be used if a GET or
PUT is executed with the <record number> parameter omitted,

LOC (<file number>})

PRINT LOC(1)
is

LOC is aiso valid for sequential files, and gives the number
ef sectors (128 byte blocks) read or written since the OPEN
statement was executed.

LOF is used to determine the last record number written to a
random file:

LOF(<£ile number>)

PRINT LOF(2)}
290

An attempt to use LOF on a sequential file will cause a BAD
FILE MODE error.

The value returned by LOF is always 5 MOD &. That is , when
the value LOF returns is divided by 8, the remainder is
always 5. Therefore,the values returned by LOF are 5, 13,
21, 29 etc. This is due to the way random files are
allocated.


============================================================
Page 77
============================================================
January, 1977 Page 65

NOTE

It is important to note that the value returned by
LOF may be a record that has never been written in
by a user program. This is because of the way
random files are pre-extended.

5) Moving Data In an@ Out of the Random Buffer. So far
we have described techniques for writing (PUT} and reading
(GET) data from a file into its associated random buffer.
Now we will describe how data from string variables is moved
to and from the random buffer itself. This is accomplished
through the use of the FIELD, LSET and RSET statements,

6} FIELD. The FIELD statement associates some or all
of a file's random buffer with a particular string variable.
Then, when the file buffer is read with GET or written with
PUT, string variables which have been PIELDed into the
buffer will automatically have their contents read or
written. The format of the FIELD statement is:

FIELD [#] <file number> ,<field size> AS <string variable>{...]

<file number> is used to specify the file number of the file
whose random buffer is being referenced. If the file is not
a random file, a BAD FILE MODE error will occur. <field
size> sets the length of the string in the random buffer.
<string variable> is the string variable which is associated
with a certain number of characters (bytes) in the buffer.
Multiple fields may be associated with string variables in a
given FIELD statement. Each successive string variable is
assigned a successive field in the random buffer. Example:

PIBLD 14 AS AS, 28 AS BS, 34 AS C$

The statement above would assign the first 18 characters of
the candom buffer to the string variable A$, the next 26
characters to BS and the next 34 characters to the variable
C$. It is important to note that the FIELD statement does
not cause any data to be transferred to or from the random
buffer. It only causes the string variables given as
arguments to "point" into the random buffer.

Often, it is necessary to divide the random buffer into
a number of sub-records to make more efficient use of disk
Space. For instance, it might be desirable to divide the
128 character record into two identical subrecords., To
accomplish this a "dummy variable" would be placed in the
FIELD statement to represent one of the subrecords. One af
the following statements would be executed depending on
whether the first or second subrecord were needed:

============================================================
Page 78
============================================================
January,

1977 Page 66

FIELD #1,64 AS DS, 28 AS NAMES,
28 AS ADDRESSES, 24 AS OCCUPATIONS

or

- FIELD $1,208 AS NAMES, 20 AS ADDRESSES,
24 AS OCCUPATIONS, 64 AS DS

where the dummy variable DS is used to skip over one of the
subrecords, Another way to do the same thing would be to
set a variable I that would select the first or second
subrecord,

FIELD $#1,64*(I-1) AS DS,
20 AS NAMES, 28 AS ADDRESSS, 24 AS OCCUPATIONS

Here, if the variable I is one, I-l *64 =@ characters will
be skipped over, selecting the first subrecord. If I is
two, 64 characters will be skipped over, selecting the
second subrecord. Another technique that is very useful is
to use & FPOR...NEXT loop and an array to set up subrecords
in the random buffer:

1484 FOR I=1 TO 16

1016 FIELD #1, (I-1}*8 AS DS, 4 AS AS{I),
4 AS B${I) .

102@ NEXT I

In this example, we have divided the random buffer into 16
subrecords composed of two fields each. The first
4-character field is in A$(X) and the second 4-character
field is in BS(X,} where X is the subrecord number.

NOTE

The FIELD statement may be executed any number of
times on a given file. It dees not cause any
allocation of string space. The only space
allocation that occurs is for the string variables
mentioned in the FIELD statement. These string
variables have a one byte count and two byte pointer
set up which points into the random buffer for the

specified file.

============================================================
Page 79
============================================================
Anuary, 1977 Page 67

C 7) Using Numeric Values in Random Files: MKIS$, MKSS$,
MKDS$ and CVI, CVS, CVD. As we have seen, data is always
stored in the random buffer through the use of string
variables. In order to convert between strings and numbers

and vice versa, a number of special functions have been
provided.

fo convert between numbers and strings:

MKI$(<integer value>) Returns a two byte string

(FC error if value is not

>#-32768 and <=+32767.

Fractional part is lost)
MKSS$(<single precision value>) Returne a four byte string
MKD$ (<double pracision value>) Returns an eight byte string

To convert between strings and numbers:

CVI (<two byte string>) Returns an integer value
CVS (<four byte string>} Returns a single precision valu
CvD(<eight byte string>} Returns a double precision value

CVI, CVS, and CVD all give an ILLEGAL FUNCTION CALL error if
the string given as the argument is shorter than required.

C, If the string argument is longer than necessary, the extra
characters are ignored. These functions are extremely fast,
since they convert between Altair BASIC's internal
representations of integers, single and double precision
values and strings. Conventional sequential 1/0 must
perform time-consuming character scanning algorithms when
converting between numbers and strings.

8. USET and RSET. When a GET operation is performed,
all string variables which have been FIELDed into the random
buffer for that file automatically have values assigned to
them, The CVI, CVS and CVD functions may be used to convert
any numeric fields in the record to their numeric values.
When going the other way, i.e. inserting strings into the
candom buffer before performing a PUT statement, a problem
arises, This is because of the way string assignments
usually take place, For example:

LET AS=B$

When a LET statement is executed, B$ is copied into string
space, A$ is pointed to the new string and the string length
of AS is modified. However, for assignments into the random
buffers we do not want this to happen. Instead, we want the
Cc string being assigned to be stored where the string variable
was FIELDed. In order to do this, two special assignment


============================================================
Page 80
============================================================
anuary,

1977 Page 68

statements have been provided, LSET and RSET:
LSET <string variable>=<string expression>
RSET <string variable>=<string expression>

Examples:
LSET A$=MKS$ (V)
RSET BS="TEST”
LSET C$ (I) =MKDS$ (D#)

The difference between LSET and RSET concerns what happens
if the string value being assigned is shorter than the
length specified for the string variable in the FIELD
statement. LSET left justifies the string, adding blanks
(octal 48, decimal 32) to pad out the right side of the
string 1£ it is teo short. RSET right justifies the string,
padding on the left. If the string value is too long, the
extra characters at the end of the string are ignored.

NOTE

Do not use LSET or RSET on string variables which
have not been mentioned in a FIELD statement, or a
SET TO NON DISK STRING error will occur,

k. The DSKI$ and DSKO$ Primitives. Often it is
mecessary for the user to perform disk I/O operations
directly without using any of the normal file structure
features of Altair BASIC. To allow this, two special
functions have been provided. These are the DSKIS$ function
and the DSKO$ statement. First we will give examples of how
to perform simple disk I/O commands using Altair BASIC
statements,

To Enable disk @:
OUT 8,4@
To Enable disk N:
OUT 8,N
TO step the disk head out one track:

WAIT 8,2,2:O00T 9,2


============================================================
Page 81
============================================================
CU

Anwary,

1977 Page 69

To step the disk head in one track:
WAIT 8,2,2:00T 9,1
To test for track @:
IF (INP(8) AND 64})=4 THEN <statements or line number>

The above will execute the statements or branch to the line
number if the head is positioned at track @. This is the
Outermost track on the disk.

To read sector Y (Y may be any expression, minimum sector
=$, maximum = 31):

AS=DSKI$ (¥)

The statement
DSKOS <string expression>,<sector expression>

writes the string expression on the sector specified. The
high order bit (most signifigant) of the first character
output will always be set to one when the string is written
on the sector, and thus will always be one when the gector
is read back in using DSKI$. A maximum of 137 characters
are written; giving a string whose length exceeds 137
characters will cause an ILLEGAL FUNCTION CALL error. If
the string argument is less than 137 characters in length,
the end of the string will be padded with zeros to make a
string of length 137.

============================================================
Page 82
============================================================
1977 Page 7¢

6. LISTS AND DIRECTORIES

1 Commands.

Commands direct Altair BASIC to arrange memory and
input/output facilities, to list and edit programs and to
handle other housekeeping details in support of program
execution. Altair BASIC accepts commands after it prints
'OK' and is at command level. The table below lists the
commands in alphabetical order. The notation to the right
of the command name indicates the versions to which it
applies,

Command Version (s)
CLEAR All

Sets all program variables to zero.
CLEAR[<expression>] 8K, Extended, Disk

Same as CLEAR but sets string space to the value of the
expression. If no argument is given, string space will
remain unchanged. When Altair BASIC is loaded, string space
is set to 50 bytes in 8K and 200 bytes in extended,

CLOAD<string expression> 8K (cassette), Extended, Disk
Causes the program on cassette tape designated by the first
character of STRING expression> to be loaded into memory. A
NEW command is issued before the program is loaded,
CLOAD?<string expression> 8K(cassette), Extended, Disk
Compares the program in memory with the file on cassette
with the same name. If they are the same, BASIC prints OK.
If not, BASIC prints NO GOOD.

CLOAD*<array name> 8K (cassette), Disk

Loads the specified array from cassette tape. May be used
as 4& orogram statement

CONT 8K, Extended, Disk

Continues program execution after a Control/C has been typed
or a STOP or END statement has bean executed, Execution
resumes at the statement after the break occurred unless
input from the terminal was interrupted. In that case,

============================================================
Page 83
============================================================
anuary, 1977 Page 71

execution resumes with the reprinting of the prompt (? or
prompt string}. CONT is useful in debugging, especially

Cc where an ‘infinite loop' is suspected. An infinite loop is
a Series of statements from which there is no escape.
Typing Controi/c causes a break in execution and puts BASIC
in command level. Direct mode statements can then be used
to print intermediate values, change the values of
variables, etc. Execution can be restarted by typing the
CONT command, or by executing a direct mode GOTO statement,
which causes execution to resume at the specified line
number.

In 4K and a&K Altair BASIC, execution cannot be
continued if a direct mode error has occured during the
break. In all versions, execution cannot continue if the
program was modified during the break.

CSAVE<string expression> 8K(cassetts), Extended, Disk

Causes the program currently in memory to he saved on
cassette tape under the name specified by the first
character of <string expression>.

CSAVE*<array name> 8K (cassette), Disk

Causes the array named to be saved on cassette tape. May be
C used as a@ program statement.

DELETE<line number> Extended, Disk

Deletes the line in the current program with the specified
number. If no such line exists, an ILLEGAL FUNCTION CALL
error occurs.

DELETE~<line number > Extended, .Disk

Deletes every line of the current program up to and
including the specified line. If there is no such line, an
ILLEGAL FUNCTION CALL error occurs.

DELETE<line number>-<line number> Extended, Disk

Deletes ail lines of the current program from the first line
number to the second inclusive. ILLEGAL FUNCTION CALL
eceurs if no line has the second number,

EDIT<line number> Extended, Disk

Allows editing of the line specified without affecting any

other lines. The EDIT command has a powerful set of
sub-commands which are discussed in detail in section 5-4,


============================================================
Page 84
============================================================
fanuary,

1977 Page 72

LIS? All

Lists the program currently in memory starting with the
lowest numbered line. Listing is terminated either by the
end of the program or by typing Control/c.

LIST{<line number>] All

In 4K and 8K, prints the current program beginning at the
specified line. In Extended and Disk, prints the specified
line if it exists.

LISTi<line number>}[-<line number>] Extended, Disk
Allows several listing options.

1. If the second number is omitted, lists all lines with
numbers greater than or equal to the number specified.

2. Tf the first number is omitted, lists all lines from
the beginning of the program to the specified line,
inclusive.

3. If both line numbers are used, lists all lines from the
first number toa the second, inclusive.

LLIST[<line number>] [-<line number>] Extended, Disk

Same as list with the same options, except prints on the
line printer.

NEW All

Deletes the current program and clears all variables. Used
before antering a new program.

NULL<integer expressioan> 8K, Extended, Disk

Sets the number of nulls to be printed at the end of each
line. For 19 character per second tape punches, <integer
expression> should be >*3. For 34 eps punches, it should he
>=3. When tapes are not being punched, <integer expression>
should be @ or 1 for Teletypes* and Teletype compatible
CRT's. It should be 2 or 3 for 38 cps hard copy printers.
The default value is @. In the 4K version, the same affect
may be achieved by patching location 46 octal to contain the
number cf nulls plus l.

* Teletype is a registered trademark of the Teletype
Corporation,

============================================================
Page 85
============================================================
anuacy,

C

1977 Page 73

RGN{<line number>] All

Starts execution of the program currently in memory at the
line specified. If the line number is omitted, execution
begins at the lowest line number. Line number specification
is not allowed in 4K. :

6-2. Statements.

The following table of statements is listed in alpahabetical
order. The notation in the Version column designates the
versions to which each statement applies. In the table, X
and ¥ stand for any expressions allowed in the version under
consideration. tit and J stand for expressions whese values
are truncated to integers. V and W are any variable names.
The format for a Altair BASIC line is as follows:

<nnnnn> <statement>(:<statement>...]
where nnnnn is the line number.

Name Format Version
CONSOLE CONSOLE <I>,<dJ> Extended, Disk

Allows terminal console device to be switched. I is the I/0
port number which is the address of the low order channel of
the new I/O board. 7 is the switch register setting (see
section 5-1 for the list of settings). @<=I,J<=255.°

DATA DATA<list> All

Specifies data to be read by a READ statement. List
elements can be numbers or, except in 4K, strings. 4K
allows expressions. List elements are separated by commas.

DEF DEF FNV(<W>) =<X> 8K, Extended, Disk

Defines a user-defined function. Function name is FN
followed by a legal variable name. Extended and Disk
versions allow user-defined string functions. Definitions
are restricted to one line (72 characters in 4K and 8K, 255
characters in extended versions).

DEFUSR DEFUSRi(<digit>]} a<xX> Extended, Disk


============================================================
Page 86
============================================================
anuary, 1977 ; ' Page 74

Defines starting address of assembly language . subroutine.
Up to ten subroutines are allowed,

DIM DIM <V>(<I>(,3...])[,-..] AL |

Allocates space for array variables. In 4K, only one
dimension is allowed per variable. More than one variable
may be dimensioned by one DIM statement up to the iimit of
the line. The value of each expression gives the maximum
subscript possible. The smallest subscript is @. Without a
DIM statement, an array is assumed to have maximum subscript
of 19 for each dimension referenced. For example, A(I,J} is
assumed to have 121 elements, from A(0,%} to A(i@,19) unless
otherwise dimensioned in a DIM statement.

END END All

Terminates execution of a program. Closes all files in the
Disk version.

ERASE ERASE<V>[,<W>...] Extended, Disk

Eliminates the arrays specified. The arrays may be
redimensioned or the space made available for other uses.

ERROR ERROR<I> Extended, Disk

Forces error with code specified by the expression, Used q
primarily for user-defined error codes.

FOR FOR<V>#<X>TO<Y> {(STEP<Z>} All

Allows repeated execution of the same statements. First
execution sets V=X. Execution proceeds normally until NEXT
is encountered. 2 ig added to V, then, IF 2<@ and V>#s¥, or
if %>@ and V<=Y, BASIC branches back to the statement after
FOR. Otherwise, execution continues with the statement
after NEXT.

GOTO GOTO<nnnnn> All

Unconditional branch to line number

GOSUB GOSUB<nannn> All

Unconditional branch to subroutine beginning at line nnnnn.
IF,..GOTO IF <xX> GOTO<nnnann> 8K, Extended, Disk

Same as IF...THEN except GOTO can only be followed by a line
number and not another statement,

============================================================
Page 87
============================================================
Inuary,

C

1977 Page 75

IfF...THEN [BLSE] IF<X>THEN<X>[ELSE<¥>} All
or IF<X>THEN<statement> ([:statement...]
[ELSE<statement> [:statement...]

TE value of X<>%, branches to line number or statement after
THEN. Otherwise, branches to the line number or
Statement(s) after ELSE. If ELSE is omitted, and the value
of X#0, execution proceeds at the line after the IF,...THEN.
In 4K, X can only be a numeric expression. The ELSE clause
is only allowed in Extended and Disk Altair BASIC,

INPUT INPOT<V>[,<W>...] All

Causes BASIC to request input from terminal. Values (or, in
4K, expressions) typed on the terminal are assigned to the
variables in the list.

LET LET <V>=<X> Ald

Assigns the value of the expression to the variable. The
word LET is optional.

LPRINT LPRINT X[,¥Y.--] Extended, Disk

Same as PRINT, but prints on the line printer. Line feeds
within strings are ignored. A carriage return is printed
automatically after the 86th character on a line.

LPRINT USING LPRINT USING<string>;<list> Bxtended, Disk

Same as PRINT USING, but prints on the line printer. For a
detailed description, see section 5-5.

MID$ MIDS (<X$>,<I>[,<3>]} #¥$ Extended, Disk

Part of the string X$ is replaced by YS. Replacement starts
with the Ith character of xX$ and proceeds until Y$ is
exhausted, the end of x$ is reached or J characters have
been replaced, whichever comes first. If I is greater than
LEN {(X$), an ILLEGAL FUNCTION CALL error results.

NEXT NEXT (<V>,<W>..6] All

Last statement of a FOR loop. V is the variable of the most
recent loop, W of the next most recent and so on. Only one
variable is allowed in 4K. Except in 4K, NEXT without a
variable terminates the most recent FOR loop.

ON ERROR GOTO ON ERROR GOTO<line number> Extended, Disk

When an error occurs, branches to line specified. Sets
variable ERR to error code and ERL to line number where tne

============================================================
Page 88
============================================================
mnuary,

1977 Page 76

error occured. See section 6-5 for a list of error codes.
ON ERROR GOTO @ (or without number) disables error trapping.

ON. . .GOTO ON<I>GOTO<list of line numbers> &K, Ext., Disk

Branches to line whose number is Ith in the list. List
elements are separated by commas. If I= or > number of
elements in the list, execution continues at next statement.
Tf I<@ or >255, an errore results.

ON...GOSUB ON <I> GOSUB <list> 8K, Extended, Disk

Same as ON...GOTO except list e¢lements are initial line
numbers of subroutines,

QUT OUT<I>,<J> 8K, Extended, Disk
Sends byte JT to port I, §<=1,J<#2255,

POKE POKE<I> ,<J> ak, Extended, Disk
Stores byte J in memory location derived from I.
O¢=39¢=255 3=-32768<1<65536,. If I is negative, address is
6553541, if I is positive, addressaI.

PRINT PRINT<X>[,<¥>...] All

Causes values of expressions in the list to be printed on
the terminal. Spacing is determined by punctuation. :

Punctuation Spacing ~ next printing begins:
’ at beginning of next 14 column zone
? immediately .

other or none at beginning of next line

String literals may be printed if enclosed by {"} marks.
String expressions may be printed in all but 4K,

PRINT USING PRINT USING<string>;<list> Extended, Disk

Prints the values of the expressions in the list edited
according to the string. The string is an expression which
represents the line to be printed. The list contains the
constants, variable names or expressions to be printed,
List entries are separated by punctuation as in the PRINT
statement. For a list of string characters and their
functions, see section 5-5.

READ READ<V>[,<W>.-.] All

Assigns values in DATA statements to variables. Values are
assigned in sequence starting with the first value in the

============================================================
Page 89
============================================================
REM REM[<remark>] Ail

Allows insertion of remarks. Not executed, but may be
branched into. In extended versions, remarks may be added
to the end of a line preceded by a single quotation mark

(‘).
RESTORE RESTORE All

Allows data from DATA statements to be reread. Next READ
statement after RESTORE begins with first data of first data
Statement,

RESUME RESUME [<number >] Extended, Disk

Resumes program execution at the line specified after error
trapping routine. If number is omitted or zero, resumes at
statement where error occured, RESUME NEXT causes

resumption at the statement following the statement where
the error was made,
CU RETURN RETURN All

Terminates a subroutine. Branches to the statement after
the most recent GOSUB.

STOP STOP All

Stops program execution. BASIC enters command level and,
except in 4K, prints BREAK IN LINE nonnn. Unlike END, STOP
does not close files.

SWAP SWAP <V>,<W> Extended, Disk

Exchanges values of the variables named. Variables must be
of the same type.

TROFF TROFE Extended, Disk

Turns off trace flag. The trace flag is turned on by TRON
{see below}. NEW also turns off the trace flag.

TRON TRON Extended, Disk

Turns on trace flag. Prints number of each line in square
C brackets as it is executed.

WAIT WAIT<I>,<J>(,<K>] 8K, Extended, Disk

Status of port I is xXOR'd with K and AND'ed with J,

|
peary? 1977 Page 77
first DATA statement,
i

============================================================
Page 90
============================================================
january,

1977 Page 78

Continued execution awaits non-zero result. K defaults to
8, @8<=1,3,K<=255.

6-3. Intrinsic Functions,

Altair BASIC provides several commonly used algebraic
and string functions which may be called from any program
without further definition. If the functions are not
required for a program, they may be deleted when BASIC is
loaded to conserve memory space, The functions in the
following table are listed in alphabetical order. The
notation to the right of the Call Format is the versions in
which the function is available. As usual, X and Y stand
for expressions, I and J for integer expressions and X$ and
Y$ for string expressions.

Function Call Format Version

ABS ABS (X) All

Returns absolute value of expression X. ABS(X)3X if X>=4,
-% if xX<@.

ASC ASC {XS$) 8K, Extended, Disk

Returns the ASCI£ code of the first character of the string
K$. ASCII codes are in appendix A.

ATN . ATN (X} 8K, Extended, Disk

Returns arctangent(X). Result is in radians in range -pi/2
to pi/2.

The following functions are available in Extended and Disk:

CINT CINT(X) Converts X to integer.
CSNG CSNG(X) Converts X to single precision.
CDBL CDBL(X) Converts X to double precision.

If the argument is in the range <-32768 to 32767, the
CINT (X)=INT(X). Otherwise, CINT will produce an OVERFLOW
error,

CHRS CHRS (I) 8K, Extended, Disk

Returns a string whose one element has ASCII code I, ASCII


============================================================
Page 91
============================================================
anuary,

C.

1977 Page 79

codes are in Appendix A,

cos COS (xX) 8K, Extended, Disk
Returns cos(X). xX is in radians.

ERL Extended, Disk

Returns the number of the line in which the last error
occurred,

ERR Extended, Disk

Returns the error code of the last error,

ERR ERR{I) Disk

Returns parameters of disk errors. After a DISK I/O ERROR,
ERR{6) returns number of the disk, ERR(1) returns the track
number (8-76) , ERR(2) returns the sector number, ERR(3) and
ERR(4) return the low and high order 8 bits of the
cumulative count of disk errors respectively.

EXP EXP (X) 8K, Extended, Disk
Returns e to the power X. X must be <=87.3365,

PIX FIX (X) Extended, Disk

Returns the truncated integer part of xX, FIX (X} is
equivalent to SGN(X)*INT(ABS(X)). The major difference
between FIX and INT is that FIX does not return the next

lower number for negative x.

FRE FRE {@) 8K, Extended, Disk
Returns number of bytes in memory not being used by BASIC.
If argument is a string, returns number of free bytes in
string space.

HEXS REXS (X) Extended, Disk

Returns a string which represents the hexadecimal of the
decimal argument.

INP INP (I} 8K, Extended, Disk
Reads a byte from port I.
INSTR INSTR((1I,]X$;¥S) Extended, Disk

Searches for the first occurrence of String YS in xX$ and

============================================================
Page 92
============================================================
1977 Page 8@

returns the position. Optional offset I sets position for
Starting the search. 6<=I¢=255, If I>LEN{(XS}, if XS is d
null or if Y$ cannot be found, INSTR returns @. If Y¥$ is

null INSTR returns I or 1. Strings may be string variable

values, string expressions or string literals.

INT INT (X) All

Returns the largest integer <=X

LEFTS LEFT$ (X$,I) 8K, Extended, Disk
Returns leftmost I characters of string XS.

LEN LEN {X$) 8K, Extended, Disk

Returns length of string XS. Non-printing characters and
blanks are counted.

LOG LOG (X) 8K, Extended, Disk

Returns natural log of X. X>@

LPOS LPOS (X) Extended, Disk
Returns the current position of the line printer print ~ head r]
within the line printer buffer. Does not necessarily give

the physical position of the print head. The expression X
Must be given, but the value is ignored. ;

MIDS MIDS (X$,1[,9]) 8K, Extended, Disk

Without J, returns rightmost characters from xX$ beginning
with the Ith character. If I>LEN(X$), MID$ returns the null
String. 9@<I<255. With 3 arguments, returns a string of
length -J of characters from XS beginning with the Ith
character. If J is greater than the number of characters in
X$ to the right of I, MIDS returns the rest of the string.
@<=J<2255.

ocTS OCTS (X} aK, Extended, Disk

Returns a string which represents the octal value of the
decimal argument,

RND RND (X)} All

Returns a random number between @ and 1. xX<@ starts a new

sequence of random numbers. X>8 gives the next random

number in the sequence. X=4 gives the last number returned.

In @&K, Extended and Disk, sequences started with the same q
negative number will be the same.

============================================================
Page 93
============================================================
C

hmuary,

1977 Page 81

POs POS (T} 8X, Extended, Disk

Returns present column position of terminal's print head.
Leftmost position =9,

RIGHTS RIGHTS (X$,1} 8K, Extended, Disk

Returns rightmost I characters of string x$. If I*=LEN(X$),
returns XS,

SGN SGN (X)} Ail

If X>9, returns 1, if X99 returns @, if X<6, returns -l.
Por example, ON SGN(X)+2 GOTO 144,299,398 branches to 199
if X is negative, 268 if xX is @ and 399 if X is positive.
SIN SIN (X) All

Returns the sine of the value of x in radians.
COS (X} SEN (X+3.14159/2).

SPACES SPACES (I) 8X, Extended, Disk

Returns a string of spaces of length I.

spc SPC (I) 8K, Extended, Disk
Prints I blanks on terminal. @<=I<=255. |

SOR SOR (X) All

Returns square root of X. X must be >=g

STRS STRS (X) 8K, Extended, Disk
Returns string representation of value of xX.

STRINGS STRINGS (I,J) Extended, Disk

Returns a string of length I whose characters all have ASCII
code J. See Appendix A for ASCII codes.

TAB TAB (I} All

Spaces to position I on the terminal, Space @ is the
leftmost space, 71 the rightmost. Tf the carriage is
already beyond space I, TAB has no effect. 4<sI<#255, Way
oniy be used in PRINT and LPRINT statements.

TAN . TAN {X) All

Returns tangent(X}. X is in radians.

============================================================
Page 94
============================================================
mary,

1977 Page 82

USR USR(X) All

Calis the user's machine language subroutine with argument

VAL VAL(X$) 8K, Extended, Disk

Returns numerical value of string x$. If first character of
X$ is not +,-,éora digit, VAL(X$) #6.

VARPTR VARPTR({V) Extended, Disk

Returns the address of the variable given as the argument.
If the variable has not been assigned a value during the
execution of the program, an ILLEGAL FUNCTION CALL error
will occur. The main use of the VARPTR function is to
obtain the address of variable or array so it may be passed
to an assembly language subroutine. Arrays are usually
passed by specifying VARPTR(A[6]) so that the lowest
addressed element of the array is returned.

NOTE

All simple variables should be assigned values in a
program before calling VARPTR for any array.
Otherwise, allocation of a new simple variable will
cause the addresses of all arrays to change,

6-4. Soecial Characters

——

Altair BASIC recognizes several characters in the ASCII
font as having spectal functions in carriage control,
editing and program interruption. Characters such as
Control/c, Control/’S, etc, are typed by holding down the
Control key and typing the designated letter. The special
characters in. the table are listed in the order of the
versions to which they apply, starting with those common to
ali versions and ending with those that apply only to
extended versions.

Typed as Printed as

The following Special Characters are available in ALL
versions.

============================================================
Page 95
============================================================
CU

anuary,

1977 Page 83

Erases current line and executes carriage return.
(backarrow)

Erases last character typed. If there is no last character
types a carriage return.

_ (underline)

same as hackarrow.

Carriage Return

Returns print head or curser to beginning of the next line.
Control/c “Cc {in extended)

Interrupts execution of current program or list command.
Takes effect after execution of the current statement or
after listing the current line. BASIC goes to command level
and types OK. CONT command resumes execution. See section

Separates statements in a line.

The following special characters are available in 38K,
Extended and Disk versions only.

Control/oO “O (in extended}

Suppresses all output until an INPUT statement is
encountered, another Control/O is typed, an error occurs or
BASIC returns to command level.

? ?
equivalent to PRINT statement.
Rubout see explanation

Deletes previous character on an input line. Pirst Rubout
Prints \ and the last character to be printed. Each
successive Rubout prints the next character to the left.
Typing a new character causes another \ and the new
character to be printed. All characters between the
backslashes are deleted.


============================================================
Page 96
============================================================
anuary, 1977 ; Page 84

Control/u . *u (in extended}
Same as @
Control/s

Causes program execution to pause until Control/Q or
Control/c is typed.

Control/gQ

Causes execution to resume after Control/s. Control/S and
Control/Q have no effect if no program is being executed.

The following special characters are available in Extended
and Disk versions only.

Controi/A

Allows use of the EDIT command on the line currently being
typed. Control/A is typed instead of Carriage Return. See
section 5-4.

Control/I 1 to 8 spaces

Tab character. Causes print head or curser to move to the
beginning of the next 8 column field. Fields begin at
columns 1, 9, 17, etc. The tab character is especially
useful for formatting lines broken with line feeds. ; ;

19G<taboFOR I*l TO 19:<line feed>
<tab><tab>FOR J=l TO 18:<line feed>
<tab><tab><tab>A(I,d)=8:<line feed>
<tab>NEXT J,I<carriage return>

lists as:
169 FOR I=1 TO 18;
FOR J=1 TO 12:
A(I,3)=4:
NEXT J,I
Control/G bell

Rings terminal's bell

LINE FEED

Breaks a long line into shorter parts. The result is still
one BASIC line.


============================================================
Page 97
============================================================
huary,

Cc

1977 Page 85

Denotes the number of the current Line. May be used
wherever a line number is to be specified.

[4] [+]

Brackets are interchangable with parentheses as delimiters
for array subscripts. ;

Lower Case Input

Lower case alphabetic characters are always echoed as lower
case, but LIST, LLIST, PRINT and LPRINT will translate lower
case to upper case if the lower case characters are not part
of string literals, REM statements or single quote (')
remarks.

6-5. Error Messages.

After an error occurs, BASIC returns to command level and
types OK, Variable values and the program text remain
intact, but the program cannot be continue by the CONT
command. In 4K and @K versions, all GOSUB and FOR context
is lost. The program may be continued by direct mode GOTO,
however. When an error occurs in a direct statement, no
line number is printed. Format of error messages:

Direct Statement ?XX ERROR
Indirect Statement ?4X ERROR IN YYYYY

where XX is the error code and Y¥YY¥¥YY is the line number
where the error occurred, The following are the possible
error codes and their meanings:
ERROR CODE EXTENDED ERROR MESSAGE NUMBER
The following error codes apply in ALL versions.
BS SUBSCRIPT OUT OF RANGE 9
An attempt was made to reference an array element which is
outside the dimensions of the array. In the 8K and larger
versions, this error can occur if the wrong number of
dimensions are used in an array reference. For example:

LET A(l,1,1) "2

============================================================
Page 98
============================================================
January,

1977 Page 86

when A has already been dimensioned by DIM A(16,18)
DD REDIMENSIONED ARRAY 18

After an array was dimensioned, another dimension statement
for the same array was encountered. This error often occurs
if an array has been given the default dimension of 19 and
later in the program a DIM statement is found for the same
array.

FC ILLEGAL FUNCTION CALL 5

The parameter passed to a math or string function was out of
range. FC errors can occur due to:

le a negative array subscript (LET A(-1)=)

2. an unreasonably large array subscript (>32767)
3. LOG with negative or zero argument

4, SOR with negative argument

5. A*B with A negative and B not an integer

6. a call to USR before the address of a machine language
Subroutine has been entered.

7. calls to MIDS, LEFTS, RIGHTS, INP, OUT, WAIT, PEEK,
POKE, TAB, SPC, STRINGS, SPACES, IWSTR or ON...GOTO with
an improper argument,

ID ILLEGAL DIRECT 12

INPUT and DEF are illegal in the direct mode. In extended
versions, however, INPUT is legal in direct.

NF NEXT WITHOUT FOR

The variable in a NEXT statement corresponds to no
previously executed FOR statement,

OD OUT OF DATA 4

A READ statement was executed but all of the DATA statements
in the program have already been read. The program tried to
read too much data or insufficient data was included itn the

program.

============================================================
Page 99
============================================================
Lmuary,

C

1977 Page 87

OM OUT OF MEMORY 7

Program is too large, has too many variables, too many FOR
loops, to many GOSUBs or too complicated expressions. See
Appendix ¢.

ov OVERFLOW

The result of a calculation was too large to be represented
in Altair BASIC's number format. If an underflow occurs,
zero is given as the result and execution continues without
any error message being printed.

SN SYNTAX ERROR . 3

Missing parenthesis in an expression, illegal character in a
line, incorrect punctuation, etc.

RG RETURN WITHOUT GOSUB 3

A RETURN statement was encountered before a previous GOSUB
statement was executed.

UL UNDEFINED LINE 8

The line reference in a GOTO, GOSUB, IF...THEN...ELSE or
DELETE was to a line which does not exist,

/8 DIVISION BY ZERO
Can occur with integer division and MOD as well as floating

point division. @ to a negative power also causes 2
DIVISION SY ZERO error. .

The following error messages apply to
8K, Extended and Disk versions only
CN CAN'T CONTINUE 1?

Attempt to continue a program when none exists, an error
occured, or after a modification was made to the program.

LS STRING TOO LONG 15

An attempt was made to create a string more than 255
characters long.

os OUT OF STRING SPACE 14

String variables exceed amount of string space allocated for

11

============================================================
Page 100
============================================================
january, 1977 : Page 88
them. Use the CLEAR command to allocate more string space
or use smaller strings or fewer string variables.

5T STRING FORMULA TOO COMPLEX 16

A string expression was too long or too complex. Break it
into two or more shorter ones,

. TM TYPE MISMATCH 13
The left hand side of an assignment statement was a numeric
variable and the cight hand side was a string, or
vice-versa; or a function which expected a string argument
was given a numeric one or vice-versa.

UF ONDEPINED USER FUNCTION 18

Reference was made to a usec defined function which had
never been defined.

The following error messages are available in
Extended and Disk versions only.

MISSING OPERAND : 22

During evaluation of an expression, an operator was found
with no operand following it.

NO RESUME 20°

BASIC entered an error trapping routine, but the program
ended before a RESUME statement was encountered, ;

RESUME WITHOUT ERROR 21

A RESUME statement was encountered, but no error trapping
routine had been entered.

UNPRINTABLE ERROR ‘i3
An error condition exists for which there is no error
message available, Probably there is an ERROR statement
with an undefined error code.

LINE BUFFER OVERFLOW 23
An attempt was made to input a program or data line which

has too many characters to be held in the line buffer.
Shorten the line or divide it into two or more parts.


============================================================
Page 101
============================================================
jnuary,

Cc

1977 Page 89
Disk Altair BASIC Error Messages

FIELD OVERFLOW

An attempt was made to allocate more than 128 characters of
string variables in a single FIELD statement.

INTERNAL ERROR

Internal error in Disk BASIC. Report conditions under which
error occurred and all relevant data to MITS software
department. This error can also be caused by certain kinds
of disk I/O errors.

BAD FILE NUMBER

An attempt was made to use a file number which specifies a
file that is not OPEN or that is greater than the number of
files entered during the Disk Altair BASIC initialization
dialog.

FILE NOT FOUND

Reference was made in a LOAD, KILL or OPEN statement to a
file which did not exist on the disk specified.

BAD FILE MODE 54,

An attempt was made to perform a PRINT to a random file, to
OPEN a random file for sequential output, to perform a PUT
or GET ‘on a sequential file, to load a random file or to
execute an OPEN statement where the file mode is not I, oO,
or R.

FILE ALREADY OPEN 55

A sequential output mode OPEN for a file was issued for a
file that was already OPEN and had never been CLOSEd or a
KILL statement was given for an OPEN file.

DISK NOT MOUNTED 56

An 1/0 operation was issued for a file that was not MOUNTed.
DISK I/O ERROR 59

An I/0 error occured on disk X. A sector read (checksum)
error occurred eighteen (18) consecutive times.

SET TO NON-DISK STRING

58

51

52

53

58

============================================================
Page 102
============================================================
january,

1977 Page 99

An LSET or RSET was given for a string variable which had
not previously been mentioned in a FIELD statement.

DISK ALREADY MOUNTED 59

A MOUNT was issued for a DISK that was already MOUNTed but
never UNLOADed.

DISK FULL 69

All disk storage is exhausted on the disk. Delete some old
disk files and try again.

INPUT PAST END

An INPUT statement was executed after all the data in a file
had been INPUT. This will happen immediately if an INPUT is
executed for a null (empty) file. Use of the EOF function
to detect End Of File will avoid this error,

BAD RECORD NUMBER 62

In a PUT or GET statement, the record number is either
greater than the allowable maximum (2646) or equal to zera.

BAD FILE NAME 63

A file name of 9 characters (null) or a file name whose
first byte was @ or 37? octal (255 decimal} or a file name
with more than 8 characters was used as an argument to LOAD,
SAVE, KILL or OPEN.

MODE-MISMATCH 64

Sequential OPEN for output was executed for a file that
already existed on the disk as a random (R} mode file, or
vice versa.

DIRECT STATEMENT IN FILE 65

A direct statement was encountered during a LOAD of a
program in ASCII format, The LOAD is terminated.

TOO MANY FILES

A SAVE or OPEN (0 or R) was executed which would create a
new file on the disk, but all 255 directory entries were
already full. Delete some files and try again.

OUT OF RANDOM BLOCKS 67

61

66

============================================================
Page 103
============================================================
anuary,

CC

1977 Page 91

An attempt was made to have more random files OPEN at once
than the number of random blocks that were allocated during
initialization by the response ta the
"NUMBER OF RANDOM FILES?" question (see Appendix E).

FILE ALREADY EXISTS 68

The new file name specified in a NAME statement had the same
Name as another file that already existed on the disk. Try
a different name.

FILE LINK ERROR

During the reading of a file, a sector was read which did
not belong to the file.

6-6. Reserved Words.

Some words are reserved by the Altair BASIC interpreter for
use as statements, commands, operators, etc, and thus may
not be used for variable or function names, The reserved
words are listed below in order of the versions for which
they are reserved, starting with those reserved in all
versions and ending with those reserved only in Disk Altair
BASIC. Words reserved in larger versions may be used in
smaller versions, although one may want to avoid all
reserved words in the interest of compatibility. In
addition to the words listed below, intrinsic function names
are reserved words in ali versions in which they are
available,

RESERVED WORDS

Words reserved in all versions.

CLEAR NEW
DATA NEXT
DIM PRINT
END READ
FOR REM
GOSUB RETURN
GOTO RUN
IF STOP
INPOP TO
LET TAB
LIST THEN
USR

Words reserved in 8K, Extended and Disk versions. All the above

plus:

69

============================================================
Page 104
============================================================
fanuary,

1977

AND ON

CONT OR

DEF out

FN POKE

NOT SPC

NULL WAIT

Words reserved in Extended and Disk versions.

AUTO LINE

CONSOLE kL LLIStT

DEFDBL LPRINT

DEPINT MOD

DEFSNG RENUM

DEFSTR RESUME

DELETE SPACES

EDIT STRINGS

ELSE SWAP
TROPF

ERASE TRON

ERL VARPTR

£RR WIDTH

IMP XOR

INSTR

Words reserved in Disk. All the above plus:

CLOSE LSET

DSKI$ MERGE

DSKO$ MOUNT |

FIELD NAME

PILES OPEN

GET PUT

KILL RSET
UNLOAD

LOAD

Page 92

All the above plus:

============================================================
Page 105
============================================================
January, 1977 Page 93

APPENDIX A
( ASCII CHARACTER CODES
DECIMAL CHAR. DECIMAL CHAR. DECIMAL CHAR.
640 NUL 443 + a86 v
Gal SoH a44 ' 487 W
892 sTX 945 - aes x
aa3 . BYX 946 . 433 Y
ag4 EOT 047 / 693 Z
gas ENG 848 a a9 [
486 ACK a49 1 $92 \
an7 BEL 956 2 993 ]
498 BS a5 3 094
ag9 gr  4$2 4 a95 <
gia LF‘) «53 5 096 '
g1l rE? 6 097 a
@12 PR -?**) 55 7 999 b
Mia CRD 856 a a99 ¢
G14 Fe) 457 3 146 d
a1 st $58 : 181 e
a16 DLE 959 ; 192 ft
Q17 Del G63 < 193 g
ala DC2 #61 = 184 A
a19 0c3 862 > 185 4
828 DC4 a63 ? 146 j
C421 NAR a64 a 197 k
$22 SYN: 065 A 198 1
$23 ETS 066 B 129 m
924 CAN G67 c lig n
425 £M 468 D 112 o
526 SUB 469 EB 112 p
827 ESCAPE a72 F 113 q
$28 PS 471 G 114 c
829 Gs G72 | 115 3
430 RS $73 I 116 ‘
a3i Us 874 J 117 u
@32 SPACE 475 K tia v
033 1 076 L 119 w
G34 * 877 x 124 x
a3 2 a78 N 121 y
$36 $ 879 Q 122 z
037 4 988 P 123 {
638 & agi Q 124
939 $82 R 125
640 { 983 s 126
a4l ) 084 t 127 DEL
942 * ag5 U

LF=Line Feed PFarorm Feed CReCarriage Return DELsRQubout

============================================================
Page 106
============================================================
January, 1977 Page 94

Using ASCII codes -- the CHRS function.

CHRS(X) returns a string whose one character is that
with ASCII code X. ASC(X$) converts the first character of
a string to its ASCII decimal value,

One of the most common uses of CHRS is to send a
special character to the user's terminal. The most oftan
used of these characters is the BEL (ASCII 7). Printing
this character will cause a bell to ring on some terminals
and a beep on many CRT's. This may be used ag a preface to
an error message, as a novelty, or just to wake up the user
if he has fallen asleep. Example:

PRINT CHRS(7);

Another major use of special characters is on those
CRT's that have cursor positioning and other Special
functions (such as turning on a hard copy printer}. For
axample, on most CRT's a form feed (CHRS{12)) will cause the
screen to erase and the curser to “home” or move to the
upper left corner.

Some CRT's give the user the capability of drawing
graphs and curves in a special point-plotter mode. This
feature may easily be taken advantage of threugh use of
Altair BASIC's CHRS function.

============================================================
Page 107
============================================================
January, 1977 Page 95

APPENDIX B
LOADING AND INITIALIZING BASIC

A. Loading BASIC from paper tape or cassette.

This appendix details the procedure for leading BASIC
in 4K, 8K and Extended versiong from paper tape or tape
cassette. For instructions on loading Bisk BASIC, see
appendix 4.

The programs below are entered into memory through the
front panel switches. Rather than specify the switch
positions as “up” and “down", it is convenient to denote the
up position as 1 and the down position as @. Taken in
groups of three, then, the switches can represent octal
digits. To save space, the switch positions in the
following loader program listings are shown in octal
netation. The leftmost two switches in an 8 bit set are
represented by the first digit, the mext three by the second
digit and the low-order three switches by the last digit.

For example, if we wish to enter octal 315 on the data
Cc switch register, the switches would have the following
positions: .
7 6 5 4 3 2 1 0
up up down down up up down up
3 1 5

For data entry, only the rightmost 8 ‘switches of the 16
switches on the ALTAIR 884@ front panel switch register are
used. All 16 switches would be used to enter a memory
address.

The following is the procedure for loading BASIC from
Paper tape or cassette.

1. furn the power switch on,

2. Raise the STOP switch and RESET switch simultaneously

3. Switch the terminal to LINE

4. Enter one of the following programs on the front panel
switches. The 4a8-MBL Multi-Bo00t Loader PROM contains
the necessary loader programs, so it is not necessary to

enter a loader from the front panel if it is installed.
C Refer to the 88=-M3L manual for more information.


============================================================
Page 108
============================================================
January, 1977 Page 96

a. loading from paper tape with the SIO board { REV 1)

Oetal Address Octal Data
209 - O41

Oat 3@2

682 Oxx {17 for 4K, 37 for 8K, 77 for
893 G61 Extended & Disk)
064 822

205 90a

#06 333

007 gag

gla Q17

g1l 3398

912 333

613 gel

a4 275

@15 316

016 a@55

G17 167

628 38d

821 351

922 643

423 G64

b. loading from cassette

Octal Address Octal Data

AGG g41

OBL 382

882 ; Oxx (17 for 4K, 37 for 8K, 77 for
603 661 Extended and Disk}
694 822

685 969

GO6 333

007 896

014 617

gll 3398

G12 333

$13 G97

$14 275

615 310

916 ; 855

917 167

226 36d

g21 351

822 633

423 390


============================================================
Page 109
============================================================
aCaarys 1977

Cc.

Page 97

‘loading with the 88 PIO board

Octal Address Octal Code
420 641

aol 382

G62 O@xx {17 for 4K, 37 for 8K, 77 for
G83 : 861 Extended and Disk)
Ob4 823

aes 890

a66 333

687 684

913 346

@1lL 681

912 318

813 333

g14 805

@15 275

816 319

917 G55

829 167

@21 _ 308

922 351

423 #83

G24 968

loading with the 2SI0 board

Octal Address Octal Data

929 a76

agl 683

ag2 323

863 429

Og4 976

gas 921 (=2 stop bits, 925=1 stop bit)
aa6 323

487 428

619 941

911 362

912 Oxx (l?for 4K, 37 for 8K, 77 for
813 @61 Extended and Disk)
d14 932

615 aga

B16 333

G17 6208

826 G17

021 328

B22 333

623 G21

624 275

625 3146

B26 655

627 167


============================================================
Page 110
============================================================
January, 1977 ; Page 98

038 . 308
432 351
432 813
933 #09

@. loading with the 4PIO board

i
]
i
5
!
|
|
661 323 :
8H2 048 ;
#83 323
aa4 641
985 676
006 054

Octal Address Octal Data

888 257

687 323

O18 848

@il Q41

812 382

613 @xx (17 for 4K, 37 for 8K, 77 for

#14 862 Extended and Disk)

$15 ° 933 :

016 6a6 "

917 333 r |
626 849 .

621 aa?

822 334

023 333

@24 041

825 275

826 310

827 855

030 167

831 368

332 351

#33 614

434 B42

£. Loading with the High Speed Tape Reader

Octal Acdceess Octal Data
aad 257
9d1 323
882 944
683 323
6B4 645
685 323
G06 646

a7 987 ,
g10 323 é

============================================================
Page 111
============================================================
J.

“ary,

1977

gil
812
$13
#14
@15
$16
@17
929
@21
G22
823
24
925
826
Q27
836
G31
032
633
a34
g35
G36
837
940
941
G42
843
44
g45
946
47
950

047
876
614
323
044
876
O04
323
@46
323
G47
@41
382
Oxx
961
447
aoa
333
g44
346
199
318
333
g45
275
316
a55
167
30%
351
Q27
$08

To enter these programs,

1.

(17 for 4K, 37 for 8K,
Extended and Disk)

Put switches @ to 15 in the down positions

Raise EXAMINE

Page 99

77 for

Put the data for address zero in switches @ through 7.

Raise DEPOSIT

Put the data for the next address in the switches

Depress DEPOSIT NEXT

Repeat steps 5 and 6 until the whole loader is toggled

in


============================================================
Page 112
============================================================
January, 1977 Page 196

a. Put switches 9 through 15 in the down position
3. Raise EXAMINE

16. Check to see that the lights D@ through D7 show the
data that should be in location #@4. Light on =l, light
off = 6. If the correct value is there, go to step 13,
i£ not go to ll,

il. Pet the correct value in the switches

12. Raise DEPOSIT

13. Depress EXAMINE NEXT

14. Repeat steps 1@ through 13 to check the entire loader

15. If there were any mistakes, check the entire loader
again to make sure they were corrected.

16. If a paper tape is being loaded, put it into the reader
and make sure that it is positioned at the beginning of
the leader. The leader is the section of tape at the
beginning with 392 octal punched in each column. If an
audio cassette is heing leaded, put it in the cassette
recorder and make sure it is fully rewound.

17. Lower switches § through 15
18. Raise EXAMINE

19. Enter the sense switch settings. See the table in
section B,

25, If loading is through a SIOA, B or C or an 88PIO, turn
on the tape reader and then depress RUN. If a cassette
is being loaded, turm on the recorder, put it in PLAY
mode and wait 15 seconds. Then press RUN on the
computer. If loading is through a 4PIO, 2S10 or. High
Speed Tape Reader, depress RUN and then start the read

evice,

2i. Wait for the tape to read. Paper tape takes about 25
minutes for Extended, 12 minutes for 8K and 6 minutes
for 4K. Cassettes take about 8 minutes for Extended, 4
Minutes for 8K and 2 minutes for 4K. Do not move any of
the switches while the tape is being read.

22. If a loading error occurs, the loading procedure must
Start over from step 1. See section C below for error
conditions.


============================================================
Page 113
============================================================
(arye 1977 . Page 181

23. When the tape is read, BASIC should start up and print
MEMORY SIZE? Sea section D below for what to do next.

24, T£ BASIC will not load from cassette, the ACR module
may need realignment, The Input Test Program described
in the ACR Manual, pages 22 and 28 may be used to test
the ACR.

B. Sense Switch Settings

Sense switches (switches A8 through Al5) must he set
before tape or cassette loading begins. The settings depend
on the terminal and input interface boards in use. The low
erder (rightmost) four switches contain the load hoard
setting and the high order four switches contain the
terminal board setting. In the table below, the setting is
given for each f£/0 board option. As above, the setting is
an octal number which signifies the switch positions. The
Terminal Switch and Load Switch columns show the switches
that are raised for each of the load and terminal device

eo options.
Sense Switch Terminal Load
Device Setting Switches Switches Channels
2SI0 8 none none 28, 21
(2 stop bits)
2sIo 1 Al2 Aa 2a, 21
{1 stop bit} ;
SIO 2 Al3 Ag a, 1
ACR 3 Al3,A12 AS ,A8 6, 7
4PIO 4 Al4 Alg 4G, 41, 42, 43
PIO 5 A14,a12 Aa1ld,A8 4, 5
HSR 6 Al4,A13 A1ld,Aa3 46, 47
non-standard 14
terminal

no terminal 15
Examples:

Input from audio cassette through ACR and CRT terminal
through 2SIO with 1 stop bit.

Switch 15 14 13 12 11 16 9 8

Position 4@ 9 i] 1 6 8 1 1

Input from high speed paper tape reader, terminal

through SIO.
CU Switch 15 124 13 12 231 186 9 8
Position 6 6 1 6B 8 1 1 a


============================================================
Page 114
============================================================
1977 Page 162

C. Error Detection

The checksum loader turns on the Interrupt Enable light
on the front panel when a loading error occurs. The ASCII
code of the error letter is stored in location @. In
addition, the error letter is sent out over all the terminal
channels and so will appear on whatever terminal is
connected to the terminal. The error letters are as
follows:

C checksum error. Bad tape data.

M memory error. Data won't store properly.
The address of the bad memory location is stored
in leeations 1 and 2.

Q overlay error, Attempt was made to load data on top
of the loader.

I invalid load device. Invalid setting on the
Sense switches.

D. Initialization Dialog
Upon starting, BASIC prints
MEMORY SIZE?

To this, the user responds by typing the number of bytes of
memory to be used by BASIC and BASIC programs. Remember
that the 6ASIC interpreter itself takes 3.4K in the 4K
version, 6.2K in 8K and 14.6K in Extended. If the response
is just a carriage return, BASIC will use all the memory it
can find, starting at location zero up to the last byte of
read/write memory. Then BASIC asks,

TERMINAL WIDTH?

to which the user responds with the width of the printing
line of whatever output device is in use. Typing a carriage
return sets the terminal width to 72. Extended and Disk
Altair BASIC set the terminal width through the WIDTH
command, so the TERMINAL WIDTH question is mot asked at
initialization and an initial width of 72 is assumed. In
4K, the response to MEMORY SIZE? and TERMINAL WIDTH? must
be less than 6 digits.

At this point BASIC asks several questions about
Mathematical functions. The functions may be kept if needed
or deleted to save space, 4K asks,

SIN? Answer Y to save SIN, SOR and RND
Answer N to delete SIN and see the

============================================================
Page 115
============================================================
J

vary, 1977 . Page 163

next question
SQR? Y keeps SQR and RND

N deletes SQR, asks next question
RND? ¥Y keeps RND

N deletes RND

8K and Extended BASIC ask,
WANT SIN-COS-TAN-ATN? keeps ail four
deletes all four
deletes only _
{in ectenden)PtpeRine
CONSOLE function. Any
other answer deletes
CONSOLE.

Arak

Now BASIC prints,
XXXX BYTES FREE

ALTAIR BASIC VERSION 4.8
[PFOUR-K VERSION]

or
[EIGHT-K VERSION]
or
(EXTENDED VERSION]
OK

BASIC is now in command level and is ready for use,
E. Echo Routines.

The Altair input/output channels work in a full-duplex
mode. This means that characters entered on an input/output
terminal will not, as a rule, be printed as they are entered
unless the computer is programmed to return them. The
following echo programs may be used to test the input/output
devices, To test an input-only device, dump the echoed
characters on an output device or store them in memory for
later examination. To test an output~only device, send the
echo characters through the front panel switches or send a
constant character. Be sure to check the ready-to-receive
bit of the output terminal before attempting cutput. If the
echo program works, but BASIC does not, make sure the load
Gevice’s I/O board is strapped for 8 data bits and that the
ready-to-recieve bit is set properly on the terminal device.

88-PIO

OCTAL ADDRESS “OCTAL CODE
@al aba
ag2 346

83 @6l


============================================================
Page 116
============================================================
January, 1977 Page 144

904 312

a5 860
896 $59
B07 333
018 095
611 323
812 805
913 363
614 aoG
615 80g

28310

OCTAL ADDRESS OCTAL CODE
aga 876
ag1 903
9&2 323
843 @26 (flag ch.}
004 876
685 O21 ("2 stop bits,
206 323 d25=1 stop bit)
867 G28
81a 333
al} 92¢
G12 617
813 322
@14 618
gis 688
016 333
617 922 {data channel)
629 323
#21 821
922 3083
823 gig
Q2¢4 039

4PIO

OCTAL ADDRESS OCTAL CODE
046 257
901 323
G52 646
683 323
BE4 #41
ga5 323
826 042
997 a57
fla 323
B11 843
412 276
013 as4
914 323
615 640

616 323


============================================================
Page 117
============================================================
January, 1977

CL

617
826
@21

@22

$23
824
825
826
G27
838
a31
432
833
a34
835
036
837
849
641
842
643
044

842
333
840
346
289
312
026
80a
333
842
346
288
312
827
6a
333
a4i
323
943
383
820
846

Page 195


============================================================
Page 118
============================================================
January, 1977 Page 1566

APPENDIX C r |
SPACE AND SPEED HINTS

A. Space Allocation

course, on the number and kind of elements in the program.
The following table contains information on the space
tequired for the various program elements.

Element Space Required

Variables
numeric integer 5 bytes
Single precision 7 bytes in Extended and Disk
6 bytes in 4K and 8k
double precision 11 bytes
string 6 bytes

i
f
i
;
The memory space required for a program depends, of |

Arrays
integer (# Of elements) *
Single precision
double precision
string :
8K and 4k @
strings and floating pt. |6|+/5

2}+16|+(# of dimensions)*2 bytes
4
a
3

Functions
intrinsic 1 byte for the call (2 bytes in Extended and Disk)
user-defined 6 bytes for the definition

Reserved Words 1 byte each
2 bytes for ELSE in Extended and Disk

Other Characters

l byte each
Stack Space
active FOR
loop 17 bytes in Extended and Disk,

16 bytes in 4K and 4k
active GOSUB 5 bytes
parentheses 6 bytes each set
temporary
result 12 bytes in Extended and Disk
14 bytes in 4K and 8K

============================================================
Page 119
============================================================
January, 1977 Page 197
; BASIC itself takes about 3.4K in the 4K version, 6.2K
oo in 8K, 14.6K in Sxtended and 29 K in Disk.

B. Space Hints

The space required to run a program may be
significantly reduced without affecting exectuion by
following a few of the following hints.

1. Use multiple statements pec line. Each line has a §
byte overhead for the line number, etc., so the fewer
lines there are, the less storage is required,

2. Delete unnecessary spaces, Instead of writing

18 PRINT X, Y, 2
use
1d PRINTX,Y,Z

3. Delete REM statements to save i byte for REM and 1 byte
for each character of the remark.

4. Use variables instead of costants, expecially when the

‘S same value is used several times. For example, using
the constant 3.14159 ten times in a program uses 49
bytes more space than assigning

18 P=3.14159

once and using P ten times.

5. Using END as the last statement of a program is not
necessary and takes one extra byte.

6. Reuse unneeded variables instead of defining new
variables.

7. Use subroutines instead of writing the same code
several times.

3. Use the smallest version of BASIC that will run the
program.

3. Use the zero elements of arrays. Remember the array
dimensioned by

164 DIM A(19)

has eleven elements, A(@) through A(1@).


============================================================
Page 120
============================================================
January, 1977

18.

Page 108

In Extended and Disk, use integer variables wherever
possible,

Speed Hints

Deleting spaces and REM statements gives a small but
significant decrease in execution time.

Variables are set up in a table in the order of their
first appearance in the program. Later in the program,
BASIC searches the table fer the variable at each
reference. Variables at the head of the table take less
time to search for than those at the end, So, reuse
variable names and keep the list of variables as short
as possible.

In 8K, Extended and Disk use NEXT without the index
variable.

8K, Extended and Disk have faster floating point
arithmetic than 4k, If space is not a limitation, use
the larger versions,

The math functions in 8K, Extended and Disk are faster
than those in 4K.

In the 4K and 8K versions, use variables instead of

constants, especially in FOR loops and other code that
must be executed repeatedly.

In Extended and Disk use integer variables wherever
possible.

============================================================
Page 121
============================================================
anuary,

C

1977 ; : Page 189

APPENDIX D
MATHEMATICAL FUNCTIONS

l. Derived Functions

The following funetions, while net intrinsic to ALTAIR
BASIC, can be calculated using the existing BASIC functions.

Funetion: BASIC equivalent:

SECANT SEC(X} = 1/C0S(X)

COSECANT CSC({X) = 1/SIN(X)

COTANGENT COT(X) =» 1/TAN(X)

INVERSE SINE ARCSIN(X} = ATN(X/SQR(-X*X+1) )

INVERSE COSINE ARCCOS{X) = -ATN X(X/SQR(-X*X+1) )
+1.5788

INVERSE SECANT ARCSEC(X) =» ATN(XSOR(X*X-1) )
+SGN (SGN (X) <1) *1.5709

INVERSE COSECANT ARCCSC(X) = ATN(1/SQR(X*X~1) }
+(SGN{X}=-1)*1.5798

INVERSE COTANGENT ARCCOT(X) = ATN(X)+1,5708

HYPERBOLIC SINE SINH(X) = {EXP(X) ~EXP(+X))/2

HYPERBOLIC COSINE COSH({X) = {EXP{X})+EXP(-X))/2

HYPERBOLIC TANGENT TANH({X} = EXP (-X} /EXP(X)} +EXP (=X) )
*2+1 ;

HYPERBOLIC SECANT SECH(X) = Z2/ (EXP (X) +EXP (=X) }

EYPERBOLIC COSECANT CSCH(X} = 2/ (EXP (X} -EXP(-X} }

RYPERBOLIC COTANGENT COTR(X) = EXP(~X) / (EXP (X) -EXP(—X)}
2+]

INVERSE HYPERBOLIC

SINE ARCSINA(X) = LOG(X+SQR(X*X#1))

INVERSE HYPERBOLIC

COSINE ARCCOSH(X) = LOG(X+SQR(X*X+-1) )

INVERSE HYPERBOLIC

TANGENT _ ARCTANE(X) = LOG((1+X)/(1-x%))/2

INVERSE HYPERBOLIC

SECANT ARCSECH(X) =# LOG{ (SQR(—X*X+1} +1) /X)

INVERSE HYPERBOLIC

COSECANT ARCCSCH({X) = LOG( (SGN(X)*

SOR (X*X+1L) +1) /X
INVERSE HYPERBOLIC
COTANGENT ARCCOTH (X} = LOG({X+1)/{X-1))/2
“2. Simulated Math Punctions.\&

The Collowing subroutines are intended for 4K BASIC users

============================================================
Page 122
============================================================
January, 1977 Page 116

who want to use the transcendental functions not built into
4K BASIC. The corresponding routines for these functions in
the 8K version are much faster and more accurate. The REM

Statements in these subroutines are given for documentation

purposes only, and should not be typed in because they take
up a large amount of: memory. The following are the
subroutine calls and their 8K equivalents:

8K EQUIVALENT 4K SUBROUTINE CALL
P9=X3"¥9 GOSUB 6993¢d
L92LOG (X39) GOSUB 620990
ES=EXP (X9) GOSUB 60169
C9=COS (X3} GOSUB 69247
TS=TAN (X9) GOSUB $6288
AS=ATN (X9} GOSUB 66318

The unneeded subroutines should not be typed in. Please
note which variables are used by each subroutine. Also note
that TAN and COS require that the SIN function be retained
when BASIC is loaded and initialized.

60906 REM EXPONENTIATION: P9=X9“*Y9
68010 REM NEED: EXP, LOG
664020 REM VARIABLES USED: A9,B9,C9,E9,L9,P9,X9,Y3
69939 REM PS =1 ; E9=G : IF ¥9=9 THEN RETURN
69949 IF X9<% THEN IF INT(%9)=Y9 THEN P9=1-2*Y¥9+4*INT(¥9/2}
+ X9==X9
62656 IF X9<>$ THEN GOSUB 60090 : X9#Y9*L9 : GOSUB 69166
68060 P9=P9*ED : RETURN
60079 REM NATURAL LOGARITEM: L9*LOG(x9)
60684 REM VARIABLES USED: A9,89,C9,E9,L9,X9
69990 E930 : IF X9<=@ THEN PRINT "LOG FC ERROR"; : STOP
69190 A9=1; 89="2: C9=.5: REM THIS WILL SPEED THE FOLLOWING
69116 IF X9>=A9 THEN X9=C9*X9 : EQ9=£9+A9 ; GOTO 60106
66128 X9={X9~.797137)/(X9+.7877197) : LO=X9*X9
60130 L9=(((.598979*L9+.961471) *L9+2.88539) *X9+E9=.5)*
; 693147
69135 RETURN
6614% REM EXPONENTIAL ; E9=EXP(X9)
69150 REM VARIABLES USED: A9,E9,L9,X9
60160 LO=INT(1.4427*X9)+1 : IF £9¢127 THEN 69186
69174 [Ff X9>@ THEN PRINT "EXP OV ERROR’; : STOP
66175 E9=9 : RETURN
66186 E£94.693147*L9-x9 : A9=1.32988E-3-1,.413168-4*E9
69190 AQ=( (A9*E9=8.361362-~3) *E94+4.16574E-2) *E9
69195 59=( (A9-.166665) *E9=-1) *E9+1 + Ad=2
60197 IF L9<=9 THEN A9=.5 : L9=-L9 ;: IF L9=% THEN RETURN
60288 FOR X9*#1 TO L9 : B9=A9*39 ; NEXT X9 : RETURN
60218 REM COSINE: C9#COS (x9)
60226 REM N.B. SIN MUST BE RETAINED AT LOAD-TIME
60230 REM VARIABLES USED: C9,xX9

============================================================
Page 123
============================================================
Januacy,

Cc

1977

60245
69258
68268
60270
68280
64298
68369
633128
69320

68338
62349

Page 111

CORSIN(X9+1.5798) + RETURN
REM TANGENT: T9=TAN(X9)
REM NEEDS COS. (SIN MUST BE RETAINED AT LOAD-TIME)
REM VARIABLES USED: C9,1T9,X9
GOSUB 69248 : T9=SIN(X9)/C9 ; RETURN
REM ARCTANGENT : A9*ATN(X9)
REM VARIABLES USED: A9,B9,C9,T9,X9
TOmSGN(X9) 2: X9sABS(X9):COmG: IF X>1 THEN C9-L: X981/X9
A9mX9*X9 : BOm((2.986623E-3*A9~1, 61657E-2) *A9
+4. 29096E-2) *AS
BO=((( (B9-7.5289E-2) *A9+. 106563) *AS-.1142089) *A9+.199936) *A9
A9@((B9~. 333332) *A9+1) *x9 : IF C9—@l THEN A9=1.5708-A9


============================================================
Page 124
============================================================
January, 1977 Page 112

APPENDIX E
BASIC AND ASSEMBLY LANGUAGE

All versions of Altair BASIC have provisions for
interfacing with assembly language routines. The USR
function allows Altair BASIC programs ta call assembly
language subroutines in the same manner as BASIC functions.

The first step in setting up a machine language
subroutine for an Altair BASIC program is to set aside
memory space. When BASIC asks, MEMORY SIZE? during
initialization, the response should be the size of memory
available, minus the amount needed for the assembly language
routine. BASIC uses all the bytes it can find from location
zero up, 30 only the topmost locations in memory can be used
for user supplied routines. If the answer ta the MEMORY
SIZE? question is too small, BASIC wiil ask the question
again until it gets all the memory it needs. See Appendix
Cc.

The assembly language routine may be loaded into memory
from the front panel switches or from a BASIC program by
means of the POKE statement.

The starting address of the assembly language routine
gees in USRLOC, a two byte location in memory which varies
from version to version. USRLOC for 4K and 8K Altair BASIC
version 4.@ is lll ceTMe . In Extended and Disk, USRLOC
need not be known explicitly since it is defined
automatically by DEFUSR. See section 5-3b. The function
USR calls the routine whose address is in USRELOC,
Initially, USRLOC contains the address of ILLFUN, the
routine which gives the FC or ILLEGAL FUNCTION CALL error,
which is what happens if USR is called with no assembly
language routine having been loaded.

When USR is called, the stack pointer is set up for 8
levels (16 bytes) of stack storage. If more stack space is
needed, BASICs stack can be saved and a new stack set up for
use by the assembly language routine, BASIC's stack must be
restored, however, before returning from the user routine.

All memory and all the registers can be changed oy a
user's assembly language routine. Of course, memory
lecations within BASIC ought not to be changed, nor should
more bytes be popped off the stack than were put on it.

USR is called with a single argument. The assembly
language routine can retrieve this argument by calling the
routine whose address is in locations 4 and 5 decimal. The

============================================================
Page 125
============================================================
C

fanuary, 1977 Page 123

low-order byte of the address is in 4 and the high-order in
5. In 4K and 8K, this routine (DEINT) stores the argument
in the register pair [D,£]. In Extended, the argument is
passed in pair [8,L]. The argument is truncated to integer
in 4K and 8K, and if it is not in the range ~32768 to 32767,
an FC error occurs. In extended, the register pair ([8,L]
contains a pointer to the Ploating Point Accumulator where
the argument is stored (see section 5-3b. for more
information}.

To pass a result back from an assembly language
routine, load the value in register pair [A,B] in 4K and 8K,
or [H,L] in Extended. This value must be a signed, 16 bit
integer as defined above. Then call the routine whose
address ig in locations 6 and 7. If this routine is not
called, USR(X) sreturns X. To return to BASIC, then, the
assembly language routine executes a RET instruction.

Assembly language routines can tbe written to handle
interrupts. Locations 56, 57 and 58 are used to hold a JMP
instruction to a user supplied interrupt handling routine.
Location 56 initially holds a RET, so it must be set up by
the user or an interrupt will have no effect.

All interrupt handling reutines should save the stack,
registers A-L and the PSW. They should also reenable
interrupts before returning since an interrupt automatically
disables all further interrupts once it is received.

There is only one way to call an assembly language
routine in 4K and 8k, but this does not limit the programmer
to only one assembly language routine. The argument of USR
can be used to designate which routine is being called. In
8X, ad@itional arguments can be passed through the use of
POKE and values may be passed back by PEEK.

In Extended and Disk BASIC, up to ten routines may be
called with the USR® - USR9 functions. For more information
on this feature, see section 5—3b.

============================================================
Page 126
============================================================
ROCLAM
WAM ED AIS
AED BY
ISAVE “AY,

January, 1977 Page 114

APPENDIX FP
USING THE ACR INTERFACE

NOTE

The cassette features , CLOAD and CSAVE , are only
present in 8K Altair BASICs which are distributed on
cassette, and in Extended and Disk versions. 8K
BASIC on paper tape will give the user about 259
additional bytes of free memory, but it will not
recognize the CLOAD or CSAVE commands,

Programs may be saved on cassette tape by means of the
CSAVE command, CSAVE may be used in either direct or
indirect mode, and its format is as follows:

CSAVE <string expression>

The program currently in memory is saved on cassette under
the name specified by the first character of the STRING

rE: THE <expression>. CSAVE writes through channel 7 when the Write

Buffer Empty bit {bit 7) of channel 6 is low. After CSAVE
is completed, BASIC always returns to command level.
Programs are written on tape in BASIC's internal
representation. Variable values are not saved on tape,
although an indirect mode CSAVE does not affect the variable
values of the program currently in memory. The number of
nulls (see WULL command) has no affect on the operation of
CSAVE. Before using CSAVE, turn on the cassette recorder,
make sure the tape is in the proper position and put the
recorder in RECORD mode,

Programs may be loaded from cassette tape by means of
the CLOAD command, which has the same format as CSAVE. The
effect of CLOAD is to execute a NEW command, clearing memory
and all variable values, and loading the specified file into
memory. When done reading and loading, SASIC returns to
command level. LOAD reads a byte from channel 7 when the
Read Data Ready bit (bit 9) in channel 6 is low, Reading
continues until 3 consecutive zeros are read, BASIC wili
not return to command level after a CLOAD if it could not
find the requested file or if the file was found but did not
end with 3 zeros. In that case, the computer will continue
to search until it is stopped and restarted at location @.

============================================================
Page 127
============================================================
January, 1977 Page 115

C

In the 4K cassette and Extended versions of ALTAIR
BASIC, data may be read and written with the CSAVE* and
CLOAD* commands. The formats are as follows:

CSAVE*<array variable name>
and
CLOAD*<array variable name>

See section 2-4d for a discussion of CSAVE* and CLOAD* for
array data.

CLOAD7<string expression> compares the program
currently in memory with the specified file on cassette. If
the two files match, BASIC prints OK. If not, BASIC prints
NO GOOD.

Data may also be read from and written on cassette in
the paper tape version of 8K Altair BASIC. To write data,
execute a WAIT 6,128 statement to check for the Write Buffer
Empty bit and then write with an OUT 7,<byte> statement. To
raad, execute a WAIT 6,1 to check for Read Data Ready and
then read with an INP(7). The end of a block of data may be
conveniently designated by a special character. Data should
be stored in array form since there is no time during
reading and writing for computation.

============================================================
Page 128
============================================================
January, 1977 ; : Page 116

APPENDIX G <q
CONVERTING BASIC PROGRAMS

Though implementations of BASIC on different computers
are in many ways similar, there are some incompatibilities
between ALTAIR BASIC and the BASIC used on other computers.

1) Strings.

A number of BASICs require the length of strings to be
Geclared before they are used. All dimension statements of
this type shouid be removed from the program. In some of
these BASICs, a declaration of the form DIM AS(I,7) declares
@ string array of J elements each of which has a length Tf,
Convert DIM statements of this type to equivalent ones in
Altair BASIC: DIM A$(J)}. Altair BASIC uses " + " for
String concatenation, not ", " or " g," ALTAIR BASIC uses
LEFT$, RIGHT$ and MIDS to take substrings of strings. Some
other BASICs use A$(I) to access the Ith character of the
string A$, and AS{I,J} to take a substring of AS from
character position I to character position J. Convert as

follows;
OLD NEW q
AS (I} MIDS {AS,I,1)}
AS (I,J) MIDS (AS,I,J-I+1)

This assumes that the reference to a subscript of AS is in
an expression or is on the right side of an assignment. If
the reference to A$ is on the left hand side of an
assignment, and xX$ is the string expression used to replace
Characters in AS, convert as follows :

In 4K and 3k

OLD NEW

AS (I) =X$ AS*™LEFTS (AS, I-1) +XS4+MIDS (AS ,I+1}
AS(I,J7}=XKS$ AS=LEFTS (A$, 1-1) +X$+MID$ {AS ,J+1)
Extended and Disk

OLD NEW

AS{I)}=X$ MID$(AS,1,1)=xS

AS(1,J)=xs MIDS (A$,1,J=I+1) =x$

============================================================
Page 129
============================================================
C

January, 1977 Page 117

2) Multiple assignments.
Some BASICs allow statements of the form:
598 LET BeC=g

This statement would set the variables B and C to zero. In
8K Altair SASIC this has an entirely different effect. All
the * s “ signs to the right of the first one would be
interpreted as logical comparison operators. This would set
the variable B to -1 if C equaled @. If C did not equal 436,
B would be set to @. The easiest way to convert statements
like this one is to rewrite them as follows.

586 C#3:B=C

3) Some BASICs use ™ \ " instead of “ 7: " to delimit
Multiple statements on a line, Change each "\ "to “=: *
in the program.

4) Paper tapes punched by other SASICs may have no nulls at
the end of each line, instead of the three per line
recommended for use with Altair BASIC. To get around this,
try to use the tape feed control on the Teletype to stop the
tape from reading as soon as Altair BASIC prints a carriage
return at the end of the line. Wait a moment, and then
continue feeding in the tape. When reading has finished, he
Sure to punch a new tape in Altair BASIC's format.

A program for converting tapes to Altair BASIC's format
was published in MITS Computer Notes, November 1976, p. 25.

5) Programs which use the MAT functions available in some
BASICs will have to be re-written using POR...NEXT loops to
perform the appropriate operations.


============================================================
Page 130
============================================================
January,

1977 © Page 118

APPENDIX HE
DISK INFORMATION

Format of Altair Floppy Disk

Track Allocation:

Tracks Use

@-5 . Disk BASIC memory image.

6-69 Space for either random or sequential files.
78 Directory track. See below.

71-76 Space for sequential files only.

Format of DISK BASIC Memory Image (Tracks 9-5):

BASIC is loaded starting at track @ sector @ then track 4
sector 1, etc. Each sector contains 128 bytes of BASIC.
The first 128 bytes are loaded first, second 128 second,
etc.

- Sector format (Tracks @~5):

Byte Use
6 Track Number+128 decimal.
1-2 Sixteen bit address of the next
higher byte of memory than the highest memory location
saved on this sector.
3-130 128 bytes of BASIC,
131 255 decimal stop byte.
132 Checksum ~ sum of bytes 3-134 with no carry in 8 bits.

Sector format (Tracks 6-76);

Byte Use
a Most Significant Bit always on.
Contains track number plus 24@ octal.
1 Sector number * 17 MOD 32.
2 Pile number in directory. Zero file number means

that the sector is not part of any file. If the
sector is the first file of a group of 8 sectors
@ means the whole group of 8 sectors is free.

============================================================
Page 131
============================================================
C

January, 1977 Page 119

3 Number of data bytes written (@ to 128) . Always

128 fore random files, (Except for the random file
index blocks in which case this byte indicates how many

groups are allocated to the file.)

4 Checksum. The sum of all the data on the sector
except for the track number, the sector
number and the terminating 255 byte.

5,6 Pointer to the next group of data. This is set up for
random files and sequential files, and is even valid
in the middle of a group. If it is zero it means there
is no more data in the file. The track ts the first byte
and the sector number is the second byte.

7-134 Data

135 A 255 {octal 377) to make sure the right number
of data bytes were read.

136 Unused.

Directory Track {78) Format:

Each sector of the directory (which is all of track 78)
is composed of up to 8 file name slots, 16 bytes per slot.
Each slot can contain a file name (8 bytes), a link to the
start of file data (2 bytes), and a byte which specifies the
mode of a file (Random=4, Sequential2). The remaining 5
bytes are not currently used. Any slot which has the first
Ellename byte equal to zero contains a file which hes been
deleted. If the first byte of a slot is a 255 , it is the
last slot currently in use in the directory. Slots beyond
the “stopper" are garbage. Pile numbers are calculated by
Multiplying the sector mumber of the directory track the
file is in by G and adding the position of the slot in the
sector (@#-7) plus l.

NOTE

The ith logical sector on a track is actually mapped
to the i*17 MOD 32 physical sector to improve
latency in BASIC I/O operations.

Format of Random Files

Each random file starts with two random index blo-s7ks. The
"number of data bytes“ field in the first block indicates
how many groups are currently allocated to this random file.
The next 256 bytes in the two random index blocks give the
location of each group in the random file in order of their
position in the file. The upper two bits give the group
number , and the lower six bits give the track number - 6.


============================================================
Page 132
============================================================
January, 1977

their own

so that

se ta ue

DSKO: MOV
MVT
SUB
MOY
CALL
MVI
ourT

7
OHBLDSK:
MVI
ORA
MOV
TNX
NOTYTD:
ANA
JNZ
ADD
out
Mov
INX
MOV
INX
DCR
JZ
DCR
out
JNZ
ZRLOP:
ANA
JINZ
out
DCR

AND [48,4]

Page 128

Assembly Code to Read and Write a Sector

The following code has been provided to help users write

assembly language subroutines to read and write

data on the Eloppy disk.

C,A
A,136
c

B,A
SECGET
A,128
9

Tt is assumed that the disk being
used ‘has already been enabled and positioned to the correct
track, Two data bytes are always read or written at a time
the CPU can
microseconds/byte) of the floppy disk. After two bytes are
read or written, the CPU re-synchronizes with the next ‘byte
ready’ status from the floppy disk controller.

up with the data rate (32

CALL WITH NUMBER OF DATA BYTES TO WRITE IN [A]
AND POINTER TO DATA BUFFER IN [5,L}
ALL REGS DESTROYED.

;SAVE #¢ OF BYTES IN C

;CALCULATE NUMBER OF ZEROS TO WRITE
;SUBTRACT THE NUMBER OF DATA BYTES
;NUMBER OF ZEROS+1

; LATENCY

;ENABLE WRITE WITHOUT SPECIAL CURRENT

CALL WITH [B]=*NUMBER OF ZEROS [C]=NUMBER OF DATA BYTES

POINTING AT OUTPUT DATA

MVI D,l
A,128

:SETUP A MASK (READY TO WRITES)
sHIGH BIT (D7) ALWAYS ON IN FIRST BYTE
7OR ON DATA BYTE
;SAVE FOR LATER
} INCREMENT BUFFER POINTER

;GET WRITE DATA READY STATUS
?TEST STATUS BIT
7NOT READY TO WRITE, WAIT
?ADD BYTE WE WANT TO SEND TO ZERO
7;SEND THE BYTE
;GET NEXT BYTE TO SEND
?MOVE BUFFER POINTER AHEAD
#GET NEXT DATA BYTE
;MOVE BUFFER POINTER AHEAD AGAIN
;DECREMENT COUNT OF CHARS TO SEND
;IF DONE, QUIT & GO TO ZRLOP
;DECREMENT COUNT OF CHARS AGAIN:
;SEND TRIS BYTE
;STILL MORE CHARS, DO THEM.

;GET READY TO WRITE
71S IT READY
7IF NOT, LOOP
?KEEP SENDING PINAL BYTE
#DECREMENT COUNT OF BYTES TO SEND

============================================================
Page 133
============================================================
highest
the PROM

PROM shou

position
be strapped at the proper address,

January, 1977
JINZ ZRLOP
EI
MVI A,8
our 9
RET
} DISK INPUT ROUTINE.
DSKI: CALL SECGET
MVI C,137
READOK: IN a
ORA A
IM READOK
IN 1a
MOV M,A
INX E
BCR Cc
JZ RETDO
DCR Cc
NOP
IN 12
MOV M,A
INX i
INZ READOK
oe RETDO: EI
MVI A,§
our - 9
RET
SECGET; MVI A,4
out 3
DI
SECLP2: IN 3
RAR
J¢ SECLP2
ANI 31
CMP E
JINZ SECLP2
RET .

Page 121

;KEEP WAITING
;RE-ENABLE INTERRUPTS
;UNLOAD HEAD

;SEND COMMAND

;DONE

ENTER WITH POINTER
+ OF 137 BYTE BUFFER IN [{H,L}]. ALL REGS DESTROYED.

;POINT TO RIGHT SECTOR

7GET ¢ OF CHARS TO READ
7GET DISK STATUS

;READY TO READ BYTE

?READ THE STUFF

:SAVE IN BUPFER

BUMP DESTINATION POINTER

;LESS CHARS

:IF OUT OF CHARS, RETURN

;DECREMENT COUNT OF CHARS

;DELAY INTO NEXT BYTE

}GET NEXT BYTE

SAVE BYTE IN BUFFER

;MOVE BUFFER POINTER

;IF CHARS STILL LEPT, LOOP BACK
;RE-ENABLE INTERRUPTS

;UNLOAD HEAD

?SEND COMMAND

;LOAD THE READ

;DISABLE INTERRUPTS

7GET SECTOR INFO
;FIX UP SECTOR #
;IF NOT, KEEP WAITING
;GET SECTOR #
7;ZS IT THE ONE WE WANTED
;TRY TO FIND IT

The Disk PROM Bootstrap Loader

The Disk bootstrap loader PROM must be
on the PROM board and the PROM beard must

installed in the

The proper position is

IC socket on the opposite side of the board from

the black finned heat sink.

ld be in the

The black dot or '‘'1l’' on the
upper
( jumpers on the PROM board must ve in the '1'

corner, The address
position.

left


============================================================
Page 134
============================================================
1977 Page 122

To use the Disk bootstrap loader, turn the computer's power
on. Raise RESET and STOP simultaneously. Lower RESET and
then STOP. EXAMINE location 177448 (address switches A15-A8
Up, rest down) and then set the sense switches for the
terminal I/O board as explained in Appendix B. Depress the
RUN switch. BASIC should print {or display):

MEMORY SIZE?

For the rest of the initialization procedure, see below.
Using the Cassette and Paper Tape Bootstraps

If the Disk Bootstrap PROM is not in use, & paper tape or
cassette program must be loaded which then reads in BASIC
from the disk. This 1s done by following the procedure
below;

1. Key in the applicable paper tape or cassette bootstrap

loader from the listings in Appendix 8. Make
location 22077 octal. Set the sense switches for the
terminal

2. Start the paper tape or cassette (labeled DISK LOADER)
reading, and then start the computer as in the
instructions for loading BASIC from paper tape from
cassette as given in Appendix 8.

BASIC should respond:
MEMORY SIZE?

For the rest of the initialization procdure, see below.

Disk Initialization Dialog

The initialization dialog has been expanded to allow the
user to select the proper amount of memory needed to use the
disk{s) on the system. After the the MEMORY SIZE question
is answered, BASIC will ask:

HIGHEST DISK NUMBER?

The user should answer with the highest physical disk
address in the system or with carriage return to default to
@. Each additional disk uses 49 bytes of memory.

Example:

============================================================
Page 135
============================================================
C

January, 1977

Page 123

HIGHEST DISK NUMBER? 1

BASIC next asks how many files are to be OPEN at one time in
the program. This number includes both random and
sequential files. If the user types carriage return, the
default is zero. Each file allocated requires 138 bytes for
buffer space. Example:

HOW MANY FILES? 2

Finally, BASIC asks how many random files are to be OPEN at
one time. The amount of memory allocated is the answer*257.
This memory space is used to keep track of the location on
the floppy disk where groups cf a random file reside. Thus,
the total memory required for each random file is
134+257=395 bytes, Example:

HOW MANY RANDOM FILES? 1
A typical dialog might appear as follows:

MEMORY SIZE? <carriage return>

HIGHEST DISK NUMBER? <carriage return> -
HOW MANY FILES? 2 <ecarriage return>

HOW MANY RANDOM FILES? 1 <carriage return>

XXXXX BYTES FREE

Altair BASIC REV. 4.6

[DISK EXTENDED VERSION]
COPYRIGHT 1976 BY MITS INC.

OK


============================================================
Page 136
============================================================
January, 1977 Page 124

APPENDIX I q

& PIP UTILITY PROGRAM

A BASIC Utility program has been provided to perform such
such common functions as printing directories, initializing
disks, copying disks etc.

NOTE

Some of the PIP commands (LIS, DIR) require that one
<file nmumber> be configured during the Disk BASIC
initialization dialeg. This is done by answering
the "BOW MANY PILES?" question with a value greater
than zero. {If an attempt is made to perfrom a LIS
or DIR without following this procedure, a
BAD FILE NUMBER error will occur,

Once the BASIC disk has been mounted, type the following
command:

ma
RUN "PIP"<carriage return> q
(PIP will type} ;
* .

PIP? is now ready to accept commands. To exit PIP, type a

carriage return to the prompt asterisk. To initialize the
floppy disk in drive @, type:

*INIG

PIP will type "DONE® when it is finished. Any disk number
may be substituted for the 8 in the above command and PIP
will format the disk in that drive. Any previous files on
the disk initialized will be lost. If you wish to use blank
disks with Disk BASIC, they must be initialized in this
fashion before they can be MOUNTed.

NOTE

DO NOT INITIALIZE THE DISK WITH DISK BXTENDED BASIC
ON IT. THIS WILL WIPE OUT ALL THE FILES PROVIDED ON
THE DISK.


============================================================
Page 137
============================================================
January, 1977 Page 125
oe Printing a Directory

Giving PIP the command:

*DIR<disk number>
prints out a directory of the files on the specified disk.
The name of each file is printed, along with the file's
“mode” (S for sequential, R for random), and the starting
track and sector number of the first block in the file.

SRT<disk number>
prints a sorted directory of the files on the specified
disk,

LISting Sequential Piles

The LIS command is used to list the contents of a sequential
data file on the terminal:

Syntax:
C LIS<disk number>,<file name>
Example:
*LISH,PIPA user types

7 CLEAR 1060 computer prints

COPying Disks

The COP command is used to copy a disk placed in one drive
to a disk on another drive. Neither disk need be MOUNTed
for the COP command to work properly.

Syntax:

COP<old disk number>,<new disk number>


============================================================
Page 138
============================================================
January, 1977 Page 126
Before the copy is done, PIP verifies the actionn by
printing the following massage:

PROM<disk number>TO<disk number>
Typing Y followed by a carriage return causes execution to

proceed, Any other responce aborts the command, Example:
*COP6,1 FROM 6 TO 1? Y<CARRIAGE return> DONE * -

The PAT command
The DAT command is used to dump out a particular sector of
the disk in octal.
Syntax:
DAT<disk number>
When the DAT command is issued, PIP asks for the numbers of
the track and sector to be dumped. Example: *DATG

TRACK? @ SECTOR? § G69 G00 G82 809 680 aga
G68 689 804 G96 G00 a0 408 etc.

The CNV command

CNV converts disks written under Altair BASIC version 3.4
and 3.3 to a format useable by version 4.4. The format of
the command is as follows:.

CN¥<disk number>

CNV makes sure that the next to last byte of each sector is
255. .

Other Programs Provided on the System Disk

Program Name Use
STARTREK Plays game based on TV series,


============================================================
Page 139
============================================================
Jan uary,

C

1977 Page 127

APPENDIX J
BASIC TEXTS

Below are a few of the many texts that may be helpful

in learning BASIC.

1) BASIC PROGRAMMING, John G, Kemeny, Thomas &, Kurtz,
1967, lL45pp.

2) BASIC, Albrecht, Finkel and Brown, 1973

3) A GUIDED TOUR OF COMPUTER PROGRAMMING IN BASIC, Thomas A.
Dwyer and Wichael S$. Kaufman; Boston: Houghton Mifflin
Co.» 1973

Books numbered 1 and 2 may be obtained from:

People's Computer Company
P.O, Box 318
Menlo Park, California 94625

They also have other books of interest, such as:

1@1 BASIC GAMES, David Ahl, Ed., 1974, 25@pp.
WHAT TO DO AFTER YOU HIT RETURN or PCC's FIRST BOOK OF

COMPUTER GAMES
COMPUTER LIB AND DREAM MACHINES, Theodore 8. Nelson, 1974,

18épp.


============================================================
Page 140
============================================================
January, 1977 Page 128

APPENDIX K

USING Altair BASIC ON THE
INTELLEC* 87MOD eg AND MDS SYSTEMS.

This appendix covers procedures for loading and
operating Altair BASIC on Intellec and MDS development
systems.

A. Leading BASIC. To load Altair BASIC, put the hex
paper tape of BASIC in the system reader device. Now enter
the System and assign the CONSOLE I/O device as desired {see
Section 4.2.1 of the Intellec 8/Mod 84 Operator's Manual).
Now read in BASIC with the following R command.

»R(Cr)

The BASIC tape will be loaded into memory and the
system monitor will type a period on the CONSOLE device. If
you are only using contiguous RAM memory below the system
monitor (38088) or are using BASIC on a MDS System, proceed
to step 2. If you have RAM memory above the PROM Intellec
monitor which you wish BASIC to use for program and variable
storage, you must patch the two locations known as INTLOC to
point to the bottom (lowest address) of memory. The is most
easily accomplished by using the System Monitor S$ command,
INTLOC is given below under "Memory Requirements."

-SXXXX @@ 48 (Cr) .
The above S$ command would make INTLOC point to RAM, starting
at 16K.

NOTE

if you are using RAM above 16K for program and
variable storage and have patched INTLOC, retain all
the math functions at initialization time (see
Appendix 5B). Essentially, this means that the WANT
SIN-COS—TAN~ATN? questions asked by BASIC's
initialization dialog should be answered by a Y(Cr).
Also, you must answer the MEMORY SIZE? question
with the highest decimal or RAM address in your
system,


============================================================
Page 141
============================================================
January, 1977 Page 129

C

Start BASIC by giving the monitor GOTO command

~Gddde<carriage return>

NOTE

Once BASIC has been started, it. may always he
restarted by depressing the RESET switch on the
Intellec 8 console.

When BASIC types MEMORY SIZE?, Typing carriage return will
Cause BASIC to use all the RAM memory it can find above the
end of BASIC. Otherwise, if you wish to specify an exact
amount of memory, type the decimai address of the highest
byte Gf memory in the computer and type carriage return.

B. BASIC I/O.

The system devices used for terminal I/O in SASIC are
CI, CO and CSTS.

C. Saving and Loading Programs.

To save a program on paper tane, re-enter the PROM
monitor and reassign the CO device to the paper tape punch
or other cutput device. Then restart BASIC by using the
GA08@ command and type LIST(Cr). The characters of the LIST
command will net be echoed, but the BASIC program currently
saved in memory will be put on the output device.

To load a program enter the system monitor, rce-assign
CI to the input device where the program resides, and then
stact BASIC with a Gd608. When the program has been
completely read in, reassign CI to the user console. Then
ve~enter BASIC with a G@@0G, and start the 1/0 device. The
program wili be echoed on CO as it is read in.

D. Memory Requirements

BASIC uses locations §S90H~-8003H and
6019H~approximately 19DFH in the 8K version, and 5010H-2FQ8H
in the Extended version. For Intellec 8K and MDS 8K BASICs,
INTLOC is 6529 decimal. For MDS Extended, INTLOC is 14257
decimal.

E. Calling Assembly Language Routines


============================================================
Page 142
============================================================
January, 1977 Page 134

USRLOC for 8K BASIC is 4955H. ADR(DEINT) is steced in
‘ lecations 9#¢43H. ADR(GIVACF) is stored in location 60458.
In the Extended version these locations contain the
addresses of FRCINT and MAKINT, respectively. Interrupt
driven subroutines using RST 7 are not allowed in the
Intellec/MDS version of Altair BASIC. See Appendix C. for
further information on calling assembly language
subroutines,

* Intellec is a registered trademark of the Intel
Corporation.


============================================================
Page 143
============================================================
C

January,

1977? Page 131

APPENDIX L
PATCHING BASIC'S 1/0 ROUTINES

BASIC’s 1/0 routines may he changed to accommodate
non-standard terminal equipment. After BASIC is loaded and
before it has been initialized, location 71 contains a
pointer to a list of addresses. These addresses contain the
T/O routines of BASIC:

ORG 11Q
OW ICLST ;TWO BYTE ADDRESS OF ADDRESS LIST
IOLST: DW TRYOUT ;ADDRESS OF OUTPUT ROUTINE
DW TRYIN ¢CHARACTER INPUT ROUTINE
DW TSCNTC 7;POLL FOR CONTROL/C CHECK
Bw NEWSTT ;FAST POLL FOR CONTROL/C CHECK
+8K AND LARGER ONLY
DW IN2S{to sADBRESS OF INITIALIZATION
:ROUTINE FOR 2$10 BOARDS
DW IN4PLO ;ADDRESS OF INITIALIZATION ROUTINE FOR
C ;4PIO BOARDS
DW LPYCoOD sADDRESS OF LPT ROUTINE (IN EXTENDED
s;AND DISK ONLY.)
DW LPTCD2 ;2ND LPT ROUTINE
DW LPTCD3 33RD LPT ROUTINE
DW IOCHNL ;ADDRESS OF 1/0 RESET LOCATION
7 (IN EXTENDED AND DISK ONLY}
TRYOUT: IN i] ;GET DEVICE STATUS
ANT 208 ;AND OFF BIT 7
JNZ TRYOUT WAIT UNTIL TERMINAL CAN OUTPUT
POP PSW ;GET CHARACTER TO OUTPOT OFF STACK
OUT l 7TRANSMIT IT
PUSH PSW ;SAVE CHARACTER BACK ON STACK
NOP ;CHANGED TO “IN 41" FOR 4PIO BOARDS
NOP
POP PSW 7;GET CHARACTER BACK OFF STACK
RET ;ALL DONE WITH CHARACTER OUTPUT ROUTINE
TRYIN: IN g 7GET TERMINAL STATUS
ANI 1 ;CHARACTER READY?
JN2Z TRYIN :NO, KEEP WAITING


============================================================
Page 144
============================================================
January, 1977

IN
ANT
CPI

RNZ

ISCNTC: IN

NEWSTT: IN
ANI
C2

IN2SIO: CPI
RNC
ADOT
PUSH
MVI
CALL
POP
JMP

IN4PIO: MVI
DCR
CALL

LPTCOD: LDA
ORA
J2
POP
PuUSsa
CPI
JNZ

MORSPL: MVI
OUTCHR
LDA
ANI

127
CONTO

ll

@
1
CNTCCN

2*4

21

PSW
Ari
DO102g
PSW
bDOTO29

A,54Q
i
DOIO24

PRTIFLG
A
TTYCHR
PSW
PSW
9
NOTABL
A,32

LPTPOS
7

Page 132

;READ IN THE CHARACTER i
7GET RID OF PARITY BIT q
;CONTROL/O?

;RETURN IF NOT

;READ TERMINAL STATUS
;HAS THE TERMINAL A CHARACTER

7TO SEND?
3;NO, RETURN

; FOLLOWING ROUTINE IS IN 8K AND LARGER VERSIONS ONLY
;AND IS EXECUTED FOR EACH STATEMENT

;READ TERMINAL STATUS
;TEST BIT 8
7YEBS, SEE IF CHARACTER CONTROL/C

71S IT 2510
;NO, OTHER GO DIRECTLY TO SETIO
;GET PROPER INITIALIZATION BYTE }
?SAVE IT q
INITIALIZE THE 2S10

7GET BACK SECOND INITIALIZATION BYTE
}PROGRAM TO DATA AND STOP BITS

;RESET FOR DATA TRANSFER
; CHANNEL=22

;SEE IF WE WANT TO TALK TO LPT
;TEST BITS
;IF ZERO THEN NOT
7GET BACK CHAR

;TAB
:NO

;GET SPACE
;SEND IT

7GET CURRENT PRINT POSIT
;AT TAB STOP?

============================================================
Page 145
============================================================
January, 1977

IN2 MORSPL
C POP PSW
RET
NOTABL:
POP PSW
PUSH PSW
CPL 13
CZ PRINTW
CPL 13
Jc PPSWRT
LDA LPTPOS
CPI LPTLEN=]
INZ NOTELP
MVI A,l
CALL = PINLP2
DCR A
NOTELP: INR A
STA LPTPOS
LPTWAT: IN 2
ORI 245
INR A
INZ LPTWAT
POF PSW
our 3
RET
eS ;FOR THE LINE PRINTER,
FINLPT: XRA A
STA PRIFLG
LDA LPTPOS
ORA A
RZ

Page 133

7GO BACK IF MORE TO PRINT
7POP OFF CHAR
; RETURN

7GET CHARACTER WE WANT TO PRINT

71S IT CARRIAGE RETURN?

FORCE OUT A LINE

1GET CONDITION CODES BACK

:1P FUNNY CONTROL CHARACTER
7({LF), DO NOTHING

WHERE ARE WE?

- ARE WE AT END OF LINE?

+NO, JUST SEND CHAR
;SET LPTLST=1 AND LPTPOS=d

7MAKE SURE LPTPOS ZERO.

7SEND OOT CHAR
+RETURN

7THIS ROUTINE IS CALLED TO PORCE OUT A PARTIAL BUFFER
IT ALSO RESETS PRIFLG SO ALL
;PURTHUR I/O GOES TO THE USER'S TERMINAL

;RESET PRINT FLAG SO OUTPOT.
;GOES TO THE TERMINAL
7SEE IF ANY LEFTOVERS MUST BE
;FORCED OUT
;BY LOOKING AT LPTPOS

;THE ROUTINE PRINTW IS CALLED TO FORCE OUT A LINE CURRENTLY
;IN THE LINE PRINTER BUFFER. THE CARRIAGE RETURN/LINE PEED
;QUTPUT SUBROUTINE CALLS PRINTW

fMAKE SURE LAST PRINT

;BIT

;CHARACTERS IN THE BUFFER?
;IF SO DON'T CLEAR THE BUFFER
;PRINT BLANK LINE.
;CHECK IF PRINT WAS LAST
;IF SO, DO SPECIAL DELAY BECAUSS
;OP DESIGN
; PROBLEM
;SAVE [H,L]
;DELAY COUNT

PRINTW: IN 2
ORI 245
INR A
JNZ PRINTW
; SEE IF BUFFER MUST BE EMPTIED
LDA LPTPOS
ORA A
JINZ PRINTR
LDA LPTLST
ORA A
J% NTEXDL
PUSH A
EXT H,190808


============================================================
Page 146
============================================================
January, 1977

LPTDLY: DCX
“ov
ORA
INZ
POP
STA
NTEXDL: MVI
out
XRA-
RET
PRINTR: MVI
out
FINLP2: STA
BCR
STA
RET

LPTCD2: LDA
ADD
CPI
JMP

LPTCD3: LDA
NLPPOS

CPI
oMP

IOCHNL: 4
B
TOREST: LxI
CALL
CALL
JMP

To patch the I/O routines,

BASIC

Page 134

i ;COUNT DOWN
A,H .
L ;UNTIL ZERO
LPTDLY
H ;RESTORE (8,4) REGS
LPTLST ;RECORD LINE FEED LAST
A,2 ;SEND A LINE FEED COMMAND
A ;RETURN WITH @ &CC'S=g
aA, ;TELL LET TO PRINT
;STATUS REG
LPTLST
aA 7 (A) 36
LPTPOS }RESET LINE PRINTER POSITION
LPTPOS ;GET CURRENT LPT PRINT HEAD POSITION
M
LPTLEN 7;WILL THIS NUMBER OVERLAP?
LINCHK
LPTPOS }GET LINE PRINTER POSITION <
;NOTE: COLUMN WIDTH (CLMWID)=
714 CHARACTERS
EQU ( ( (LPTLEN/CLMWID) -1) *CLMWID) ; POSITION BEYOND
;WHICH THERE ARE
;NO MORE COMMA FEBLDS, SO
NLPPOS ;COMMA JUST DOES A "CRDO"
CHKCOM ;USE TELETYPE CHECK
;DEPOSIT BOARD TYPE HERE
;CHANNEL GETS DEPOSITED HERE.
H, LOCHNL ;GRAB POINTER TO IT
HELPIO ;SET UP THE NEW CONSOLE DEVICE
STKINI }MAKE STACK OK
READY 7AND TYPE "OK" HOPEFULLY ON GOGD CONSOLE:

stop the
and insert the patches using the front panel switches
or read in a tape containing the patches.
location zero with all sense switches up.
BASIC from modifying the I/O routines. In

machine after loading

Restart BASIC at
This will prevent
general, these

guidelines should be followed in writing I/O routines: e

============================================================
Page 147
============================================================
UC

January, 1977 : Page 135

1. Insert a JMP at TRYOUT to the custom output routine, Be
sure the PSW that is saved on the stack when the routine
is entered is preserved. Make sure all registers are
left unchanged when the routine is exited.

2. Insert a JMP at TRYIN to the custom input routine.
Return the input character in the A register and do not
change any of the other registers. The PSW may be
changed, ,

3. To modify ISCNTC insert a CALL to the custom poll
routine. This routine returns a nonzero condition code
setting if no character is present, and zero if a
character is present. The A register and the condition
codes may be changed.

4. To change the initialization of the 2SI0 board, change
the “ADE 230" to “MVI A,XXX" where XXX is the new
initialization byte.

5. To change the initialization of the 4PIO board, change
the "MVI A,540" to a "MVI A,XXX" where XXX is the new
initialization byte.

6. To patch in a new line printer driver change the code at
LPTCOD, Note that PRINTW is also called by the routine
which prints a carriage return line feed. ‘The code at
LPTCD2 and LPTCO3 must be changed if the line printer is
not 8@ characters wide.

7. ‘To recover from an incorrect CONSOLE command, deposit
the board Aupxess in IOCHNL, the board type in IOCHNL+1,
and start the machine at IOCHNL+2.

Patching Disk BASIC - the PTD program. After Disk
BASIC is loaded, deposit the desired patches in memory.
Then examine and run PTD at location 5490¢@ octal. After two
or three seconds, the patched version of BASIC will be saved
on disk, The save is complete when the Disk Enable light on
disk drive zero goes out.

To save a patched version of BASIC on a disk which did
not previously contain release 4.8 Altair BASIC, track @
must be copied from a 4.8 disk.

PTD may also be used to save programs other than Basic
on tracks @-4 of a diskette by loading the program after
BASIC is loaded and running PTD. All memory locations
between @ and 46689 octal will be saved on tracks 9~4 on
Giskette zero,


============================================================
Page 148
============================================================
January,

1977 Page 136

APPENDIX M
USING ALTAIR DISK BASIC

An Example

The following is a discussion of how to program a
typical application in BASIC. The example is the MITS
in-house inventory system which is designed to run on the
following hardware:

Altair 8890b computer with 32K memory, PROM memory board
with the Disk PROM Bootstrap leader and a 2510 serial
I/O board

Two disk drives

2¢-line Lear-Sigler CRT terminal

Line printer

The most important part of the design for an
application is setting up the files. Files that are
correctly set up will be easy to use and maintain. Poorly
set up files will be a perpetual headache, causing either an
eventual rewrite or, more likely, abandonment of the system.

The first listing at the end of the appendix, INVEN,
contains modules from the main program in the inventory
system. INVEN shows how the central file (a random file) in
the system is set up and how it is handled, The INVEN
listing also shows the use of another random file and a
sequential file. The CALC listing shows how to read
programs as data files. CODE1 is a partial listing of a
program that will be read as a data file.

The INVEN modules listed were included to show the
following features:
l. program startup initialization and comments about the
files used by the program (lines 1-35)

2. what the complete program does (lines 69-1086)

3. an example of how to modify records in a random file
{lines 960-1949)

4. an example of how sequential files are used (lines
1890-1868 and 2798-2824)

============================================================
Page 149
============================================================
January,

C,

1977 Page 137

5. one approach to the problew of handling a random file
that spans more than one disk (lines 2099-2930)

6. three subroutines (lines 306-340, 9@99~992¢ and
9269-9228) that are called by the INVEN modules.

The function PNY (line 6} is used to round dollar
amounts to thousandths of a cent. FNQ (line 7) is used to
round quantities to thousandths and to convert single
precision amounts to double precision.

INV3 is flelded once in the program initialization, but
INVi and INV2 are repeatedly fielded by calls to the
subroutine at line 2089. The IP F>255 {line 68) avoids the
possibility that the program can be stopped by an illegal
function call at line 61,

PUT statements are the very last statements executed in
the Remove from Inventory module, the Add to Inventory
module, etc. This prevents updating one file but not the
other. (This could happen if PUT Z, Rl was at line 19814.)

Line 2808 sets Z to 1 and Rl to N if the item wanted,
N, is less than 2001. It sets 2 to 2 and R1 to N-2600 if
the item wanted is greater than 2606. Line 2828 then sets
the pointers for the variables in the field statement to
point into either the buffer for INVl or the buffer for
INV2, depending on whether the item wanted is less than 2062
or greater than 2099.

The CALC listing is a program which determines if there
aré enough parts in inventory to meet projected demands.
Line 68 waits while the disk comes up to speed so the
message “ENABLE DISK 1" will not be printed on the terminal.
Lines 10@-148 input up to fifty different product codes and
the number of each product to be built. Line 170 opens a
file for each product that contains the parts required for
the product. Lines 229-258 build up a report heading
extracting the product description contained in line 14 of
each File.

Lines 126-158 accumulate the number of parts required
for each product into the array Q, If more than 32767 of a
part is required, a pointer is set in the array Q and the
number of the part is accumuulated in the array Q!. This
maneuvering is necessary since the system does not have
enough memory to dimension Q as single precision instead of
integer.


============================================================
Page 150
============================================================
January, 1977 Page 138

The parts lists for a product are programs saved with q
the A option, Since they are programs, their maintenance is
very easy. For example, suppose that part 1671 in the 889%b
is too marginal and -that from now on part 1173 should be
used instead. With the parts lists disk mounted on drive @,
the following sequence will update the 98@¢@b file:

LOAD "CODE1*"
164,1,1273
SAVE "CODE1",4,A

The programmer who is cramped for memory will find that
programs can still ke documented adequately if comments are
set up as separate files. The memory used for variables
when a program runs can be used for comments if the comments
are merged in when the program is to be listed.
Alternatively, the program could be listed in two or more
Parts. Additional memory can be obtained by bringing BASIC
up without optional functions and with no files.

The main inventory program is set up so that a carriage
return typed in responce to any prompt cause the program to
dump the function descriptions on the CRT and to return to
the FUNCTION NUMBER prompt. If the program were to be run
on a printing terminal, instead of a 9608 baud CRT, it would
not be set up to print the descriptions every time the q
operator wanted to get back to the FUNCTION NUMBER prompt.

The list of function descriptions might be taped on the wall
next to the terminal instead.

Listing of INVEN

DEFINT P-N
DEFINT R

DEFINT Z

DEFDBL P

DEF FNY#(Q8#) =INT(Q8#*A#+.54) /A#

DEF FNQ#(Q9!) sINT(VAL(STRS(Q9!))*1900#+.5#) /1690¢
AS=MKD§ (4) :BS=MKSS () :A#=100000$

1@ DIM QS (2) ,P$(2)

ll!

a yA Ww Nr

INV1 ON DRIVE @ HOLDS ITEMS 1-2996

INV2 ON DRIVE 1 HOLDS ITEMS 2991-4099

INV3 ON DRIVE 1 HOLDS SUMS LOGGED IN AND OUT BY DEPARTMENT
12

WEKLYRST AND MONTHRST ARE WRITTEN WHILE THE WEEKLY,
MONTHLY ACTIVE ITEMS LISTS ARE PRINTING;

CONTAIN TRE ITEM #S THAT NEED TO BE RESET; AND ARE READ BY
Tae CEERLY , MONTHLY RESETS.

Q$(} <=> THREE ON HAND QTY FOR: P$() <=> TAREE PRICES @

============================================================
Page 151
============================================================
January, 1977 Lo Page 139

C

[P{(@) OLDEST, P(1) NEXT OLDEST, Q(9)<>@ IF O(1}<>@,
Q(1)<>d_ IF Q(2)<>9)

D$ <=>'DESCRIPTION  LEPT$(D$,3)="$$$" <=> INACTVE ITEM #
1s

I1l$ <=> WEEKLY QTY IN

12$ <=> MONTHLY QTY IN

O15 <=> WEEKLY QTY OUT

O2$ <=> MONTHLY QTY OUT

TS <#> REORDER LEVEL

DI1$ <=> WEEKLY § IN

ID2$ <=> MONTHLY $ IN

DO1$ <=> WEEKLY $ OUT

OD2$ <=> MONTHLY $ OUT

17!

DT1$ <*> WEEKLY DEPT $ TAKEN

DX2$ <=> MONTSLY DEPT $ TAKEN

DG1$ <=> WEEKLY DEPT §$ GIVEN

DY2$ <=> MONTHLY DEPT $ GIVEN

25 OPEN "R°,#1,"INV1*

38 OPEN *R",#2,"INV2",1

32 OPEN "R",€3,“INV3",1

35 FIELD #3,8 AS DT1$,8 AS DX2$,8 AS DGiS,3 AS DY2S

6@ PRINT: F=:INPUT"FONCTION NUMBER“ ;F:IFF>255THEN63

61 ON F GOTO 218,358,35¢,1908,686,960,1760,
2702,2500,2360,2489,1839,290¢'
2 3 4 5 6 7 8 9 1¢ 11 12 13
14 15 16

63 PRINT"1 ENTER NEW ITEM”

64 PRINT"2 LIST ITEM ON CRT {SHORT FORM)"
65 PRINT"3 LIST ITEM ON CRT (LONG FORM)"
66 PRINT™4 PRINT ITEMS ON LINE PRINTER

68 PRINT"6 REMOVE FROM INVENTORY”

6% PRINT"? PRINT WEEKLY DEPT DOLLAR RECORD ON LINE PRINTER
70 PRINT"$S PRINT WEEKLY ACTIVE ITEMS LIST CN LINE PRINTER
71 PRINT"? WEEKLY RESET

72 PRINT"19—= PRINT MONTHLY DEPT DOLLAR RECORD ON LINE PRINTER
73 PRINT*i1-~- PRINT MONTHLY ACTIVE ITEMS LIST ON LINE PRINTER
74 PRINT"12= MONTHLY RESET

75 PRINT" 13~- RESET ORDER LEVELS

76 PRINT®14— PRINT LISTNG OF ITEMS NEEDING TO BE RE-ORDERED
77 PRINT"1L5= DELETE OLD ITEM

78 PRINT"’16= ERRORS BACKOUT

1@a@ GOTO62

298 '

*

67 PRINT"S = ADD TO INVENTORY"

SU8 - INPUT PART # & GET RECORD
*.

348 PRINT: PRINT:N=9:INPUT"PART NUMBER® ;N: IFN<1THENRETURN
310 IFN>4GQOTHENPRINT: PRINT" ''# TOO HIGH''":GOTO 308
326 GOSUB2000:GETZ,R1


============================================================
Page 152
============================================================
January, 1977 Page 144

330 IFLEFTS (D$,3) 2"$$S“THENPRINT:
PRINT"''NO INFORMATION ON PART’’";N:GOTO369

348 RETURN

age".

x

F=6 - REMOVE FROM INVENTORY
*

984 GOSUB39@: LFN=8GOT063
929 DNa-1:INPUT"NUMBER OF ITEMS REMOVED FROM INVENTORY";
ON: IfDN«~1LTHENG3
958 LFCVS (QS (B} ) #CVS (QS (1) ) #CVS (QS (2) } <DNTHENPRINT"
ATTEMPT TO REMOVE MORE THAN ON HAND"’:PRINT:GOTO63
9608 DG=DN:P=g
978 IFD@<CVS (OS (8) ) THEN
P=D+FNQ# (DG) *CVD(PS (@) ) sLSETQS (9) =MKS$ (CVS (OS (8) )~D9) :
GOTO1484
980 P=P+FNO# (CVS (0${9))) *CVD(PS$ (a) } :DG=Da-CVS(Q$(d)):
LSETQS (9) =QS (1) sLSETOS (1) *Q$ (2) sLSETQS (2) =BS$:
LSETD$ (9) =P$ (1) sLSETPS (1}=PS (2) :LSETPS (2) #AS : IFDOTHEN
GOTO9 72
1695 LSETO1LS=MKSS (CVS (01$) +DN) :LSETO2$@MKSS (CVS (02$}+DN) :
LSETDOL$=MKD$ {CVD (DO1$) +P) : LSETOD2S#MKDS (CVD (OD2$) +P)
1628 GOSUB9 204: I FC¢2-1GOTO63
1638 LSETDT1S*MKDS (CVD(DT1$) +P} :LSETDX2S=MKD$ (CVD (DX2$) +P}
1840 PUT3,C%:PUTZ,R1:GOTO9GB

1799 a
F=9 - WEEKLY RESET .
*
188@ PRINT"7 - WEEKLY DEPARTMENT RECORD
18462 PRINT"3 - WEEKLY ACTIVE ITEMS
1864 ZS$a"":INPUT"HAVE THE ASOVE BEEN LISTED FOR TODAY";2$
1814 IPLEFTS (2$,1)<>“¥"THENPRINT: PRINT
"WEERLY RESET NOT PERFORMED" :GOTO63
1343 OPEN"I",4,"WEKLYRST*
1845 IFEOF (4) THENCLOSE4:KILL"WEKLYRST" :GOTO1862
1858 INPUT#4,N:IF 1<=NANDN<#46905 THENGOSUB22900@:GETZ,R1
ELSEPRINTN;"OUT OP BOUNDS. RESET ABORTED.": END
1855 LSETI1LS=BS :LSETO1$=BS : LSETDILS=A$ : LSETDOLS*AS$:PUTZ,R1
186@ GOTO1845
1862 FORT=1T026
1864 GET3,I:LSETDTIS=AS : LSETDG1S$=2A$ ;PUT3,I
1866 NEXT
1868 GOTO6A
1999 '
x

SUB - GET 2,Rl FOR N AND FIELD TO INV1,2

*

2009 Z2l1-(N>2008) :Rl=N+(Z=2) *2008

2029 FIELD 2,4 AS Q${9),4 AS Q$({1),4 AS Q$(2), 8 AS PS{@),

8 AS P$(1),8 AS PS(2),4@ AS DS,4 AS I1$,4 AS 12$,
4 AS 015,4 AS 02$,8 AS DI1$,8 AS ID2$,8 AS DOIS,8 AS OD2$ é


============================================================
Page 153
============================================================
Truary, 1977 Page 141

CU

2038 RETURN
2698 '
*

F29,11 - WEEXLY,MONTHLY ACTIVE ITEMS LIST
*

2798 New1:GOSUB269¢:GOSUB2855

2703 IPF*8THENOPEN"O", 4, "WEKLYRST"ELSEOPEN"O", 4,"MONTHRST"

2705 ITss9:OT4ad: TTH09

2718 FPORI#1T02902

2726 GETZ, I:IFLEFTS(DS,3) ="$$S"THEN28G2

2723 Q=eCVS (Q5 (9) ) :Ql=CVS(Q$(1)) :Q2=CVS (QS (2) }

2725 I[FPagTHENL! #CVS (11$) :0!=CVS (01S) :I14=CVD(DI1$) :0#=CVD(DO1S}
ELSEI 1 sCVS (12$) :O12CVS (02S) :I$sCVD(ID2$) :O#=CVD(OD2$)

2727 TT#=TTE+CVD (BS (G) ) *Q+CVD{ PS (1) ) *Q1+CVD (PS {2)} *Q2

2738 IPI! +0] =@THEN2800

2733 PRINT#4,N+I-1

2735 IT#sIT#+I$ :OTHSOTH+OF

2749 IFL9>SS9ANDKK=9THENGOSUB285¢

2759 LPRINTUSING* ####84" ;9999914N+I;

2776 LPRINTUSING" 4#, #84, #3#%31T1,0!,QU+Q1+02, Q0+014+02+0!-1!;

2786 LPRINTUSING"SS ,##4,844.#¢2%";1l#,OF

2796 L9=L9+]

2795 KK#KX+1; [FKK=5THENLPRINT: L952,9+1: Kad

2a9@ NEXT

‘e 2818 IFN=]1THENN=2691:GOSUB2980:GOTO271¢

2811 CLOSE4

2813 LPRINT:LPRINTUSING"TOTAL INVENTORY COST =SS4+,4¢4,2#4. Fe ;TT#

2815 REM *GOTO2828 IN F=7,10

2820 LPRINT: LPRINTUSING" TOTAL IN = $$#3,#34,84¢.9¢" ;IT#

2838 LPRINTUSING"TOTAL OUT =SSE4, $44,244.98" 0TH

2837 LPRINT:LPRINT

2844 GOTOSé

2858 FORJ=L9T066:LERINT:NEXT

2855 IFF=8TRENLPRINT"WEEKLY®"; :ELSELPRINT" MONTHLY";

28690 LPRINT" ACTIVE ITEMS LIST"; :GOSUB9@09

2865 LPRINTTAB (39) ; "STARTED"

287% LPRINT"ITEM 4 OTY~IN QTY-OUT ON-HAND MO-WITH
DOLLARS-IN  DOLLARS-OUT®

288@ LPRINT:KK29:L9=6: RETURN

99g '

*

SUB - PRINT TODAY'S DATE
x
9099 IFTDS=""THENLINEINPUT"TODAY'S DATE ?";TDS:IFTDS=""THENGI
$014 LPRINT” ";TDS
9815 LPRINT
9820 RETURN
9198 *
*
C INPUT DEPARTMENT + AND GET TOTALS

; *

920@ C%=-L:INPUT“ENTER DEPARTMENT CODE" ;C%;IPC$*#-1TSENRETURN


============================================================
Page 154
============================================================
January,

1977 Page 142

9218 IF1<sC8ANDC3<=20THENGETS , C%: RETURN @
$220 PRINT"INVALID CODE" :GOTO920a

Listing of CODE

5 CODE]

18 PARTS LIST FOR: 8880B
20 OCT 30,1976

948 REM THIS IS THE -START OF DATA
14@ ,11,1842

112 ,3,1134

122 ,4,1946

13@ ,1,1026

149 ,1,1921

15@ .1,1024

164 ,1,1071

170 ,1,1974

189 ,1,2195

194 ,24,348

209 ,2,326

Listing of CALC

1d CLEARGGA
29 DEFINT A~-Z é
36 DIM CN(49) ,NU(49} ,Q(4888) ,Q! (206)
42 CLOSE:UNLOADL
5@ INPUT"PLACE DISK WITH PARTS LISTS IN DRIVE 1. HIT RETURN";GS
60 FORK!=1T0506@:NEXT:MOUNTL
9@ LINELWPUT”’ TODAY'S MO/DA/YR ";DT$:H$(9)=DT$+" PARTS AVAILABLE FOR:"*
95 '
INPUT QUANTITY OF EACH PRODUCT REQUIRED
eaekae .
104 INPUT*CODE NUMBER(S WHEN FINISHED)” ;CN(I)
118 IF CN{I)*9 THEN 156
12a IF CN{I)<1l OR S8<CN(I) THEN PRINT“INVALID CODE NUMBER:
GOTO 193
136 INPUT"NUMBER OF UNITS TO BE MADE" ;NU(I)
148 I=I+l:IP 1<58 THEN 184
145 '
ACCUMULATE QUANTITY OF EACH PART REQUIRED
kakaek
158 FOR K=9 TO I-1
168 ONERRORGOTO61G
170 OPEN"I", #1, “CODE"+MID$ (STRS {CN(K}},2),1
188 ONERRORGOTODB
198 LINEINPUT#1,A$:IFAS=""THEN19@
298 IFLEPTS(A$,3)="90 "THEN269
218 IPLEPTS (AS,3)<>"15 “THEN19@
228 IFKTHENHS (HK) =HS (HK) +"," a


============================================================
Page 155
============================================================
U

January,

1977

239
249
259
266
276
288
298

3008
314
315
GET

Page 143

HHS={STRS (NU (K} } +STRS (CN (K) }+"=("+MIDS (AS, 20) +") "
IFLEN (HHS) +LEN (85 (HR) ) > 7 2THENHR=HK+1

AS (HK) =H$ (BK) +HHS :GOTOL9S
ONERRORGOTO6 34

IFEOF (1) THEN314

INPUT $1,A,QN,PN

IFQ (PN) <8THENQ! (-Q(PN) )=Q1! (-Q( PN} ) +NU(K) *QN
ELSEQ (PN) ©Q {PN} +NU(K) *QN

GOTO279

ONERRORGOTO@:CLOSE L:NEXT K

q

SECOND HALF OF INVENTORY BACK ON LINE

eaRee

328
334

CLOSE: UNLOAD1
INFUT*®

PLACE INVENTORY DISK #i IN DRIVE 1. HIT RETURN TO START REPORT"; GS

343
360
378

375

FPORI 15] T05896 : NEXT: MOUNT
OPEN*R", #2," INVi"
FIELD #2,4 AS Q1S,4 AS Q2$,4 AS Q3$,24 AS G$,48 AS DS

PRINT REPORT
HERE

388
398
408
418
42%
434
448
450

468
478

48a
36a
512
529
53a
548
565

GOSUB579 .

FOR I=1 TO 4640

IF Q({I)=@ THEN 530

QQiaQ(I) sIFQ{I) <@THENQQ?=0i (-Q(I))
IFL9>59ANDKK#@GTHENGOSUBS 66

L9=L9+1

RN=I

IFI<2000THEN4 6S9ELSERN=RN-29 09: [FFLAG=9THEN
CLOSE2:0PEN"R", $2,"INV2",1:FLAG=1:

FIELD#2,4 AS Q1$,4 AS Q2S,4 AS 03$,24 AS GS,4@ AS Ds
GET #2,RN

IFLEPTS (D$,3)="$S$"THENLPRINTI+190000!;
VakaeekEA NO INFORMATION ON BART **ee ta eHN Ss
LPRINTOSING##, ### ##H" >QQ) :GOTOS20

QH!=CVS (Q1$) +CVS (Q2S$) +CVS (Q35) :QD!=QH!-Q9!
LPRINTI+1 90990: ;DS;*" ";

LPRINT USING "4%, ###4#¢" 500! 7QH1;QD!

KK=KK+1: LFKK=5THENKK20: LPRINT:L9=L9+1

NEXTI: CLOSE: END

FORK#=L97066: LPRINT: NEXT

PRINT PAGE HEADING
kk ee

5768
58d
594
665

FORK=8TOHK: LPRINTHS (K) :NEXT
LPRINT: LPRINTTAB(52);"NEEDED ON HAND EXCESS": LPRINT
KK=@:L925+HK: RETURN

TRAP ROUTINE: BAD CODE NUMBER

RARER

618

IFERR=S3THENPRINT:PRINT"NO CODE" ;MIDS (STRS(CN(K)),2);" FILE"


============================================================
Page 156
============================================================
January, 1977 Page 144

628 ONERRORGOTOG S|
625 '

TRAP ROUTINE: ACCUMULATE INTO Q OVERFLOWED

RRRKK

630 IFERR<>60RERL<> 29 OTHENONERRORGOTOS

640 NOQ=NQ+1:Q! (NQ) =Q(PN} +NU(K) *ON:Q (PN) =-NO

678 RESUME27@


============================================================
Page 157
============================================================
January,

1977

Qe
»
.
*
+
’
.
»
.
.

ABS . 2. © «© «© «
ACR interface .

AND . 1.1. 2 wo
Array variables
ASC ... °

ASCII character cod
ATN 2. «6 wa eo

AUTO . 2. 1 ws ee

> © Ornanae
rar, ee rer ers

Backarrow .. . 2.6
BASIC texts ... »
Boot loaders ...
Branch, conditional
Branch, unconditional
Branching ...-.-s.

Carriage Return ..
Carriage return ..
Gharacter, alphanumec
CLEAR . 4 5 « & 6
CLOAD . «1 « t wh
CLOAD* for arrays
CLOAD? . 2. 2 «4 «2
CLOSE . « « + + «
CLOSE, random files
Command Level .
Commands List .
CONSOLE 1.» ..
Constants .. .
CONT . . . . ss
Control/A ee

Control/c
Control/I
Control/o
Control/Q
Control/s
Control/y

cos ...
CSAVE* for
CVD . 4»
CVI “2.

rrays
CVS si... :

Conversion from non-A.
arr

INDEX

ove # ©

‘se * © we ew ee
e 6 *+ 8s © we we
ee wp ee ee

ic”

ee ee

rm
ee
= se ee De we es we ww

ee © © © De © = & wo

Page 145

127
96
19
19
19

83

78
74
78
25

68
63

74

18
76
18
83
84
83
84
84
14

re 116

79
25
67
67
67


============================================================
Page 158
============================================================
January, 1977

DATA . 2. 6 6 we oe oe ot ew 4
DEF . 6 we we ew we tt we we we OF
DEFDBL . . . 6. 6 6 © © © © © = 1
Definitions ...++.+4+4+44
DEPINT . 1 2 6 © «@ eet ew ee 1B
DEFSNG . a |
DEFSTR . . 2 6 6 @ «© ww ew ow se DD
BDEFUSR . 1. «4 » 6 «© «@ @ @ ee eo 49
DELETE . 2. 2 2 2 ew ew et ew ew FIL
DIM . 2. 2 we we ee ew ee ew ee «1S
Dimensions . . .. 4.4.64. . 14
Direct Mode ....«.«.2 +e. 5
Disk format . . « « « « « « « 118
Disk number .. . 2... 1 ss 53
Disk operations ...... . 53
Disk PROM bootstrap loader .. 121
i

Page 146

Disk read and write, assembly code 129
Division,integer ..... . 39
Double precision .... . . ll

DSKF . 2. 1 5 as © © ew we we « 62

DSKI$ and DSKOS$ primitives - 68

Echo routines ... . «+ « « is3

EDIT 2 «2 » «© » » » © » © aw we s 49

Edit, definition ....... 5
Editing, elementary provisions 9

END «6 » ee ee eo we we we gre 74
EOF . 2. 6 1 + aw ew ee ew ew we &

EQV . ee ee te ee ee ee 1G @
ERASE 2.4. 2. 2 2 » » » © © «© « 32

ERR « ew 6 eo we eh ew et we 3G

ERR « «+ 6 ew ee ee te ww we 86, 79
Error codes «6 « «© « « « « « 36

Error message format .... . 8

Error messages, disk .... . 89

ERROR statement ..... +. . 39

Error trapping ........ 35

EXP « « «to ew ee we we we ow we se 79
Expression, integer ....+s. 5
Expressions, string .... . 31

FIELD «ww ew we ee we ew 85
Fields, numeric ....... 48
Fields, string ....-+-+. + 47

File mame .... +. « » « © « 54

FILES command ..+.-+ ++ « 54

FIX . «© «© © © @ © wo we ew ew we TE

FOR «6 ew ew we ee ee ee 22
FRCINT 2. 1 e ee eo ee we we ee 41

PRE « e« 6 ew ew ew ee ee ke ee FY
Functions . 2. 2 1 « «© 6 © e « 28
Functions, derived ..... . 189
Punctions, extended .... . 46 ;
Punctions, intrinsic .... . 28
Functions, simulated (for 4k 1249 é

============================================================
Page 159
============================================================
January, 1977 Page 147

Functions, string .... +. . 32
Functions, user~defined .. . 29

GET 2. ww ee ee ee 69
GOSUB .. 1 ee wwe ee ew 22
GOTO... ee ee ew ee we ew YD

HEXS . 2 2» «2 © wo wm awe
Hexadecimal constants .... 12

IF,..GOTO . .. 226 © «© © © «© 2
IF...THEN . «4 « » «2» «© «@ «@ 2 2 LY
IP...THEN...ELSE . . 2. 2 ss s 28
IMP . e . * . oJ * * . . . . oJ 1 a
Indirect Mode . 2. 2.2 1. 2. sw a a §
Initialization dialo « = + » 182
Initialization dialog, disk . 122
Initializing a disk .... . 124
INP 2. 2 «© © © © © ee tt ow ee 28
INPUT 2. 6. 1 6 ew wt tw ew we ew 29
INPUT, disk . 4. «6 «2 © © «© © « 5F
INSTR 2. 2. 0 we pw we ew ew TY
INT 1. 2. 6 © © ee eo we oe ew et ss BG
Intellec systems, Altair BASIC on. 128

KILL 2 0 6 2 we ee ew wk 5

LEFT$ . « + © «© + © © © we 6 e BF
LEN 2. et ww we te eh we we tl BE
LET «2 2 ew ph ew ew ew et we wh ew we 18
Line 2. 6. 5 we we ew we ee we oe G
LINE FEED .... «5s «© « « 2 8&4
LINE INPUT . . 2. «© « © «© © « « 33
LINE INPUT, disk . .....- . 61
Line LENGTH ....... 2. +4
Line Number... 6. 6 s 2» «© « 6
LIST . 2» 6 2 2 © © © @ 2 et ee 72
Lists and Directories ... . 78
LLIST 2. 2 6 ee ew we we ew ew 72
LOAD . 1 nw ew we we we we te 5H
Loader errors . +.» 6 + + + + 162
Loading BASIC ....4..... 95
LOC 6 ww ee te ew ww 64
LOP 2. 2 ew ew ew wt we we wt he G4
LOG . 6 6 ew ew te ee we eww we BB
Loops .« . 6 6 © ew ew ew ew we ZL
Lower case input ....... 85
LPOS . 1. ew wt we ww ek BD
LPRINT 2 2 6 6 6 1 eh @ eo ow a 7H
LPRINT USING . . . 2. 6 e © « « 75
LSET 2.6 1 6 ww tt ee ew GF

MAKINT « 2 2 6 6 © © «@ ee ow 41
MERGE . 2 6 we 8 ee et ew ww 57
MIDS 2 2. 6 0 © © © ew wt we ow FH


============================================================
Page 160
============================================================
January, 1977

MID$ function
MKD$ ..-
MKI$ ....
MRSS . 2. «4
MOD operator
MOUNT . «2. .

NAME . 2. 2
NEW . . . oJ
NEW in disk
NEXT «eae
NOT ...-
NGdLL

OCTS 2. + ew ew
Octal constants
ON ERROR GOTO .
ON...GOSUB ...
ON...GOTO ...
OPEN . . 2» 2 «
OPEN, random files. .
Operators .. + +4 -
OPERATORS, extended and
Operators, logical...
Operators, precedence of
Operators, relational
Operators, string ...
OR . «4 «© © © © we we
OUT 2. . ww ww we

s+ we eee
ee en
es © 2 eo

PEEK . 4 0 6 se ew
PIP utility program
PIP, CNY command . .
PIP, COP command
PIP, DAT command
PIP, DIR command
PIP, INI command
PIP, LIS command
PIP, SRT command
POKE 1. 1 6 6© ©
POS . «ee ee .
Precedence, table of
PRINT . 2. « © @
PRINT USING ..
PRINT, disk ..
Prompt string

PTD program ..
PUT «1 we we a

Random buffer . .
Random File I/O .
Random files...
READ. 1. 1. 6 ew
RemarkS ... 4 6
RENUM . .« «© «© «© «
Reserved WORDS . .

disk

86
67

67
49
53

37
72
61
22
i?
yes
86
12
36
23

58
63
15
39
17
15
16
31

27

27

124
126
125
126
125
124
125
125

81
16
24
47
6G
23
135
63

63
63
54

win oO

Page 148

============================================================
Page 161
============================================================
January, 1977

Reserved words

RESTORE
RESUME .
RESOME
RETURN .
RIGATS .
REND.
RSET ..
RUBOUT .
Rubout .

RUN...
RON, disk

SAVE ..

NE&T

files

ite

Scientific not

ation
Sense switch gettings

Sequential File 1/0

Sequential mode

SGN
.SIN « -

Single precision

Space allocation

Space hints

SPACES .
SPC ..

*

Special Characters

Speed hints

SQR ..

*

Statements .

Statements, extende

STOP . -
STRS . .

String Literal

STRINGS
Strings

Subroutines

+

Subroutines,

SWAP ..

TAB.
TAN « «
TROFF .
TRON . .

Type of constants
Type of variables
type definition

UNLOAD .
USR ..

VAL ..

Variable types

Variables
VARPTR .«.

machin

7“ s # ©
7 es * #
“ # # «

*

.

.
+
.
«

ee @ #

d

.
€

oe ve «

Pe ee ie o

ow

2 ee a il

iQ

«fee es + wo wee we eee eee eee PR

oe @ © @ © +

fo

ee ee ee Mev es eo we eevee ee ne ee eee eH oe HO
o

7 # «

61, 77

Page 149


============================================================
Page 162
============================================================
January, 1977

WAIT . . .
WIDTH ..

KOR «2 a

26

35
18

83
83

============================================================
Page 163
============================================================
