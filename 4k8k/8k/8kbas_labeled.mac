;8K BASIC Version 4.0 for Altair 8800
;Disassembled by ud80

	.8080

;Macro: rdc - Reverse DC (high bit on FIRST character)
rdc	macro	str
	local	first
first	set	1
	irpc	ch,<str>
	if	first
	db '&ch' + 80h
first	set	0
	else
	db '&ch'
	endif
	endm
	endm

	org 0000H

;=============================================================================
;RST 0 - Start / Cold Boot Entry Point
;=============================================================================
Start:	di				;Disable interrupts
	jmp Init			;Jump to initialization
;Function pointers (for extended BASIC compatibility)
fn_ptrs: dw L0738
D0006:	dw L0DE5

;=============================================================================
;RST 1 - SyntaxCheck
;The byte following RST 1 is the expected token. If mismatch, Syntax Error.
;If match, return address is adjusted and falls through to NextChar.
;=============================================================================
SyntaxCheck:
	mov a,m				;A = current byte of BASIC program
	xthl				;HL = return address (points to expected byte)
	cmp m				;Compare program byte to expected byte
L000B:	inx h				;Advance return address past expected byte
	xthl				;Restore HL, put adjusted return addr back
L000D:	jnz SyntaxError			;Error if bytes don't match
				;Fall through to NextChar if match

;=============================================================================
;RST 2 - NextChar
;Returns next character from buffer at HL, skipping spaces.
;Carry set if numeric (0-9). Zero set if null terminator.
;=============================================================================
NextChar:
	inx h				;Advance to next character
	mov a,m				;Get character
	cpi 3AH				;Compare to ':'
	rnc
	jmp L0653			;Handle spaces and digits

;=============================================================================
;RST 3 - OutChar
;Outputs character in A to terminal, with output suppression check.
;=============================================================================
OutChar:
	push psw
	lda suppress_output
	ora a
	jmp L052D

;=============================================================================
;RST 4 - CompareHLDE
;Compares HL and DE. Returns Z if HL==DE, sets flags like 8-bit compare.
;=============================================================================
CompareHLDE:
	mov a,h				;Compare high bytes first
	sub d
	rnz				;Return if high bytes differ
	mov a,l				;Compare low bytes
	sub e
	ret

terminal_y: db 01H			;0026 - Current Y position (row)
terminal_x: db 00H			;0027 - Current X position (column)

;=============================================================================
;RST 5 - FTestSign
;Tests sign of floating point accumulator (FAC).
;Returns: A=0 and Z set if FAC==0, A=0xFF if negative, A=0x01 if positive
;=============================================================================
FTestSign:
	lda D0256			;Get FAC exponent
	ora a				;Test if zero
	jnz L1469			;If not zero, determine sign
	ret				;Return with A=0, Z set

;=============================================================================
;RST 6 - Unused in 8K (zeros)
;=============================================================================
	db 00H				;0030
	db 00H				;0031
	db 00H				;0032
	db 00H				;0033
	db 00H				;0034
	db 00H				;0035
	db 00H				;0036
	db 00H				;0037

;=============================================================================
;RST 7 - Return (minimal handler)
;=============================================================================
rst7:	ret
	db 0EH				;0039
	db 02H				;003A

szCRLF:	db 0DH				;003B - CR
	db 0AH				;003C - LF
szBreak:
	db 42H				;003D - 'B'
	db 52H				;003E
	db 45H				;003F
	db 41H				;0040
	db 4BH				;0041
	db 00H				;0042
					;end disk functions
;spcdsk functions
;the following tables are the alphabetic dispatch table
;followed by the reserved word table itself
stmt_dispatch: dw StmtEND
	dw StmtFOR
	dw StmtNEXT
	dw StmtDATA
	dw StmtINPUT
	dw StmtDIM
	dw StmtREAD
	dw Log
	dw StmtGOTO
	dw FCompare
	dw StmtDEF
D0059:	dw Sin
D005B:	dw L187C
D005D:	dw Cos
					;end disk functions
;spcdsk functions
;the following tables are the alphabetic dispatch table
;followed by the reserved word table itself
D005F:	dw StmtLET
	dw Right
	dw StmtNEW
	dw StmtLIST
	dw StmtPOKE
	dw StmtSTOP
	dw StmtOUT
	dw StmtON
	dw StmtNULL
	db 0ABH				;0071
stmt_dispatch_end: db 10H		;0072
keywords:
	rdc	<END>
	rdc	<FOR>
	rdc	<NEXT>
	rdc	<DATA>
	rdc	<INPUT>
	rdc	<DIM>
	rdc	<READ>
	rdc	<LET>
	rdc	<GOTO>
	rdc	<RUN>
	rdc	<IF>
	rdc	<RESTORE>
	rdc	<GOSUB>
	rdc	<RETURN>
	rdc	<REM>
	rdc	<STOP>
	rdc	<OUT>
	rdc	<ON>
	rdc	<NULL>
	rdc	<WAIT>
	rdc	<DEF>
	rdc	<POKE>
	rdc	<PRINT>
	rdc	<CONT>
	rdc	<LIST>
	rdc	<CLEAR>
	rdc	<CLOAD>
	rdc	<CSAVE>
	rdc	<NEW>
	rdc	<TAB(>
	rdc	<TO>
	rdc	<FN>
	rdc	<SPC(>
	rdc	<THEN>
	rdc	<NOT>
	rdc	<STEP>
	db 0ABH				;+
	db 0ADH				;-
	db 0AAH				;*
	db 0AFH				;/
	db 0DEH				;^
	rdc	<AND>
	rdc	<OR>
	db 0BEH				;>
	db 0BDH				;=
	db 0BCH				;<
	rdc	<SGN>
	rdc	<INT>
	rdc	<ABS>
	rdc	<USR>
	rdc	<FRE>
	rdc	<INP>
	rdc	<POS>
	rdc	<SQR>
	rdc	<RND>
	rdc	<LOG>
	rdc	<EXP>
	rdc	<COS>
	rdc	<SIN>
	rdc	<TAN>
	rdc	<ATN>
	rdc	<PEEK>
	rdc	<LEN>
	rdc	<STR$>
	rdc	<VAL>
	rdc	<ASC>
	rdc	<CHR$>
	rdc	<LEFT$>
	rdc	<RIGHT$>
	rdc	<MID$>
	db 80H				;End of keyword table
D015B:	dw 0681H			;015B: 81 06
	dw Print
	dw FNegate
	dw Restore
	dw L095E
	dw Sqr
	dw FMul
	dw L0811
	dw L07B9
	dw Gosub
	dw L087F
	dw L065E
	dw Goto
	dw Return
	dw 07FCH			;0177: FC 07
	dw L067F
	dw Len
	dw L0863
	dw L06C0
	dw Asc
	dw L0DF9
	dw Mid
	dw L089B
	dw L06AD
	dw L056D
	dw L0773
	dw Left
	dw Chr
	dw L03B0
D0195:	db 79H				;0195
	db 0EBH				;0196
	db 15H				;0197
	db 79H				;0198
	db 1CH				;0199
	db 12H				;019A
	db 7CH				;019B
	db 59H				;019C
	db 13H				;019D
	db 7CH				;019E
	db 0B7H				;019F
	db 13H				;01A0
	db 7FH				;01A1
	db 08H				;01A2
	db 17H				;01A3
	db 50H				;01A4
	db 9CH				;01A5
	db 0BH				;01A6
	db 46H				;01A7
	db 9BH				;01A8
	db 0BH				;01A9
error_codes: db 4EH			;01AA
	db 46H				;01AB
	db 53H				;01AC
	db 4EH				;01AD
	db 52H				;01AE
	db 47H				;01AF
	db 4FH				;01B0
	db 44H				;01B1
	db 46H				;01B2
	db 43H				;01B3
	db 4FH				;01B4
	db 56H				;01B5
	db 4FH				;01B6
	db 4DH				;01B7
	db 55H				;01B8
	db 4CH				;01B9
	db 42H				;01BA
	db 53H				;01BB
	db 44H				;01BC
	db 44H				;01BD
	db 2FH				;01BE
	db 30H				;01BF
	db 49H				;01C0
	db 44H				;01C1
	db 54H				;01C2
	db 4DH				;01C3
	db 4FH				;01C4
	db 53H				;01C5
	db 4CH				;01C6
	db 53H				;01C7
	db 53H				;01C8
	db 54H				;01C9
	db 43H				;01CA
	db 4EH				;01CB
	db 55H				;01CC
	db 46H				;01CD
	db 4DH				;01CE
	db 4FH				;01CF
ctrl_o_flag: db 00H			;01D0
suppress_output: db 00H			;01D1
stack_top: db 73H			;01D2
	db 1CH				;01D3
current_line: db 0FEH			;01D4
	db 0FFH				;01D5
program_base: db 10H			;01D6
	db 1CH				;01D7
D01D8:	db 2CH				;01D8
D01D9:	db 00H				;01D9
	db 00H				;01DA
	db 00H				;01DB
	db 00H				;01DC
	db 00H				;01DD
	db 00H				;01DE
	db 00H				;01DF
	db 00H				;01E0
	db 00H				;01E1
	db 00H				;01E2
	db 00H				;01E3
	db 00H				;01E4
	db 00H				;01E5
	db 00H				;01E6
	db 00H				;01E7
	db 00H				;01E8
	db 00H				;01E9
	db 00H				;01EA
	db 00H				;01EB
	db 00H				;01EC
	db 00H				;01ED
	db 00H				;01EE
	db 00H				;01EF
	db 00H				;01F0
	db 00H				;01F1
	db 00H				;01F2
	db 00H				;01F3
	db 00H				;01F4
	db 00H				;01F5
	db 00H				;01F6
	db 00H				;01F7
	db 00H				;01F8
	db 00H				;01F9
	db 00H				;01FA
	db 00H				;01FB
	db 00H				;01FC
	db 00H				;01FD
	db 00H				;01FE
	db 00H				;01FF
	db 00H				;0200
	db 00H				;0201
	db 00H				;0202
	db 00H				;0203
	db 00H				;0204
	db 00H				;0205
	db 00H				;0206
	db 00H				;0207
	db 00H				;0208
	db 00H				;0209
	db 00H				;020A
	db 00H				;020B
	db 00H				;020C
	db 00H				;020D
	db 56H				;020E
	db 05H				;020F
	db 47H				;0210
	db 05H				;0211
	db 68H				;0212
	db 06H				;0213
	db 0CH				;0214
	db 06H				;0215
	db 7FH				;0216
	db 19H				;0217
	db 0A8H				;0218
	db 19H				;0219
	db 00H				;021A
	db 00H				;021B
	db 00H				;021C
	db 00H				;021D
	db 00H				;021E
	db 00H				;021F
	db 00H				;0220
	db 00H				;0221
	db 00H				;0222
D0223:	db 00H				;0223
D0224:	db 00H				;0224
D0225:	db 00H				;0225
D0226:	db 00H				;0226
	db 00H				;0227
D0228:	db 00H				;0228
	db 00H				;0229
D022A:	db 00H				;022A
	db 00H				;022B
	db 00H				;022C
	db 00H				;022D
	db 00H				;022E
	db 00H				;022F
	db 00H				;0230
	db 00H				;0231
	db 00H				;0232
	db 00H				;0233
	db 00H				;0234
	db 00H				;0235
D0236:	db 00H				;0236
	db 00H				;0237
D0238:	db 00H				;0238
	db 00H				;0239
D023A:	db 00H				;023A
	db 00H				;023B
D023C:	db 00H				;023C
	db 00H				;023D
D023E:	db 00H				;023E
	db 00H				;023F
D0240:	db 00H				;0240
D0241:	db 00H				;0241
D0242:	db 00H				;0242
D0243:	db 00H				;0243
	db 00H				;0244
D0245:	db 00H				;0245
	db 00H				;0246
D0247:	db 00H				;0247
	db 00H				;0248
D0249:	db 00H				;0249
	db 00H				;024A
D024B:	db 00H				;024B
	db 00H				;024C
D024D:	db 00H				;024D
	db 00H				;024E
D024F:	db 00H				;024F
	db 00H				;0250
D0251:	db 00H				;0251
	db 00H				;0252
D0253:	db 00H				;0253
	db 00H				;0254
D0255:	db 00H				;0255
D0256:	db 00H				;0256
D0257:	db 00H				;0257
D0258:	db 00H				;0258
	db 00H				;0259
	db 00H				;025A
	db 00H				;025B
	db 00H				;025C
	db 00H				;025D
	db 00H				;025E
	db 00H				;025F
	db 00H				;0260
	db 00H				;0261
	db 00H				;0262
	db 00H				;0263
	db 00H				;0264
szError: db 20H				;0265
	db 45H				;0266
	db 52H				;0267
	db 52H				;0268
	db 4FH				;0269
	db 52H				;026A
	db 00H				;026B
szIn:	db 20H				;026C
	db 49H				;026D
	db 4EH				;026E
	db 20H				;026F
D0270:	db 00H				;0270
szOK:	db 4FH				;0271
	db 4BH				;0272
	db 0DH				;0273
	db 0AH				;0274
	db 00H				;0275
;=============================================================================
;GetFlowPtr - Find Flow Control Structure on Stack
;Sets HL to point to the appropriate flow struct (FOR/GOSUB) on stack.
;For NEXT, DE points to the loop variable to match against FOR structs.
;Returns with A = keyword ID byte (81H for FOR, 8CH for GOSUB)
;=============================================================================
GetFlowPtr: lxi h,fn_ptrs
	dad sp				;HL = SP + 4
L027A:	mov a,m				;Get keyword ID byte
	inx h				;Point to flow struct
	cpi 81H				;Is it FOR (81H)?
	rnz				;Return if not FOR (found GOSUB or end)
	mov c,m
	inx h				;do equivalent of pushm / xthl
	mov b,m
	inx h
	push h				;put h  on
	mov l,c
	mov h,b
	mov a,d				;for the "NEXT" statment without an argument
	ora e				;we match on anything
	xchg				;make sure we return [d,e]
	jz L028E			;pointing to the variable
	xchg
	rst 4
L028E:	lxi b,L000D			;to wipe out a "FOR" entry
	pop h
	rz				;if variable in this entry matches
	dad b
	jmp L027A			;now pointing to the start of the next
;=============================================================================
;CopyMemoryUp - Copy Memory Block Upward
;Copies from HL to BC, going backwards (down) until HL==DE.
;Used to make room for inserting program lines.
;=============================================================================
CopyMemoryUp: call 02AFH
					;sure the stack won'T BE OVERRUN
					;sure the stack won'T BE OVERRUN
bltuc:	push b				;exchange [b,c] and [h,l]
	xthl
	pop b
L029D:	rst 4				;Compare HL and DE
	mov a,m				;Get source byte
	stax b				;Store to destination
	rz				;Done when HL==DE
	dcx b				;Move backward
	dcx h
	jmp L029D
;=============================================================================
;CheckEnoughVarSpace - Check Variable Storage Space
;Checks that there's room for C*2 bytes on top of VAR_TOP before stack.
;=============================================================================
CheckEnoughVarSpace: push h
	lhld D024F			;Get top of variable storage
	mvi b,00H
	dad b
	dad b
	mvi a,0E5H
	mvi a,0D4H
	sub l
	mov l,a
	mvi a,0FFH
	sbb h
	mov h,a
	dad sp				;Add stack pointer
	pop h
	rc				;Return if enough room (no carry)
;=============================================================================
;Error Entry Points
;Uses LXI trick: LXI B,xxxx is 01 xx xx, which skips over 2 bytes
;=============================================================================
OutOfMemory: mvi e,0CH			;Error code 0C (OM - Out of Memory)
	jmp Error
datsne:	lhld D023E
	shld current_line
SyntaxError: mvi e,02H
	lxi b,L141E
	lxi b,001EH
	lxi b,L121E
;=============================================================================
;Error - Print Error Message and Return to Main Loop
;E = error code (offset into error_codes table)
;=============================================================================
Error:	call L03D5
	sta suppress_output
	call ptrchk
	lxi h,error_codes
	mov d,a
	mvi a,3FH
	rst 3
	dad d				;HL = error_codes + E
	mov a,m				;Get first char of error code
	rst 3				;Print it
	rst 2				;Advance HL, get second char
	rst 3				;Print it
	lxi h,szError			;Point to " ERROR" string
L02E9:	call finex			;Print it (skip INX HL)
	lhld current_line		;Get current line number
	mov a,h				;Check if in direct mode (FFFF)
	ana l
	inr a				;A = 0 if FFFF (direct mode)
	cnz L15FC			;Print " IN <line>" if running program
	mvi a,0C1H
;=============================================================================
;Main - The BASIC Prompt Loop
;Prints "OK", gets user input, and either executes or stores program lines
;=============================================================================
Main:	xra a				;set zero flag in [a]
	sta suppress_output
	call ptrchk
	lxi h,szOK			;Point to "\rOK\r" string
	call Init			;First time: Init (patched to PrintString after)
L0304:	lxi h,0FFFFH			;Set line number to FFFF (direct mode)
	shld current_line
	call L04D4			;Get line of input
	jc L0304
	xra a
	sta D0241
	rst 2				;Get first char
	inr a				;Test if A==0 without affecting carry
	dcr a				;(INR/DCR don't affect carry)
	jz L0304			;Loop if blank line
	push psw			;Save carry flag (set if first char is digit)
	call L0752			;Try to parse line number into DE
	push d				;Save line number
	call L03F8			;Tokenize the input line
	mov b,a				;B = 0 (from Tokenize), BC = line length
	pop d				;DE = line number
	pop psw				;Restore carry flag
	jnc L0630			;If no line number, execute immediately
	push d				;Save line number
	push b				;Save line length
	rst 2				;Get first char of tokenized line
	ora a				;Z set if line is empty (deleting line)
	push psw			;Save empty-line flag
	call L0392			;Find where line should go (BC=addr)
	jc L0339			;line exists, delete it
	pop psw				;get flag says whether line blank
	push psw			;save back
	jz L07D0			;trying to delete non-existant line, error
	ora a				;clear flag that says line exists
L0339:	push b				;save the pointer
	jnc GetNonBlankLine		;Jump if line doesn't exist yet
	xchg				;DE = next line address
	lhld D024B			;HL = end of program
mloop:	ldax d				;Copy byte from DE to BC
	stax b
	inx b
	inx d
	rst 4				;Compare HL and DE
	jnz mloop			;Loop until DE reaches VAR_BASE
	mov h,b				;Update VAR_BASE
	mov l,c
	shld D024B
;-----------------------------------------------------------------------------
;GetNonBlankLine - Get a line of input from the user
;-----------------------------------------------------------------------------
GetNonBlankLine: pop d			;DE = line address
	pop psw				;Restore empty-line flag
	jz L0375			;If empty line, just update links
	lhld D024B			;HL = end of program
	xthl				;HL = line length, stack = VAR_BASE
	pop b				;BC = VAR_BASE
	dad b				;HL = new VAR_BASE
	push h
	call CopyMemoryUp		;Move program up to make room
	pop h
	shld D024B			;Update VAR_BASE
	xchg				;HL = line address
	mov m,h				;Store (temporary) next-line pointer
	pop d				;DE = line number
	inx h
	inx h
	mov m,e				;Store line number (low)
	inx h
	mov m,d				;Store line number (high)
	inx h
	lxi d,D01D9
mloopr:	ldax d				;now transfering line
	mov m,a
	inx h
	inx d
	ora a				;Check for null terminator
	jnz mloopr
L0375:	call L03BC			;Reset to start of program
	inx h
	xchg
;
;chead goes through program storage and fixes
;up all the links. the end of each
;line is found by searching for the zero at the end.
;the double zero link is used to detect the end of the program
;
;
;chead goes through program storage and fixes
;up all the links. the end of each
;line is found by searching for the zero at the end.
;the double zero link is used to detect the end of the program
;
chead:	mov h,d				;[h,l]=[d,e]
	mov l,e
	mov a,m				;Check for end of program
	inx h
	ora m				;(next-line ptr is 0000)
	jz L0304			;Done - go get next input
	inx h				;Skip line number
	inx h
	inx h
	xra a				;Find end of line (null byte)
L0386:	cmp m
	inx h
	jnz L0386
	xchg				;DE = next line address
	mov m,e				;Store next-line pointer
	inx h
	mov m,d
	jmp chead
L0392:	lhld program_base		;get pointer to start of text
;
;fndlin searches the program text for the line
;whose line # is passed in [d,e]. [d,e] is preserved.
;there are three possible returns:
;
;	1) zero flag set. carry not set.  line not found.
;	   no line in program greater than one sought.
;	   [b,c] points to two zero bytes at end of program.
;	   [h,l]=[b,c]
;
;	2) zero, carry set.
;	   [b,c] points to the link field in the line
;	   which is the line searched for.
;	   [h,l] points to the link field in the next line.
;
;	3) non-zero, carry not set.
;	   line not found, [b,c]  points to line in program
;	   greater than one searched for.
;	   [h,l] points to the link field in the next line.
;
fndlin:	mov b,h				;if exiting because of end of program,
	mov c,l
	mov a,m				;get word pointer to
	inx h				;bump pointer
	ora m				;get 2nd byte
	dcx h				;go back
	rz				;if zero then done
	inx h				;skip past and get the line #
	inx h
	mov a,m				;into [h,l] for comparison with
	inx h				;the line # being searched for
	mov h,m				;which is in [d,e]
	mov l,a
	rst 4
	mov h,b				;make [h,l] point to the start of the
	mov l,c				;line beyond this one, by picking
	mov a,m				;up the link that [b,c] points at
	inx h
	mov h,m
	mov l,a
	cmc				;turn carry on
	rz				;equal return
	cmc				;make carry zero
	rnc				;no match return (greater)
	jmp fndlin			;keep looping
L03B0:	rnz				;Syntax error if arguments
InputLineWithQ: lhld program_base	;Get program base
	xra a				;Write null terminator (empty program)
	mov m,a
	inx h
	mov m,a
	inx h
	shld D024B			;VAR_BASE = just after program
L03BC:	lhld program_base
	dcx h
L03C0:	shld D0243
	lhld D0226			;get file pointer, could be zero
	shld D023A			;save it
	call L065E			;do clear & set up stack
	lhld D024B			;reset [filptr]
	shld D024D
	shld D024F
L03D5:	pop b
	lhld stack_top
	sphl
	lxi h,D022A
	shld D0228
	xra a
	mov l,a
	mov h,a
	shld D0249			;and no parameter blocks on the stack
	sta D0240			;allow subscripts
	push h				;put zero (non $for,$gosub)
	push b				;put return address back on
finnow:	lhld D0243			;get saved [h,l]
	ret
L03EF:	mvi a,3FH
	rst 3
	mvi a,20H
	rst 3
	jmp L04D4
L03F8:	xra a
	sta D0225
	mvi c,05H
	lxi d,D01D9
L0401:	mov a,m
	cpi 20H
	jz L047E
	mov b,a
	cpi 22H
	jz L049E
	ora a
	jz L04A5
	lda D0225
	ora a
	mov a,m
	jnz L047E
	cpi 3FH
	mvi a,96H
	jz L047E
	mov a,m
	cpi 30H
	jc L042B
	cpi 3CH
	jc L047E
L042B:	push d
	lxi d,stmt_dispatch_end
	push b
	lxi b,D047A
	push b
	mvi b,7FH
	mov a,m
	cpi 61H
	jc Tokenize
	cpi 7BH
	jnc Tokenize
	ani 5FH
	mov m,a
;=============================================================================
;Tokenize - Convert Input Line to Tokenized Form
;Replaces keywords with single-byte tokens.
;Input: HL points to input buffer
;Output: C = length of tokenized line + overhead, A = 0
;=============================================================================
Tokenize: mov c,m
	xchg				;HL = keyword ptr, DE = input ptr
L0446:	inx h				;Advance to next keyword char
	ora m				;Check for end of keyword (bit 7 set)
	jp L0446			;Loop if not end of keyword yet
	db 04H				;044B
	db 7EH				;044C
	db 0E6H				;044D
	db 7FH				;044E
	db 0C8H				;044F
	db 0B9H				;0450
	db 0C2H				;0451
	db 46H				;0452
	db 04H				;0453
	db 0EBH				;0454
	db 0E5H				;0455
	db 13H				;0456
	db 1AH				;0457
	db 0B7H				;0458
	db 0FAH				;0459
	db 76H				;045A
	db 04H				;045B
	db 4FH				;045C
	db 78H				;045D
	db 0FEH				;045E
	db 88H				;045F
	db 0C2H				;0460
	db 65H				;0461
	db 04H				;0462
	db 0D7H				;0463
	db 2BH				;0464
	db 23H				;0465
	db 7EH				;0466
	db 0FEH				;0467
	db 61H				;0468
	db 0DAH				;0469
	db 6EH				;046A
	db 04H				;046B
	db 0E6H				;046C
	db 5FH				;046D
	db 0B9H				;046E
	db 0CAH				;046F
	db 56H				;0470
	db 04H				;0471
	db 0E1H				;0472
	db 0C3H				;0473
	db 44H				;0474
	db 04H				;0475
	db 48H				;0476
	db 0F1H				;0477
	db 0EBH				;0478
	db 0C9H				;0479
D047A:	db 0EBH				;047A
	db 79H				;047B
	db 0C1H				;047C
	db 0D1H				;047D
L047E:	inx h
	stax d
	inx d
	inr c
	sui 3AH
	jz L048C
	cpi 49H
	jnz L048F
L048C:	sta D0225
L048F:	sui 54H
	jnz L0401			;No - continue tokenizing
	mov b,a				;B = 0 (terminator for FreeCopy)
sngau1:	mov a,m				;see if zero
	ora a				;Null terminator?
	jz L04A5			;Exit if end
	cmp b				;Terminator character?
	jz L047E			;If so, write it and resume tokenizing
L049E:	inx h				;Advance input
	stax d				;Copy character
	inr c				;Increment length
	inx d
	jmp sngau1
L04A5:	lxi h,D01D8			;Point to comma before LINE_BUFFER
	stax d				;Write three null terminators
	inx d
	stax d
	inx d
	stax d
	ret
L04AE:	lda ctrl_o_flag
	ora a
	mvi a,5CH
	sta ctrl_o_flag
	jnz 04C0H
	dcr b
	jz L04D4
	rst 3
	mvi a,05H
	dcx h
	jz L04D0
	mov a,m
	rst 3
	jmp L04DD
L04CA:	dcr b				;Decrement char count
	dcx h				;Back up pointer
	rst 3				;Echo backspace char
	jnz L04DD			;Continue if not at start
L04D0:	rst 3				;Echo cancel char
	call L08ED			;Print newline
L04D4:	lxi h,D01D9			;Point to input buffer
	mvi b,01H
	xra a
	sta ctrl_o_flag
L04DD:	call L0556
	mov c,a
	cpi 7FH
	jz L04AE
	lda ctrl_o_flag
	ora a
	jz L04F4
	mvi a,5CH
	rst 3
	xra a
	sta ctrl_o_flag
L04F4:	mov a,c
	cpi 07H
	jz L051A
	cpi 03H
	cz L08ED
	stc
	rz
	cpi 0DH
	jz L08E8
	cpi 15H
	jz L04D0
	cpi 40H
	jz L04D0
	cpi 5FH
	jz L04CA
	cpi 20H
	jc L04DD
L051A:	mov a,b
	cpi 48H
	mvi a,07H
	jnc L0529
	mov a,c
	mov m,c
	sta D0241
	inx h
	inr b
L0529:	rst 3
	jmp L04DD
;
;here when the data that was typed in or in "DATA" statements
;is improperly formatted. for "INPUT" we start again.
;for "READ" we give a syntax error at the data line
;
L052D:	lda suppress_output		;was it read or input?
	ora a
	jnz L0F14
	pop psw
	push psw
	cpi 20H
	jc L0547
	lda terminal_x
	cpi 48H
	cz L08ED
	inr a
	sta terminal_x
L0547:	in 00H
	ani 0C8H
	jnz L0547
	pop psw
	out 01H
	push psw
L0552:	in 13H				;Check for paper tape mode
	pop psw
	ret
L0556:	in 00H				;Check receive ready (port 0 status)
	ani 01H				;Mask ready bit
	jnz L0556			;Wait until ready
	in 01H				;Get character (port 1 data)
	ani 7FH				;Strip high bit
	cpi 0FH
	rnz
	lda suppress_output
	cma
	sta suppress_output
	xra a
	ret
L056D:	call L0752
	db 0C0H				;0570
	db 0C1H				;0571
	db 0CDH				;0572
	db 92H				;0573
	db 03H				;0574
	db 0C5H				;0575
	db 0E1H				;0576
	db 4EH				;0577
	db 23H				;0578
	db 46H				;0579
	db 23H				;057A
	db 78H				;057B
	db 0B1H				;057C
	db 0CAH				;057D
	db 0F7H				;057E
	db 02H				;057F
	db 0CDH				;0580
	db 68H				;0581
	db 06H				;0582
	db 0C5H				;0583
	db 0CDH				;0584
	db 0EDH				;0585
	db 08H				;0586
	db 5EH				;0587
	db 23H				;0588
	db 56H				;0589
	db 23H				;058A
	db 0E5H				;058B
	db 0EBH				;058C
	db 0CDH				;058D
	db 04H				;058E
	db 16H				;058F
	db 3EH				;0590
	db 20H				;0591
	db 0E1H				;0592
	db 0DFH				;0593
	db 7EH				;0594
	db 0B7H				;0595
	db 23H				;0596
	db 0CAH				;0597
	db 76H				;0598
	db 05H				;0599
	db 0F2H				;059A
	db 93H				;059B
	db 05H				;059C
	db 0D6H				;059D
	db 7FH				;059E
	db 4FH				;059F
	db 11H				;05A0
	db 73H				;05A1
	db 00H				;05A2
	db 1AH				;05A3
	db 13H				;05A4
	db 0B7H				;05A5
	db 0F2H				;05A6
	db 0A3H				;05A7
	db 05H				;05A8
	db 0DH				;05A9
	db 0C2H				;05AA
	db 0A3H				;05AB
	db 05H				;05AC
	db 0DFH				;05AD
	db 1AH				;05AE
	db 13H				;05AF
	db 0B7H				;05B0
	db 0F2H				;05B1
	db 0ADH				;05B2
	db 05H				;05B3
	db 0C3H				;05B4
	db 94H				;05B5
	db 05H				;05B6
;=============================================================================
;PRINT Handler
;Prints expressions, string literals, with optional formatting (TAB, comma, ;)
;=============================================================================
Print:	mvi a,64H
	sta D0240
	call L0811			;Assign initial value to loop variable
	xthl				;Swap prog ptr with return addr
	call GetFlowPtr			;Check for existing FOR with same var
	pop d				;DE = program pointer
	jnz L05C9			;If no existing FOR, skip cleanup
	dad b				;HL = old SP + struct size (remove old struct)
	sphl				;Clean up old FOR structure
L05C9:	xchg				;HL = prog ptr, DE = stack ptr
	mvi c,08H			;Check for 8*4=32 bytes stack space
	call CheckEnoughVarSpace
	push h				;Save program pointer
	call Restore			;Find end of FOR statement
	xthl				;Swap: (SP)=stmt end, HL=prog ptr
	push h				;Push program pointer
	lhld current_line		;Get current line number
	xthl				;Swap: (SP)=line number, HL=prog ptr
	call L0A86
	rst 1
	sbb m
	call L0A83			;Evaluate TO expression
	push h				;Save program pointer
	call L14AC			;Get TO value into BCDE
	pop h				;Restore program pointer
	push b				;Push TO value (high word)
	push d				;Push TO value (low word)
	lxi b,8100H			;B=81H (exponent), C=00
	mov d,c				;D=00
	mov e,d				;E=00
	mov a,m				;Get next token
	cpi 0A3H
	mvi a,01H
	jnz lexist
	rst 2
	call L0A83			;Skip token and evaluate STEP
	push h				;Save program pointer
	call L14AC			;Get STEP value into BCDE
	rst 5				;Test sign of STEP (sets A to direction)
	pop h				;Restore program pointer
lexist:	push b				;save the pointer
	push d				;Push STEP value (low word)
	push psw			;Push direction byte (1 or -1)
	inx sp				;Adjust SP (only push 1 byte)
	push h				;Push program pointer
	lhld D0243			;Get loop variable address
	xthl				;Swap: (SP)=var addr, HL=prog ptr
L0608:	mvi b,81H			;FOR token ID
	push b				;Push token byte
	inx sp				;Adjust SP (only push 1 byte)
L060C:	in 00H
	ani 01H
	cz L066D
	shld D0243
	mov a,m
	cpi 3AH
	jz L0630			;If colon, execute next statement
	ora a				;Is it null (end of line)?
	jnz SyntaxError			;If not null or colon, syntax error
	inx h				;Skip null terminator
	mov a,m				;Get low byte of next line address
	inx h
	ora m				;OR with high byte
	jz L0689			;If both zero, end of program
	inx h				;Point to line number
	mov e,m				;Get line number low byte
	inx h
	mov d,m				;Get line number high byte
	xchg				;HL = line number
	shld current_line		;Store current line number
	xchg				;HL = program pointer
L0630:	rst 2				;Get first character of statement
	lxi d,L060C			;Return address after statement
	push d				;Push return address
	rz				;Return if empty statement
	sui 80H				;Subtract keyword base
	jc L0811
	cpi 1DH
	jnc SyntaxError			;If >= 20, syntax error
	rlc				;Multiply by 2 (word table)
	mov c,a				;BC = offset into table
	mvi b,00H
	xchg				;DE = program pointer
	lxi h,D015B			;HL = function table
	dad b				;HL = pointer to function address
	mov c,m				;Get function address low byte
	inx h
	mov b,m				;Get function address high byte
	push b				;Push function address
	xchg				;HL = program pointer
L064E:	inx h
	mov a,m
	cpi 3AH
	rnc
L0653:	cpi 20H
	jz L064E
	cpi 30H
	cmc				;Complement carry (C set if digit)
	inr a				;Set Z flag if A was 0
	dcr a				;(without changing A)
	ret
L065E:	xchg				;Save HL in DE
	lhld program_base		;Get start of program
	dcx h				;Point to byte before program
resfin:	shld D0251			;read finishes come to resfin
	xchg				;Restore HL
	ret
L0668:	in 00H				;Check if key pressed
	ani 01H				;Mask ready bit
	rnz				;Return if no key
L066D:	call L0556			;Get the character
	cpi 03H				;Is it Ctrl-C (break)?
	jz L067F			;If so, stop program
	cpi 11H
	jz L0668
	cpi 13H
	jz L066D
L067F:	rnz
	ori 0C0H
	shld D0243
	lxi h,0FFF6H
	pop b
L0689:	lhld current_line
	push psw			;save the message flag
	mov a,l
	ana h				;see if it was direct
	inr a
	jz scnval			;if not set up for continue
	shld D0247			;save old line #
	lhld D0243			;get pointer to start of statement
	shld D0249			;save it
scnval:	xra a				;set zero flag in [a]
	sta suppress_output		;force output
	call ptrchk
	pop psw
	lxi h,szCRLF
	jnz L02E9
	jmp Main
L06AD:	lhld D0249
	db 7CH				;06B0
	db 0B5H				;06B1
	db 1EH				;06B2
	db 20H				;06B3
	db 0CAH				;06B4
	db 0D1H				;06B5
	db 02H				;06B6
	db 0EBH				;06B7
	db 2AH				;06B8
	db 47H				;06B9
	db 02H				;06BA
	db 22H				;06BB
	db 0D4H				;06BC
	db 01H				;06BD
	db 0EBH				;06BE
	db 0C9H				;06BF
L06C0:	call L1131
	db 0C0H				;06C3
	db 3CH				;06C4
	db 0FEH				;06C5
D06C6:	db 48H				;06C6
	db 0D2H				;06C7
	db 4DH				;06C8
	db 07H				;06C9
	db 32H				;06CA
	db 26H				;06CB
	db 00H				;06CC
	db 0C9H				;06CD
L06CE:	mvi b,0FFH
L06D0:	rst 2
	mov a,b
	sta D0243
	mvi a,01H
	sta D0240
	jmp 0C44H
L06DD:	sta D0240
	mov b,h
	mov c,l
	dcx b
	dcx b
	dcx b
	dcx b
	lda D0243
	ora a
	push psw
	xchg
	dad d
	xchg
	mov c,m
	mvi b,00H
	dad b
	dad b
	inx h
	mvi b,0D2H
	jm L0703
	mov a,b
	call L114A
	call L114A
	jmp L0710
L0703:	mvi c,04H
L0705:	call L1140
	cmp b
	jnz L0703
	dcr c
	jnz L0705
L0710:	call L0A86
L0713:	rst 4
	jz pophsr
	pop psw
	push psw
	mov a,m
	cp L114D
	cm L1140
	mov m,a
	inx h
	jmp L0713
pophsr:	pop psw				;get off terminating digit
	pop h
	ret
L0728:	mov a,m
	cpi 41H
	rc
	cpi 5BH
	cmc
	ret
	db 0D7H				;0730
	db 0CDH				;0731
	db 83H				;0732
	db 0AH				;0733
L0734:	rst 5
	jm StmtDATA
L0738:	lda D0256
	cpi 90H
	jc qint
	lxi b,9080H
	lxi d,Start
	push h
	call fcomp
	pop h
	mov d,c
	rz
StmtDATA: mvi e,08H
	jmp Error
L0752:	dcx h
	lxi d,Start
L0756:	rst 2
	rnc
	push h
	push psw
	lxi h,L1998
	rst 4				;Compare HL to DE
	jc SyntaxError			;Error if > 6552 (result would be > 65529)
	mov h,d				;HL = DE
	mov l,e
	dad d				;HL = DE*2
	dad h				;HL = DE*4
	dad d				;HL = DE*5
	dad h				;HL = DE*10
	pop psw				;Restore digit character
	sui 30H
	mov e,a				;DE = digit value
	mvi d,00H
	dad d				;HL = result*10 + digit
	xchg				;DE = new result
	pop h				;Restore string pointer
	jmp L0756			;Continue parsing
L0773:	jz L03C0
	db 0CDH				;0776
	db 31H				;0777
	db 07H				;0778
	db 2BH				;0779
	db 0D7H				;077A
	db 0C0H				;077B
	db 0E5H				;077C
	db 2AH				;077D
	db 26H				;077E
	db 02H				;077F
	db 7DH				;0780
	db 93H				;0781
	db 5FH				;0782
	db 7CH				;0783
	db 9AH				;0784
	db 57H				;0785
	db 0DAH				;0786
	db 0BBH				;0787
	db 02H				;0788
	db 2AH				;0789
	db 4BH				;078A
	db 02H				;078B
	db 01H				;078C
	db 28H				;078D
	db 00H				;078E
	db 09H				;078F
	db 0E7H				;0790
	db 0D2H				;0791
	db 0BBH				;0792
	db 02H				;0793
	db 0EBH				;0794
	db 22H				;0795
	db 0D2H				;0796
	db 01H				;0797
	db 0E1H				;0798
	db 0C3H				;0799
	db 0C0H				;079A
	db 03H				;079B
;=============================================================================
;GOSUB Handler
;Sets up a flow control structure on stack and falls into GOTO.
;Stack structure: KWID_GOSUB (8CH), line number (2), prog ptr (2)
;=============================================================================
Gosub:	jz L03BC
	call L03C0
	lxi b,L060C
	jmp L07B8			;Continue parsing
	;Fall through to GOTO
;=============================================================================
;GOTO Handler
;Sets program execution to continue from the line number argument.
;=============================================================================
Goto:	mvi c,03H			;Need 3 words (6 bytes) stack space
	call CheckEnoughVarSpace
	pop b				;Preserve return address
	push h				;Push program pointer
	push h				;Push again (will become line number)
	lhld current_line		;Get current line number
	xthl				;Swap with stacked prog ptr
	mvi a,8CH			;KWID_GOSUB token
	push psw			;Push token (high byte)
	inx sp				;Adjust SP (only pushed 1 byte)
L07B8:	push b				;Push return address
L07B9:	call L0752			;Get target line number in DE
	call 07FCH
	push h
	lhld current_line
	rst 4
	pop h
	inx h
	cc fndlin
	cnc L0392
	mov h,b				;HL = line address
	mov l,c
	dcx h				;Adjust (FindProgramLine returns +1)
	rc				;Return if line found (carry set)
L07D0:	mvi e,0EH			;UL - Undefined Line error
	jmp Error
;=============================================================================
;RETURN Handler
;Returns program execution to statement after the last GOSUB.
;Information about where to return is kept in flow struct on stack.
;=============================================================================
Return:	rnz				;No arguments allowed
	mvi d,0FFH			;Search for any flow struct (not FOR)
	call GetFlowPtr			;Find flow structure on stack
	sphl				;Set SP to flow structure
	cpi 8CH				;Is it KWID_GOSUB?
	mvi e,04H			;RG - Return without Gosub error
	jnz Error			;Error if not GOSUB
	pop h				;Get saved line number
	shld current_line		;Restore current line
	inx h
	mov a,h
	ora l
	jnz L07F4
	lda D0241
	ora a
	jnz 02F6H
L07F4:	lxi h,L060C
	xthl
	mvi a,0E1H
;-----------------------------------------------------------------------------
;RESTORE Handler
;Resets the DATA pointer to just before the start of the program
;-----------------------------------------------------------------------------
Restore: lxi b,L0E3A
	nop
	mvi b,00H
exchqt:	mov a,c				;when a quote is seen the second
	mov c,b
	mov b,a
str1:	mov a,m				;get a char
	ora a				;zero is always a terminator
	rz
	cmp b				;test for the other terminator
	rz
	inx h
	cpi 22H
	jz exchqt
	jmp str1
L0811:	call 0C44H
	rst 1
	xra h
	push d
	lda D0224
	push psw
	call L0A94			;get the value of the formula
	pop psw				;get the valtyp of the
	xthl				;[h,l]=pointer to variable
	shld D0243
	rar
	call L0A88
	jz edent
L082A:	push h
	lhld D0253
	push h
	inx h
	inx h
	mov e,m				;get line # in [d,e]
	inx h
	mov d,m				;get high part
	lhld program_base
	rst 4
	jnc 084BH
	lhld stack_top
	rst 4
	pop d
	jnc L0853
	lhld D024B
	rst 4
	jnc L0853
	mvi a,0D1H
	call fretms
	xchg
	call frcinc
L0853:	call fretms
	pop h
	call L14BB
	pop h
	ret
edent:	push h				;save line #
	call L14B8			;Copy FACCUM to variable
	pop d				;DE = var address
	pop h				;HL = program pointer
	ret
L0863:	call L1131			;Evaluate left-hand side expression
	db 7EH				;0866
	db 47H				;0867
	db 0FEH				;0868
	db 8CH				;0869
	db 0CAH				;086A
	db 70H				;086B
	db 08H				;086C
	db 0CFH				;086D
	db 88H				;086E
	db 2BH				;086F
	db 4BH				;0870
	db 0DH				;0871
	db 78H				;0872
	db 0CAH				;0873
	db 36H				;0874
	db 06H				;0875
	db 0CDH				;0876
	db 53H				;0877
	db 07H				;0878
	db 0FEH				;0879
	db 2CH				;087A
	db 0C0H				;087B
	db 0C3H				;087C
	db 71H				;087D
	db 08H				;087E
L087F:	call L0A94
	db 7EH				;0882
	db 0FEH				;0883
	db 88H				;0884
	db 0CAH				;0885
	db 8AH				;0886
	db 08H				;0887
	db 0CFH				;0888
	db 0A1H				;0889
	db 2BH				;088A
	db 0CDH				;088B
	db 86H				;088C
	db 0AH				;088D
	db 0EFH				;088E
	db 0CAH				;088F
	db 0FCH				;0890
	db 07H				;0891
	db 0D7H				;0892
	db 0DAH				;0893
	db 0B9H				;0894
	db 07H				;0895
	db 0C3H				;0896
	db 35H				;0897
	db 06H				;0898
	db 2BH				;0899
	db 0D7H				;089A
L089B:	jz L08ED
	db 0C8H				;089E
	db 0FEH				;089F
	db 9DH				;08A0
	db 0CAH				;08A1
	db 16H				;08A2
	db 09H				;08A3
	db 0FEH				;08A4
	db 0A0H				;08A5
	db 0CAH				;08A6
	db 16H				;08A7
	db 09H				;08A8
	db 0E5H				;08A9
	db 0FEH				;08AA
	db 2CH				;08AB
	db 0CAH				;08AC
	db 02H				;08AD
	db 09H				;08AE
	db 0FEH				;08AF
	db 3BH				;08B0
	db 0CAH				;08B1
	db 35H				;08B2
	db 09H				;08B3
	db 0C1H				;08B4
	db 0CDH				;08B5
	db 94H				;08B6
	db 0AH				;08B7
	db 0E5H				;08B8
	db 3AH				;08B9
	db 24H				;08BA
	db 02H				;08BB
	db 0B7H				;08BC
	db 0C2H				;08BD
	db 0D9H				;08BE
	db 08H				;08BF
	db 0CDH				;08C0
	db 0FH				;08C1
	db 16H				;08C2
	db 0CDH				;08C3
	db 0A3H				;08C4
	db 0EH				;08C5
	db 2AH				;08C6
	db 53H				;08C7
	db 02H				;08C8
	db 3AH				;08C9
	db 27H				;08CA
	db 00H				;08CB
	db 86H				;08CC
	db 0FEH				;08CD
D08CE:	db 48H				;08CE
	db 0D4H				;08CF
	db 0EDH				;08D0
	db 08H				;08D1
	db 0CDH				;08D2
	db 0E6H				;08D3
	db 0EH				;08D4
	db 3EH				;08D5
	db 20H				;08D6
	db 0DFH				;08D7
	db 0AFH				;08D8
	db 0C4H				;08D9
	db 0E6H				;08DA
	db 0EH				;08DB
	db 0E1H				;08DC
	db 0C3H				;08DD
	db 99H				;08DE
	db 08H				;08DF
ptrchk:	lda terminal_x			;do line pointers exist in pgm?
	ora a
	rz
	jmp L08ED
L08E8:	mvi m,00H
	lxi h,D01D8
L08ED:	mvi a,0DH
	rst 3				;Print CR
	mvi a,0AH			;Line feed
	rst 3				;Print LF
L08F3:	lda terminal_y			;Get null count for timing
L08F6:	dcr a				;Decrement counter
	sta terminal_x			;Store as column position
	rz				;Return when done
	push psw			;Save counter
	xra a				;A = 0 (null character)
	rst 3				;Print null
	pop psw				;Restore counter
	jmp L08F6			;Loop
	db 3AH				;0902
	db 27H				;0903
	db 00H				;0904
	db 0FEH				;0905
D0906:	db 38H				;0906
	db 0D4H				;0907
	db 0EDH				;0908
	db 08H				;0909
	db 0D2H				;090A
	db 35H				;090B
	db 09H				;090C
	db 0D6H				;090D
	db 0EH				;090E
	db 0D2H				;090F
	db 0DH				;0910
	db 09H				;0911
	db 2FH				;0912
	db 0C3H				;0913
	db 2CH				;0914
	db 09H				;0915
	db 0F5H				;0916
	db 0CDH				;0917
	db 30H				;0918
	db 11H				;0919
	db 0CFH				;091A
	db 29H				;091B
	db 2BH				;091C
	db 0F1H				;091D
	db 0D6H				;091E
	db 0A0H				;091F
	db 0E5H				;0920
	db 0CAH				;0921
	db 27H				;0922
	db 09H				;0923
	db 3AH				;0924
	db 27H				;0925
	db 00H				;0926
	db 2FH				;0927
	db 83H				;0928
	db 0D2H				;0929
	db 35H				;092A
	db 09H				;092B
	db 3CH				;092C
	db 47H				;092D
	db 3EH				;092E
	db 20H				;092F
	db 0DFH				;0930
	db 05H				;0931
	db 0C2H				;0932
	db 30H				;0933
	db 09H				;0934
	db 0E1H				;0935
	db 0D7H				;0936
	db 0C3H				;0937
	db 9EH				;0938
	db 08H				;0939
D093A:	db 3FH				;093A
	db 52H				;093B
	db 45H				;093C
	db 44H				;093D
	db 4FH				;093E
	db 20H				;093F
	db 46H				;0940
	db 52H				;0941
	db 4FH				;0942
	db 4DH				;0943
	db 20H				;0944
	db 53H				;0945
	db 54H				;0946
	db 41H				;0947
	db 52H				;0948
	db 54H				;0949
	db 0DH				;094A
	db 0AH				;094B
	db 00H				;094C
;
;here when the data that was typed in or in "DATA" statements
;is improperly formatted. for "INPUT" we start again.
;for "READ" we give a syntax error at the data line
;
;
;here when the data that was typed in or in "DATA" statements
;is improperly formatted. for "INPUT" we start again.
;for "READ" we give a syntax error at the data line
;
trmnok:	lda D0242			;was it read or input?
	ora a				;zero=input
	jnz datsne			;give error at data line
	pop b				;get rid of the pointer into the variable list
	lxi h,D093A
	call finex			;print "?REDO FROM START"
	jmp finnow
L095E:	cpi 22H
	db 3EH				;0960
	db 00H				;0961
	db 32H				;0962
	db 0D1H				;0963
	db 01H				;0964
	db 0C2H				;0965
	db 72H				;0966
	db 09H				;0967
	db 0CDH				;0968
	db 0A4H				;0969
	db 0EH				;096A
	db 0CFH				;096B
	db 3BH				;096C
	db 0E5H				;096D
	db 0CDH				;096E
	db 0E6H				;096F
	db 0EH				;0970
	db 3EH				;0971
	db 0E5H				;0972
	db 0CDH				;0973
	db 52H				;0974
	db 0EH				;0975
	db 0CDH				;0976
	db 0EFH				;0977
	db 03H				;0978
	db 0C1H				;0979
	db 0DAH				;097A
	db 86H				;097B
	db 06H				;097C
	db 23H				;097D
	db 7EH				;097E
	db 0B7H				;097F
	db 2BH				;0980
	db 0C5H				;0981
	db 0CAH				;0982
	db 0F9H				;0983
	db 07H				;0984
	db 0C3H				;0985
	db 8DH				;0986
	db 09H				;0987
FMul:	push h
	lhld D0251
	ori 0AFH
	sta D0242
	xthl
	lxi b,2CCFH
	call 0C44H
	xthl
	push d
	mov a,m
	cpi 2CH
	jz autstr
	lda D0242
	ora a
	jnz L0A18
	mvi a,3FH
	rst 3
	call L03EF
	pop d
	pop b
	jc 0686H
	inx h
	mov a,m
	ora a
	dcx h
	push b
	jz 07F9H
	push d
autstr:	lda D0224
	ora a
	jz L09DB
	rst 2
	mov d,a
	mov b,a
	cpi 22H
	jz intid2
	mvi d,3AH
	mvi b,2CH
	dcx h
intid2:	call L0EA7
	xchg				;[d,e]=text pointer
	lxi h,L09E4			;return loc
	xthl				;[h,l]=place to store variable value
	push d				;text pointer goes on
	jmp L082A			;do assignment
L09DB:	rst 2
	call L1565
	xthl
	call L14B8
	pop h
L09E4:	dcx h
	rst 2
	jz L09EE
	cpi 2CH
	jnz trmnok
L09EE:	xthl
	dcx h
	rst 2
	jnz 0993H
	pop d				;pop off the pointer into data
	lda D0242			;fetch the statement type flag
	ora a
	xchg
	jnz resfin			;update datptr
	push d				;save the text pointer
	ora m
	lxi h,D0A07
	cnz finex
	pop h
	ret
D0A07:	db 3FH				;0A07
	db 45H				;0A08
	db 58H				;0A09
	db 54H				;0A0A
	db 52H				;0A0B
	db 41H				;0A0C
	db 20H				;0A0D
	db 49H				;0A0E
	db 47H				;0A0F
	db 4EH				;0A10
	db 4FH				;0A11
	db 52H				;0A12
	db 45H				;0A13
	db 44H				;0A14
	db 0DH				;0A15
	db 0AH				;0A16
	db 00H				;0A17
L0A18:	call Restore
	ora a
	jnz L0A31
	inx h
	mov a,m
	inx h
	ora m
	mvi e,06H
	jz Error			;If both zero, end of program
	inx h				;Point to line number
	mov e,m				;Get line number low byte
	inx h
	mov d,m				;Get line number high byte
	xchg				;HL = line number
	shld D023E			;Store current line number
	xchg				;HL = program pointer
L0A31:	rst 2				;Get first character of statement
	cpi 83H
	jnz L0A18
	jmp autstr
;Fall into FNegate
;-----------------------------------------------------------------------------
;FNegate - Negate FACCUM (flip sign bit)
;-----------------------------------------------------------------------------
FNegate: lxi d,Start
L0A3D:	cnz 0C44H
	shld D0243
	call GetFlowPtr
	jnz 02CCH
	sphl				;Set SP to FOR structure
	push d				;Save loop variable address
	mov a,m				;Get direction byte from struct
	inx h				;Point to STEP value
	push psw			;Save direction byte
	push d				;Save var address again
	call L149E			;FACCUM = STEP value
	xthl				;HL = var addr, (SP) = struct ptr
	push h				;Save var address
	call L1212			;FACCUM = var + STEP
	pop h				;HL = var address
	call L14B8			;Store updated var value
	pop h				;HL = struct ptr (now at TO value)
	call lopnto			;BCDE = TO limit
	push h				;Save struct ptr
	call fcomp			;Compare var to limit (-1,0,1)
	pop h				;Restore struct ptr
	pop b				;B = direction byte (1=up, -1=down)
	sub b				;If result=direction, loop done
	call lopnto			;BC=FOR stmt ptr, DE=line number
	jz L0A75			;Jump if loop complete
	xchg				;HL = line number
	shld current_line		;Set current line
	mov l,c				;HL = FOR statement pointer
	mov h,b
	jmp L0608			;Push FOR token and execute
L0A75:	sphl
	lhld D0243
	mov a,m
	cpi 2CH
	jnz L060C
	rst 2
	call L0A3D
L0A83:	call L0A94
L0A86:	ori 37H
L0A88:	lda D0224
	adc a
	rpe
	mvi e,18H
	jmp Error			;Continue after NEXT
L0A92:	rst 1				;Syntax check for '('
	db 28H				;0A93: 28
L0A94:	dcx h				;Back up (will be advanced by NextChar)
	mvi d,00H			;D = current precedence level
L0A97:	push d				;Save precedence
	mvi c,01H			;Need 1 word stack space
	call CheckEnoughVarSpace
	call L0B09			;Evaluate a term (number, var, function)
	shld D0245			;Save program pointer
L0AA3:	lhld D0245			;Restore program pointer
L0AA6:	pop b				;B = previous precedence
	mov a,b
	cpi 78H
	cnc L0A86
	mov a,m
	mvi d,00H
L0AB0:	sui 0ABH
	jc kloop			;Exit loop if not a comparison token
	cpi 03H				;Check if it's one of the 3 comp ops
	jnc kloop			;Exit if not
	cpi 01H				;Compare to '=' offset
	ral				;Rotate carry into bit 0
	xra d				;bring in the old bits
	cmp d				;make sure result is bigger
	mov d,a				;save the mask
	jc SyntaxError			;don'T ALLOW TWO OF THE SAME
	shld D023C			;save character pointer
	rst 2
	jmp L0AB0
kloop:	mov a,d				;get character from buf
	ora a
	jnz L0BC3
	mov a,m
	shld D023C
	sui 0A4H
	rc
	cpi 07H
	rnc
	mov e,a
	lda D0224
	dcr a
	ora e
	mov a,e
	jz strcat
	rlc				;A = index * 2
	add e				;A = index * 3
	mov e,a				;DE = offset
	lxi h,D0195
	dad d				;HL points to table entry
	mov a,b				;A = previous precedence
	mov d,m				;D = this operator's precedence
	cmp d				;Compare precedences
	rnc				;Return if prev >= this (lower precedence)
	inx h				;Point to function address
	call L0A86
L0AF2:	push b
	lxi b,L0AA3
	push b
	mov b,e
	mov c,d
	call pushf
	mov e,b
	mov d,c
	mov c,m				;Load low byte
	inx h
	mov b,m				;Load high byte
	inx h				;Advance HL past the word
	push b				;Push the word onto stack
	lhld D023C
	jmp L0A97
L0B09:	xra a
	sta D0224
	rst 2
	mvi e,24H
	jz Error
	jc L1565
	call L0728
	jnc L0B56
	cpi 0A4H
	jz L0B09
	cpi 2EH
	jz L1565
	cpi 0A5H
	jz L0B45
	cpi 22H
	jz L0EA4
	cpi 0A2H
	jz L0C23
	cpi 9FH
	jz poke
	sui 0AEH
	jnc L0B67
L0B3F:	call L0A92
	rst 1
	dad h
	ret
L0B45:	mvi d,7DH
	call L0A97
	lhld D0245
	push h
	call L1489
L0B51:	call L0A86
	pop h
	ret
L0B56:	call 0C44H
					;variable in [d,e]
					;variable in [d,e]
retvar:	push h				;save the text pointer
	xchg
	shld D0253
	lda D0224
	ora a
	cz L149E
	pop h				;Restore program pointer
	ret
L0B67:	mvi b,00H			;Calculate offset into KW_INLINE_FNS
	rlc				;A = function index * 2
	mov c,a				;BC = offset
	push b				;Save offset
	rst 2				;Get next char
	mov a,c
	cpi 29H
	jc L0B8A
	call L0A92
	rst 1
	inr l
	call 0A87H
	xchg				;[d,e]=txtptr
	lhld D0253			;get ptr at string descriptor
	xthl				;get function #
	push h				;put the function # on
	xchg				;[h,l]=txtptr
	call L1131			;[e]=value of formula
	xchg				;text pointer into [d,e]
	xthl				;save int value of second arg
	jmp L0B92			;dispatch to function
L0B8A:	call L0B3F			;check out the argument
	xthl				;[h,l]=function # and save text pointer
	lxi d,L0B51
	push d
L0B92:	lxi b,stmt_dispatch		;function dispatch table
	dad b				;add on the offset
	mov c,m				;faster than pushm
	inx h
	mov h,m
	mov l,c
	pchl				;go perform the function
	db 0F6H				;0B9B
	db 0AFH				;0B9C
	db 0F5H				;0B9D
	db 0CDH				;0B9E
	db 86H				;0B9F
	db 0AH				;0BA0
	db 0CDH				;0BA1
	db 38H				;0BA2
	db 07H				;0BA3
	db 0F1H				;0BA4
	db 0EBH				;0BA5
	db 0C1H				;0BA6
	db 0E3H				;0BA7
	db 0EBH				;0BA8
	db 0CDH				;0BA9
	db 0A1H				;0BAA
	db 14H				;0BAB
	db 0F5H				;0BAC
	db 0CDH				;0BAD
	db 38H				;0BAE
	db 07H				;0BAF
	db 0F1H				;0BB0
	db 0C1H				;0BB1
	db 79H				;0BB2
	db 21H				;0BB3
	db 0E4H				;0BB4
	db 0DH				;0BB5
	db 0C2H				;0BB6
	db 0BEH				;0BB7
	db 0BH				;0BB8
	db 0A3H				;0BB9
	db 4FH				;0BBA
	db 78H				;0BBB
	db 0A2H				;0BBC
	db 0E9H				;0BBD
	db 0B3H				;0BBE
	db 4FH				;0BBF
	db 78H				;0BC0
	db 0B2H				;0BC1
	db 0E9H				;0BC2
L0BC3:	lxi h,D0BD5
	lda D0224
	rar
	mov a,d
	ral
	mov e,a
	mvi d,64H
	mov a,b
	cmp d
	rnc
	jmp L0AF2
D0BD5:	db 0D7H				;0BD5
	db 0BH				;0BD6
	db 79H				;0BD7
	db 0B7H				;0BD8
	db 1FH				;0BD9
	db 0C1H				;0BDA
	db 0D1H				;0BDB
	db 0F5H				;0BDC
	db 0CDH				;0BDD
	db 88H				;0BDE
	db 0AH				;0BDF
	db 21H				;0BE0
	db 19H				;0BE1
	db 0CH				;0BE2
	db 0E5H				;0BE3
	db 0CAH				;0BE4
	db 0DBH				;0BE5
	db 14H				;0BE6
	db 0AFH				;0BE7
	db 32H				;0BE8
	db 24H				;0BE9
	db 02H				;0BEA
	db 0D5H				;0BEB
	db 0CDH				;0BEC
	db 16H				;0BED
	db 10H				;0BEE
	db 7EH				;0BEF
	db 23H				;0BF0
	db 23H				;0BF1
	db 4EH				;0BF2
	db 23H				;0BF3
	db 46H				;0BF4
	db 0D1H				;0BF5
	db 0C5H				;0BF6
	db 0F5H				;0BF7
	db 0CDH				;0BF8
	db 1AH				;0BF9
	db 10H				;0BFA
	db 0CDH				;0BFB
	db 0AFH				;0BFC
	db 14H				;0BFD
	db 0F1H				;0BFE
	db 57H				;0BFF
	db 0E1H				;0C00
	db 7BH				;0C01
	db 0B2H				;0C02
	db 0C8H				;0C03
	db 7AH				;0C04
	db 0D6H				;0C05
	db 01H				;0C06
	db 0D8H				;0C07
	db 0AFH				;0C08
	db 0BBH				;0C09
	db 3CH				;0C0A
	db 0D0H				;0C0B
	db 15H				;0C0C
	db 1DH				;0C0D
	db 0AH				;0C0E
	db 0BEH				;0C0F
	db 23H				;0C10
	db 03H				;0C11
	db 0CAH				;0C12
	db 01H				;0C13
	db 0CH				;0C14
	db 3FH				;0C15
	db 0C3H				;0C16
	db 6FH				;0C17
	db 14H				;0C18
	db 3CH				;0C19
	db 8FH				;0C1A
	db 0C1H				;0C1B
	db 0A0H				;0C1C
	db 0C6H				;0C1D
	db 0FFH				;0C1E
	db 9FH				;0C1F
	db 0C3H				;0C20
	db 74H				;0C21
	db 14H				;0C22
L0C23:	mvi d,5AH
	call L0A97
	call L0A86
	call L0738
	mov a,e
	cma
	mov c,a
	mov a,d
	cma
	call L0DE4
	pop b
	jmp L0AA3
D0C3A:	db 2BH				;0C3A
	db 0D7H				;0C3B
	db 0C8H				;0C3C
	db 0CFH				;0C3D
	db 2CH				;0C3E
;-----------------------------------------------------------------------------
;SQR - Square Root (Optional Function #1)
;Uses Newton's method: x[n+1] = (x[n] + N/x[n]) / 2
;Iterates 4 times for convergence
;-----------------------------------------------------------------------------
Sqr:	lxi b,D0C3A
	push b
	ori 0AFH
	sta D0223			;Store DIM/EVAL flag
	mov b,m				;B = first char of variable name
ptrgt2:	call L0728			;check for letter
	jc SyntaxError			;Error if not alpha
	xra a				;Clear A
	mov c,a				;C = 0 (default second char)
	sta D0224
	rst 2
	jc L0C5E
	call L0728
	jc L0C69
L0C5E:	mov c,a
L0C5F:	rst 2
	jc L0C5F
	call L0728
	jnc L0C5F
L0C69:	sui 24H
	jnz L0C76
	inr a
	sta D0224
	rrc
	add c
	mov c,a
	rst 2
L0C76:	lda D0240
	dcr a
	jz cat
	jp finprt
	db 7EH				;0C80
	db 0D6H				;0C81
	db 28H				;0C82
	db 0CAH				;0C83
	db 0E7H				;0C84
	db 0CH				;0C85
finprt:	xra a
	sta D0240
	push h				;Save program pointer
	lhld D024D			;DE = end of simple variables
	xchg
	lhld D024B			;HL = start of simple variables
L0C92:	rst 4				;CompareHLDE - at end of variables?
	jz smkvar			;Not found, allocate new variable
	mov a,c				;Compare second char of name
	sub m				;With stored variable name
	inx h
	jnz L0C9E			;No match on second char
	mov a,b				;Compare first char
	sub m
L0C9E:	inx h
	jz mulret			;Names match - variable found
	inx h				;Skip over 4-byte value
	inx h
	inx h
	inx h
	jmp L0C92			;Try next variable
smkvar:	pop h				;[h,l]= text pointer
	xthl				;(SP) = prog ptr, HL = return address
	push d				;Save DE
	lxi d,retvar			;Address inside EvalVarTerm
	rst 4				;Compare return address
	pop d				;Restore DE
	jz L0CDC			;If from evaluator, don't allocate
	xthl				;(SP) = ret addr, HL = prog ptr
	push h				;Prog ptr back on stack
	push b				;Save variable name BC
	lxi b,D0006
	lhld D024F			;Get current top
	push h				;Save old top
	dad b				;HL = new top
	pop b				;BC = old top
	push h				;Save new top
	call CopyMemoryUp		;Move array block up 6 bytes
	pop h
	shld D024F			;Update VAR_TOP
	mov h,b				;HL = old VAR_TOP (where arrays were)
	mov l,c
	shld D024D			;Update VAR_ARRAY_BASE
L0CCD:	dcx h
	mvi m,00H
	rst 4				;CompareHLDE - done?
	jnz L0CCD
	pop d				;DE = variable name (BC was pushed)
	mov m,e				;Store second char of name
	inx h
	mov m,d				;Store first char of name
	inx h
mulret:	xchg				;return the result in [d,e]
	pop h				;HL = program pointer
	ret
L0CDC:	sta D0256			;A=0 from compare, zero the exponent
	lxi h,D0270
	shld D0253
	pop h
	ret
	db 0E5H				;0CE7
	db 2AH				;0CE8
	db 23H				;0CE9
	db 02H				;0CEA
	db 0E3H				;0CEB
	db 57H				;0CEC
	db 0D5H				;0CED
	db 0C5H				;0CEE
	db 0CDH				;0CEF
	db 30H				;0CF0
	db 07H				;0CF1
	db 0C1H				;0CF2
	db 0F1H				;0CF3
	db 0EBH				;0CF4
	db 0E3H				;0CF5
	db 0E5H				;0CF6
	db 0EBH				;0CF7
	db 3CH				;0CF8
	db 57H				;0CF9
	db 7EH				;0CFA
	db 0FEH				;0CFB
	db 2CH				;0CFC
	db 0CAH				;0CFD
	db 0EDH				;0CFE
	db 0CH				;0CFF
	db 0CFH				;0D00
	db 29H				;0D01
	db 22H				;0D02
	db 45H				;0D03
	db 02H				;0D04
	db 0E1H				;0D05
	db 22H				;0D06
	db 23H				;0D07
	db 02H				;0D08
	db 1EH				;0D09
	db 00H				;0D0A
	db 0D5H				;0D0B
	db 11H				;0D0C
;
;the following routine concatenates two strings
;the faclo contains the first one at this point,
;[h,l] points beyond the + sign after it
;
;
;the following routine concatenates two strings
;the faclo contains the first one at this point,
;[h,l] points beyond the + sign after it
;
cat:	push h				;put old precedence back on
	push psw
	lhld D024D
	mvi a,19H
	xchg
	lhld D024F
	xchg
	rst 4
	jz L0D41
	mov a,m
	cmp c
	inx h
	jnz L0D25
	mov a,m
	cmp b
L0D25:	inx h
	mov e,m				;pick up the length
	inx h
	mov d,m
	inx h
	jnz 0D13H
	lda D0223
	ora a
	jnz 02CFH
	pop psw
	jz L06DD
	sub m
	jz getdef
L0D3C:	mvi e,10H
	jmp Error
L0D41:	lxi d,fn_ptrs
	pop psw				;[a]=number of dimensions
	jz StmtDATA			;called by chain, just return non-zero
	mov m,c				;put down the descriptor
	inx h
	mov m,b
	inx h
	mov c,a				;[c]=number of two byte entries needed
	call CheckEnoughVarSpace	;get space for dimension entries
	inx h				;skip over the size locations
	inx h
	shld D023C			;save the location to put the size
	mov m,c				;store the number of dimensions
	inx h
	lda D0223			;called by dimension?
	ral				;set carry if so
	mov a,c				;[a]=number of dimensions
L0D5C:	lxi b,L000B
	jnc L0D64
	pop b
	inx b
L0D64:	mov m,c
	inx h
	mov m,b
	inx h
	push psw
	push h
	call L154A
	xchg
	pop h
	pop psw				;get the number of dimensions and
	dcr a				;decrement the number of dimensions left
	jnz L0D5C			;handle the other indices
	push psw			;save dimflg (carry)
	mov b,d				;[b,c]=size
	mov c,e
	xchg				;[d,e]=start of values
	dad d				;[h,l]=end of values
	jc L0D3C			;out of memory pointer being generated?
	call 02AFH
	shld D024F
L0D82:	dcx h
	mvi m,00H
	rst 4
	jnz L0D82			;no, zero more
	inx b				;add one to the size to include
	mov d,a				;[d]=zero
	lhld D023C			;get a pointer at the number of dimensions
	mov e,m				;[e]=number of dimensions
	xchg				;[h,l]=number of dimensions
	dad h				;[h,l]=number of dimensions times two
	dad b				;add on the size
	xchg				;[d,e]=total size
	dcx h				;back up to point to location to put
	dcx h				;the size of the array in bytes in.
	mov m,e				;put down the size
	inx h
	mov m,d
	inx h
	pop psw				;get back dimflg (carry) and set [a]=0
	jc L0DBF
;
;at this point [h,l] points beyond the size to the number of dimensions
;strategy:
;	numdim=number of dimensions
;	curtol=0
;inlpnm:get a new indice
;	pop new max into curmax
;	make sure indice is not too big
;	mutliply curtol by curmax
;	add indice to curtol
;	numdim=numdim-1
;	jnz	inlpnm
;	use curtol*4 (valtyp for extended) as offset
;
getdef:	mov b,a				;[b,c]=curtol=zero
	mov c,a
	mov a,m				;[a]=number of dimensions
	inx h
	mvi d,0E1H
	mov e,m				;[d,e]=maximum for the current indice
	inx h
	mov d,m
	inx h
	xthl				;[h,l]=current indice
	push psw			;save the number of dimensions
	rst 4
	jnc L0D3C
	push h
	call L154A
	pop d
	dad d				;add the indice to curtol
	pop psw				;get the number of dimensions in [a]
	dcr a				;see if all the indices have been processed
	mov b,h				;[b,c]=curtol in case we loop back
	mov c,l
	jnz 0DA2H
	dad h
	dad h
	pop b				;pop off the address of where the values
	dad b				;add it onto curtol to get the
	xchg				;return the pointer in [d,e]
L0DBF:	lhld D0245			;reget the text pointer
	ret
StmtINPUT: lhld D024F
	xchg
	lxi h,Start
	dad sp
	lda D0224			;must see if arg is zero
	ora a
	jz L0DDF			;return zero
	call L1016			;add exponents and take care of signs
	call L0F22			;zero fac and put fac in fbuffr
	lhld stack_top
	xchg
	lhld D023A
L0DDF:	mov a,l
	sub e
	mov c,a
	mov a,h
	sbb d
L0DE4:	mov b,c
L0DE5:	mov d,b
	mvi e,00H
	lxi h,D0224
	mov m,e
	mvi b,90H
	jmp L1479
StmtREAD: lda terminal_x
L0DF4:	mov b,a
	xra a
	jmp L0DE5
L0DF9:	call L0E60
	db 0CDH				;0DFC
	db 52H				;0DFD
	db 0EH				;0DFE
	db 01H				;0DFF
	db 0FAH				;0E00
	db 07H				;0E01
	db 0C5H				;0E02
	db 0D5H				;0E03
	db 0CFH				;0E04
	db 28H				;0E05
	db 0CDH				;0E06
	db 44H				;0E07
	db 0CH				;0E08
	db 0CDH				;0E09
	db 86H				;0E0A
	db 0AH				;0E0B
	db 0CFH				;0E0C
	db 29H				;0E0D
	db 0CFH				;0E0E
	db 0ACH				;0E0F
	db 44H				;0E10
	db 4DH				;0E11
	db 0E3H				;0E12
	db 0C3H				;0E13
	db 4CH				;0E14
	db 0EH				;0E15
poke:	call L0E60			;evaluate address, get integer in [d,e]
	push d				;save it
	call L0B3F
	call L0A86			;get formula arg 2
	xthl
	mov e,m
	inx h
	mov d,m
	inx h
	mov a,m				;into [h,l] for comparison with
	inx h				;the line # being searched for
	mov h,m				;which is in [d,e]
	mov l,a
	mov c,m				;push its 4 lo bytes on the stack
	inx h
	mov b,m
	inx h
	push b
	mov c,m
	inx h
	mov b,m
	push b				;user-defined functions require that the
	dcx h
	dcx h
	dcx h
	push h
	rst 4
	push d
	mvi e,22H
L0E3A:	jz Error
	call L14B8
	pop h
	call L0A83
	dcx h
	rst 2
	jnz SyntaxError
	pop h
	pop d
	pop b
	mov m,c
	inx h
	mov m,b
	jmp putdei
	db 0E5H				;0E52
	db 2AH				;0E53
	db 0D4H				;0E54
	db 01H				;0E55
	db 23H				;0E56
	db 7CH				;0E57
	db 0B5H				;0E58
	db 0E1H				;0E59
	db 0C0H				;0E5A
	db 1EH				;0E5B
	db 16H				;0E5C
	db 0C3H				;0E5D
	db 0D1H				;0E5E
	db 02H				;0E5F
L0E60:	rst 1
	sbb a
	mvi a,80H
	sta D0240
	ora m
	mov b,a
	call ptrgt2			;pack it into the fac
	jmp L0A86			;get flags off stack and we are done
StmtLIST: call L0A86			;force the fac to be sng or dbl
	call L160F			;multiply the fac by 10
	call L0EA3			;save the fac in arg
	call L1016			;free up the temp
	lxi b,L106D
	push b				;set up answer in new temp
frcinc:	mov a,m				;get low byte of constant
	inx h				;move up to the pointer
	inx h				;move up to the pointer
	push h				;get pointer to pointer of arg
	call L0EFA			;get the space
	pop h				;find out where string to copy
	mov c,m
	inx h
	mov b,m
	call L0E97			;setup dsctmp
	push h				;save pointer to dsctmp
	mov l,a				;get character count into [l]
	call L1009			;move the chars in
	pop d				;restore pointer to dsctmp
	ret				;return
L0E94:	call L0EFA			;get some string space ([a] chars)
L0E97:	lxi h,D0236			;get desc. temp
	push h				;save desc. pointer
	mov m,a				;save character count
	inx h				;store [d,e]=pointer to free space
putdei:	inx h				;store [d,e]=pointer to free space
	mov m,e
	inx h
	mov m,d
	pop h				;and restore [h,l] as the descriptor pointer
	ret
L0EA3:	dcx h
L0EA4:	mvi b,22H
	mov d,b
L0EA7:	push h
	mvi c,0FFH
strget:	inx h
	mov a,m				;get char
	inr c				;bump character count
	ora a				;if 0, (end of line) done
	jz L0EB9			;test
	cmp d
	jz L0EB9
	cmp b				;closing quote
	jnz strget			;no, go back for more
L0EB9:	cpi 22H
	cz L064E
	xthl
	inx h
	xchg				;get pointer to temp
	mov a,c				;get character count in a
	call L0E97			;save str info
L0EC5:	lxi d,D0236			;[d,e] point at result descriptor
	lhld D0228
	shld D0253
	mvi a,01H
	sta D0224
	call L14BB
	rst 4
	shld D0228
	pop h
	mov a,m
	rnz
	mvi e,1EH
	jmp Error
D0EE2:	db 23H				;0EE2
finex:	call L0EA3			;force the fac to be sng or dbl
	call L1016
	call lopnto
	inr e
					;to check for null string
					;to check for null string
strpr2:	dcr e				;decrement the length
	rz
	ldax b
	rst 3
	cpi 0DH
	cz L08F3
	inx b
	jmp strpr2
L0EFA:	ora a
	mvi c,0F1H
	push psw			;save it back
	lhld stack_top
	xchg				;in [d,e]
	lhld D023A			;get top of free space in [h,l]
	cma				;-# of chars
	mov c,a				;in [b,c]
	mvi b,0FFH
	dad b
	inx h
	rst 4
	jc L0F16			;not enough room for string, offal time
	shld D023A			;save new bottom of memory
	inx h				;move back to point to string
	xchg				;return with pointer in [d,e]
L0F14:	pop psw				;get character count
	ret				;return from getspa
L0F16:	pop psw				;have we collected before?
	mvi e,1AH
	jz Error
	cmp a
	push psw
	lxi b,0EFCH
	push b
L0F22:	lhld D0226
L0F25:	shld D023A
	lxi h,Start
	push h				;say didnt see vars this pass
	lhld stack_top			;force dvars to ignore strings
	push h				;force find high address
	lxi h,D022A			;get start of string temps
lingt3:	xchg				;save text ptr in [d,e]
	lhld D0228			;see if done
	xchg				;flip
	rst 4
	lxi b,lingt3
	jnz L0F7F
	lhld D024B
L0F42:	xchg				;save text ptr in [d,e]
	lhld D024D
	xchg
	rst 4
	jz L0F56
	mov a,m
	inx h
	inx h
	ora a
	call L0F82
	jmp L0F42
L0F55:	pop b				;get rid of stack garbage
L0F56:	xchg				;save text ptr in [d,e]
	lhld D024F			;get end of arrays
	xchg				;flip back
	rst 4
	jz grbpas
	call lopnto
	mov a,e
	push h
	dad b
	ora a
	jp L0F55
	db 22H				;0F69
	db 3CH				;0F6A
	db 02H				;0F6B
	db 0E1H				;0F6C
	db 4EH				;0F6D
	db 06H				;0F6E
	db 00H				;0F6F
	db 09H				;0F70
	db 09H				;0F71
	db 23H				;0F72
	db 0EBH				;0F73
	db 2AH				;0F74
	db 3CH				;0F75
	db 02H				;0F76
	db 0EBH				;0F77
	db 0E7H				;0F78
	db 0CAH				;0F79
	db 56H				;0F7A
	db 0FH				;0F7B
	db 01H				;0F7C
	db 73H				;0F7D
	db 0FH				;0F7E
L0F7F:	push b
	ori 80H
L0F82:	mov a,m				;get low byte of constant
	inx h				;skip chain pointer
	inx h
	mov e,m				;pick up the length
	inx h
	mov d,m
	inx h
	rp
	ora a
	rz
	mov b,h
	mov c,l
	lhld D023A
	rst 4
	mov h,b				;move [b,c] back to [h,l]
	mov l,c
	rc				;if not, no need to mess with it furthur
	pop h				;get return address off stack
	xthl				;get max seen so far & save return address
	rst 4
	xthl				;save max seen & get return address off stack
	push h				;save return address back
	mov h,b				;move [b,c] back to [h,l]
	mov l,c
	rnc				;if not, lets look at next var
	pop b				;get return addr off stack
	pop psw				;pop off max seen
	pop psw				;and variable pointer
	push h				;save new variable pointer
	push d				;and new max pointer
	push b				;save return address back
	ret				;and return
;
;here when made one complete pass thru string vars
;
;
;here when made one complete pass thru string vars
;
grbpas:	pop d				;pop off max pointer
	pop h				;and get variable pointer
	mov a,l
	ora h
	rz				;if end of collection,
	dcx h				;currently just past the descriptor
	mov b,m				;[b]=high byte of data pointer
	dcx h
	mov c,m				;[b,c]=pointer at string data
	push h				;save this location so the pointer
	dcx h
	dcx h
	mov l,m
	mvi h,00H
	dad b				;[h,l]=pointer beyond string
	mov d,b
	mov e,c				;[d,e]=original pointer
	dcx h				;don'T MOVE ONE BEYOND STRING
	mov b,h				;get top of string in [b,c]
	mov c,l
	lhld D023A			;get top of free space
	call bltuc			;move string
	pop h				;get back pointer to desc.
	mov m,c				;save fixed addr
	inx h				;move pointer
	mov m,b				;high part
	mov l,c
	mov h,b
	dcx h
	jmp L0F25
;
;the following routine concatenates two strings
;the faclo contains the first one at this point,
;[h,l] points beyond the + sign after it
;
strcat:	push b				;put old precedence back on
	push h				;save text pointer
	lhld D0253			;get pointer to string desc.
	xthl				;save on stack & get text pointer back
	call L0B09			;evaluate rest of formula
	xthl				;save text pointer, get back desc.
	call 0A87H
	mov a,m
	push h				;save desc. pointer.
	lhld D0253			;get pointer to 2nd desc.
L0FDB:	push h				;save it
	add m				;add two lengths together
	mvi e,1CH
	jc Error			;error "LONG STRING"
	call L0E94			;get initial string
	pop d				;get 2nd desc.
	call fretmp
	xthl				;save pointer to it
	call L1019			;free up 1st temp
	push h				;save desc. pointer (first)
	lhld D0238
	xchg				;in [d,e]
	call movins			;move in the first string
	call movins			;and the second
	lxi h,L0AA6			;cat reenters formula evaluation at tstop
	xthl
	push h				;text pointer off first
	jmp L0EC5			;then return address of tstop
movins:	pop h				;get return addr
	xthl				;put back, but get desc.
	mov a,m				;[a]=string length
	inx h
	inx h
	mov c,m				;[b,c]=pointer at string data
	inx h
	mov b,m
	mov l,a				;[l]=string length
L1009:	inr l
movlp:	dcr l				;set cc'S
	rz				;0, no byte to move
	ldax b				;get char
	stax d				;save it
	inx b				;move pointers
	inx d
	jmp movlp			;keep doing it
L1013:	call 0A87H
L1016:	lhld D0253
L1019:	xchg				;free up the temp in the faclo
fretmp:	call fretms			;free up the temporary
	xchg				;put the string pointer into [h,l]
	rnz
	push d				;save [d,e] to return in [h,l]
	mov d,b				;[d,e]=pointer at string
	mov e,c
	dcx d				;subtract one
	mov c,m				;[c]=length of the string freed up
	lhld D023A			;see if its the first
	rst 4
	jnz L1030			;no so don'T ADD
	mov b,a				;make [b]=0
	dad b				;add
	shld D023A			;and update fretop
L1030:	pop h				;get pointer at current descriptor
	ret
fretms:	lhld D0228			;get temp pointer
	dcx h				;look at what is in the last temp
	mov b,m				;[b,c]=pointer at string
	dcx h				;decrement temppt by strsiz
	mov c,m
	dcx h
	dcx h
	rst 4
	rnz
	shld D0228
	ret
StmtNEW: lxi b,L0DF4			;call sngflt when done
	push b				;like so
len1:	call L1013			;free up temp pointed to by faclo
	xra a				;force numeric flag
	mov d,a				;set high of [d,e] to zero for val
	sta D0224
	mov a,m
	ora a				;set condition codes on length
	ret				;return
StmtSTOP: lxi b,L0DF4			;where to go when done
	push b				;save return addr on stack
asc2:	call len1			;set up original str
	jz StmtDATA			;null str, bad arg.
	inx h				;bump pointer
	inx h				;bump pointer
	mov e,m				;[d,e]=pointer at string data
	inx h
	mov d,m
	ldax d				;[a]=first character
	ret
StmtOUT: mvi a,01H
	call L0E94
	call clrhlp
	lhld D0238
	mov m,e
L106D:	pop b
	jmp L0EC5
StmtON:	call L10ED
	xra a
L1075:	xthl
	mov c,a
					;the extra pop in putnew
					;the extra pop in putnew
left2:	push h				;save desc. for  fretmp
	mov a,m
	cmp b
	jc 107FH
	mov a,b
	lxi d,000EH
	push b				;save offset on stack
	call L0EFA			;get space for new string
	pop b				;get back offset
	pop h				;get back desc pointer.
	push h				;but keep on stack
	inx h				;move to string pointer field
	inx h				;move to string pointer field
	mov b,m				;get pointer low
	inx h				;
	mov h,m				;pointer high
	mov l,b				;get low in  l
	mvi b,00H
	dad b				;add  it
	mov b,h				;get offset pointer in [b,c]
	mov c,l
	call L0E97			;save info in dsctmp
	mov l,a				;get#  of chars to  move in l
	call L1009			;move them in
	pop d				;get back desc. pointer
	call fretmp			;free it up.
	jmp L0EC5			;put temp in temp list
StmtNULL: call L10ED
	pop d				;get desc. pointer
	push d				;save back for left
	ldax d				;get present len of str
	sub b				;subtract 2nd parm
	jmp L1075			;continue with left code
StmtWAIT: xchg
	mov a,m
	call pream2
	push b
	mvi e,0FFH
	cpi 29H
	jz L10BD
	rst 1
	inr l
	call L1131
L10BD:	rst 1
	dad h
	pop psw				;get offset back in a
	xthl				;save text pointer, get desc.
	lxi b,left2			;where to return to.
	push b				;goes on stack
	dcr a				;sub one from offset
	cmp m				;pointer past end of str?
	mvi b,00H
	rnc				;yes, just use null str
	mov c,a				;save offset of character pointer
	mov a,m				;get present len of str
	sub c				;subtract index (2nd arg)
	cmp e				;is it truncation
	mov b,a				;get calced length in b
	rc				;if not use partial str
	mov b,e				;use truncated length
	ret				;return to left2
;
;the val function takes a string and turn it into
;a number by interpreting the ascii digits. etc..
;except for the problem that a terminator must be supplied
;by replacing the character beyond the string, val
;is merely a call to floating input (fin).
;
StmtPOKE: call len1			;do setup, set result=real
	jz L1287			;make sure type set up ok in extended
	mov e,a				;get length of str
	inx h				;to handle the fact the if
	inx h				;to handle the fact the if
	mov a,m
	inx h
	mov h,m				;two strings "1" and "2"
	mov l,a				;are stored next to each other
	push h				;and fin is called pointing to
	dad d				;the first twelve will be returned
	mov b,m				;the idea is to store 0 in the
	mov m,d				;string beyond the one val
	xthl				;is being called on
	push b				;the first character of the next string
	mov a,m
	call L1565			;in extended, get all the precision we can
	pop b				;get the modified character of the next
	pop h				;get the pointer to the modified character
	mov m,b				;restore the character
	ret
L10ED:	xchg				;put the text pointer in [h,l]
	rst 1
	dad h
;used by mid$ for parameter checking and setup
;used by mid$ for parameter checking and setup
pream2:	pop b				;get return addr off stack
	pop d
	push b
	mov b,e
	inr b
	dcr b
	rnz
	jmp StmtDATA
StmtDIM: call clrhlp
	sta 1101H
	in 00H
	jmp L0DF4
;
;the function len($) returns the length of the
;string passed as an argument
;
Len:	call L1124
	out 00H
	ret
;
;the following is the asc($) function. it returns an integer
;which is the decimal ascii equivalent
;
Asc:	call L1124
	push psw
	mvi e,00H
	dcx h
	rst 2
	jz L111B
	rst 1
	inr l
	call L1131
L111B:	pop b
L111C:	in 00H
	xra e
	ana b
	jz L111C
	ret
L1124:	call L1131
	sta 111DH
	sta 1109H
	rst 1
	inr l
	mvi b,0D7H
L1131:	call L0A83
;5.21: helper subroutine for CLEAR formula evaluation
;5.21: helper subroutine for CLEAR formula evaluation
clrhlp:	call L0734			;call helper at 22D1
	mov a,d
	ora a
	jnz StmtDATA
	dcx h
	rst 2
	mov a,e
	ret
L1140:	in 06H
	ani 01H
	jnz L1140
	in 07H
	ret
L114A:	call L114D
L114D:	push psw
L114E:	in 06H
	ani 80H
	jnz L114E
	pop psw
	out 07H
	ret
Chr:	mvi b,01H
	cpi 0A6H
	jz L06D0
	call L0A94
	push h
	call asc2
	mvi a,0D3H
	call L114D
	call L114A
	ldax d
	call L114D
	lhld program_base
	xchg
	lhld D024B
L117A:	ldax d
	inx d
	call L114D
	rst 4
	jnz L117A
	pop h
	ret
Left:	cpi 0A6H
	jz L06CE
	sui 96H
	jz 1191H
	xra a
	lxi b,232FH
	push psw
	call L0A94
	call asc2
	ldax d
	mov l,a
	pop psw
	ora a
	mov h,a
	shld D0253
	cz InputLineWithQ
	lhld D0253
	xchg
L11A9:	mvi b,03H
L11AB:	call L1140
	sui 0D3H
	jnz L11A9
	dcr b
	jnz L11AB
	call L1140
	sub e
	jnz L11A9
	lhld program_base
L11C1:	mvi b,03H
L11C3:	call L1140
	mov e,a
	sub m
	ana d
	jnz L11E6
	mov m,e
	call 02AFH
	mov a,m
	ora a
	inx h
	jnz L11C1
	dcr b
	jnz L11C3
	shld D024B
	lxi h,szOK
	call finex
	jmp L0375
L11E6:	lxi h,D11EF
	call finex
	jmp 02F6H
D11EF:	db 4EH				;11EF
	db 4FH				;11F0
	db 20H				;11F1
	db 47H				;11F2
	db 4FH				;11F3
	db 4FH				;11F4
	db 44H				;11F5
	db 0DH				;11F6
	db 0AH				;11F7
	db 00H				;11F8
Right:	call L0738
	ldax d
	jmp L0DF4
Mid:	call L0A83
	call L0738
	push d
	rst 1
	inr l
	call L1131
	pop d
	stax d
	ret
L120F:	lxi h,D16E4
L1212:	call lopnto
	jmp FAdd
L1218:	call lopnto
	lxi h,0D1C1H
L121E:	call L1489			;negate second argument
					;fall into fadd
					;addition	fac:=arg+fac
					;alters a,b,c,d,e,h,l
;*****************************************************************
;if intfsw=1 the format of floating point numbers will be:
;reg b:sign and bits 1-7 of exponent,reg c:bit 8 of exponent
;and bits 2-8 of mantissa,reg d:bits 9-16 of mantissa,
;reg e:bits 17-24 of mantissa, and likewise for the fac format
;furthermore, the exponent for intel will be bias 177 octal
;******************************************************************
;-----------------------------------------------------------------------------
;FAdd - Floating point addition: FACCUM = BCDE + FACCUM
;Entry: LHS in BCDE, RHS in FACCUM
;Exit: Result in FACCUM
;-----------------------------------------------------------------------------
FAdd:	mov a,b				;check if first argument is zero
	ora a				;get exponent
	rz				;it is, result is number in fac
	lda D0256			;get exponent
	ora a				;see if the number is zero
	jz movfr			;it is, answer is in registers
	sub b				;check relative sizes
	jnc L123B			;is fac smaller?
	cma				;yes, negate shift count
	inr a
	xchg				;switch fac and registers, save (de)
	call pushf			;put fac on stack
	xchg				;get (de) back where it belongs
	call movfr			;put registers in the fac
	pop b
	pop d
L123B:	cpi 19H
	rnc
	push psw			;save shift count
	call L14C6			;unpack the numbers
	mov h,a				;save subtraction flag
	pop psw				;get shift count back
	call L12E8			;shift registers right the right amount
	ora h
	lxi h,D0253
	jp fadd3
	db 0CDH				;124E
	db 0C8H				;124F
	db 12H				;1250
	db 0D2H				;1251
	db 0A7H				;1252
	db 12H				;1253
	db 23H				;1254
	db 34H				;1255
	db 0CAH				;1256
	db 0C3H				;1257
	db 12H				;1258
	db 2EH				;1259
	db 01H				;125A
	db 0CDH				;125B
	db 0FEH				;125C
	db 12H				;125D
	db 0C3H				;125E
	db 0A7H				;125F
	db 12H				;1260
					;here to subtract c,d,e,b from ((hl)+0,1,2),0
					;here to subtract c,d,e,b from ((hl)+0,1,2),0
fadd3:	xra a				;subtract numbers, negate underflow byte
	sub b
	mov b,a				;save it
	mov a,m				;subtract low orders
	sbb e
	mov e,a
	inx h				;update pointer to next byte
	mov a,m				;subtract middle orders
	sbb d
	mov d,a
	inx h				;update pointer to high orders
	mov a,m				;subtract high orders
	sbb c
	mov c,a
					;because we want a positive mantissa, check if we have to negate the
					;number
fadflt:	cc negr				;entry from floatr, int: negate number if it
					;was negative, fall into normalize
					;normalize c,d,e,b
					;alters a,b,c,d,e,h,l
					;here we shift the mantissa left until the msb is a one.
					;except in 4k, the idea is to shift left by 8 as many times as
					;possible.
					;was negative, fall into normalize
					;normalize c,d,e,b
					;alters a,b,c,d,e,h,l
					;here we shift the mantissa left until the msb is a one.
					;except in 4k, the idea is to shift left by 8 as many times as
					;possible.
normal:	mov l,b				;put lowest 2 bytes in (hl)
	mov h,e
	xra a				;zero shift count
norm1:	mov b,a				;save shift count
	mov a,c				;do we have 1 byte of zeros
	ora a
	jnz L1294			;no, shift one place at a time
	mov c,d				;yes, shift over 1 byte
	mov d,h
	mov h,l
	mov l,a				;shift in 8 zeros for the low order
	mov a,b				;update shift count
	sui 08H
	cpi 0E0H
	jnz norm1
L1287:	xra a
L1288:	sta D0256
	ret
norm2u:	dcr b				;decrement shift count
	dad h				;rotate (hl) left one, shift in a zero
	mov a,d				;rotate next higher order left one
	ral
	mov d,a
	mov a,c				;rotate high order left one
	adc a				;set condition codes
	mov c,a
L1294:	jp norm2u			;we have more normalization to do
	db 78H				;1297
	db 5CH				;1298
	db 45H				;1299
	db 0B7H				;129A
	db 0CAH				;129B
	db 0A7H				;129C
	db 12H				;129D
	db 21H				;129E
	db 56H				;129F
	db 02H				;12A0
	db 86H				;12A1
	db 77H				;12A2
	db 0D2H				;12A3
	db 87H				;12A4
	db 12H				;12A5
	db 0C8H				;12A6
	db 78H				;12A7
L12A8:	lxi h,D0256			;Point to exponent
	ora a				;If bit 7 of extra byte set
	cm rounda			;Round up the mantissa
	mov b,m				;B = exponent
	inx h
	mov a,m				;A = FTEMP_SIGN
	ani 80H				;Isolate sign bit
	xra c				;Combine with mantissa high bit
	mov c,a				;C = signed high mantissa
	jmp movfr			;Store result
					;subroutne for round:  add one to c,d,e
					;subroutne for round:  add one to c,d,e
rounda:	inr e				;add one to the low order, entry from qint
	rnz
	inr d
	rnz
	inr c
	rnz
	mvi c,80H			;Mantissa overflowed, set to 1.0
	inr m				;Increment exponent
	rnz
L12C3:	mvi e,0AH			;OV error
	jmp Error
					;add (hl)+2,1,0 to c,d,e
					;this code is used by fadd, fout
					;add (hl)+2,1,0 to c,d,e
					;this code is used by fadd, fout
fadda:	mov a,m				;get lowest order
	add e
	mov e,a
	inx h
	mov a,m				;Add middle bytes with carry
	adc d
	mov d,a
	inx h
	mov a,m				;Add high bytes with carry
	adc c
	mov c,a
	ret
					;negate number in c,d,e,b
					;this code is used by fadd, qint
					;alters a,b,c,d,e,l
negr:	lxi h,D0257			;Complement sign
	mov a,m
	cma
	mov m,a
	xra a				;CDEB = 0 - CDEB
	mov l,a
	sub b
	mov b,a
	mov a,l
	sbb e
	mov e,a
	mov a,l
	sbb d
	mov d,a
	mov a,l
	sbb c
	mov c,a
	ret
L12E8:	mvi b,00H
L12EA:	sui 08H
	jc L12F7
	mov b,e
	mov e,d
	mov d,c
	mvi c,00H
	jmp L12EA
L12F7:	adi 09H
	mov l,a
shftr3:	xra a				;clear carry
	dcr l				;are we done shifting?
	rz				;return if we are
	mov a,c				;get ho
	rar				;entry from fadd, shift it right
	mov c,a				;save it
	mov a,d				;shift next byte right
	rar
	mov d,a
	mov a,e				;shift low order right
	rar
	mov e,a
	mov a,b				;shift overflow byte right
	rar
	mov b,a
	jmp shftr3			;see if we are done
D130C:	db 00H				;130C
	db 00H				;130D
	db 00H				;130E
	db 81H				;130F
D1310:	db 03H				;1310
	db 0AAH				;1311
	db 56H				;1312
	db 19H				;1313
	db 80H				;1314
	db 0F1H				;1315
	db 22H				;1316
	db 76H				;1317
	db 80H				;1318
	db 45H				;1319
	db 0AAH				;131A
	db 38H				;131B
	db 82H				;131C
;-----------------------------------------------------------------------------
;FCompare - Convert FACCUM to integer in BCDE for comparison
;Used by INT function and comparisons
;-----------------------------------------------------------------------------
FCompare: rst 5
	jpe StmtDATA
	lxi h,D0256
	mov a,m
	lxi b,8035H
	lxi d,04F3H
	sub b
	push psw
	mov m,b
	push d
	push b
	call FAdd			;see if y is an integer
	pop b
	pop d
	inr b
	call L13B9
	lxi h,D130C
	call L1218
	lxi h,D1310
	call L17AC
	lxi b,8080H
	lxi d,Start
	call FAdd
	pop psw
	call L15E5
L1352:	lxi b,8031H
	lxi d,7218H
	lxi h,0D1C1H
L135B:	rst 5
	rz
	mvi l,00H
	call muldiv
	mov a,c
	sta 1392H
	xchg
	shld 138DH
	lxi b,Start
	mov d,b
	mov e,b
	lxi h,normal
	push h				;on the stack
	lxi h,fmult2			;put fmult2 on the stack twice, so after
	push h				;we multiply by the lo byte, we will
	push h				;multiply by the mo and ho
	lxi h,D0253			;get address of lo of fac
fmult2:	mov a,m				;get byte to multiply by
	inx h				;move pointer to next byte
	ora a
	jz fmult3			;are we multiplying by zero?
	push h				;save pointer
	xchg				;get lo'S IN (HL)
	mvi e,08H
;the product will be formed in c,d,e,b. this will be in c,h,l,b part of the
;time in order to use the "DAD" instruction.  at fmult2, we get the next
;byte of the mantissa in the fac to multiply by.  ((hl) points to it)
;(the fmult2 subroutine preserves (hl))  in 8k, if the byte is zero, we just
;shift the product 8 right.  this byte is then shifted right and saved in d
;(h in 4k).  the carry determines if we should add in the second factor
;if we do, we add it to c,h,l.  b is only used to determine which way we
;round.  we then shift c,h,l,b (c,d,e,b) in 4k right one to get ready for the
;next time through the loop.  note that the carry is shifted into the msb of
;c.  e has a count (l in 4k) to determine when we have looked at all the bits
;of d (h in 4k).
;the product will be formed in c,d,e,b. this will be in c,h,l,b part of the
;time in order to use the "DAD" instruction.  at fmult2, we get the next
;byte of the mantissa in the fac to multiply by.  ((hl) points to it)
;(the fmult2 subroutine preserves (hl))  in 8k, if the byte is zero, we just
;shift the product 8 right.  this byte is then shifted right and saved in d
;(h in 4k).  the carry determines if we should add in the second factor
;if we do, we add it to c,h,l.  b is only used to determine which way we
;round.  we then shift c,h,l,b (c,d,e,b) in 4k right one to get ready for the
;next time through the loop.  note that the carry is shifted into the msb of
;c.  e has a count (l in 4k) to determine when we have looked at all the bits
;of d (h in 4k).
fmult4:	rar				;rotate byte right
	mov d,a				;save it
	mov a,c				;get ho
	jnc fmult5			;don'T ADD IN NUMBER IF BIT WAS ZERO
	push d				;save counters
	lxi d,Start
	dad d
	pop d
	aci 00H
fmult5:	rar				;rotate result right one
	mov c,a
	mov a,h				;rotate next byte
	rar
	mov h,a
	mov a,l				;rotate next lower order
	rar
	mov l,a
	mov a,b				;rotate lo
	rar
	mov b,a
	dcr e				;are we done?
	mov a,d				;get number we are multiplying by
	jnz fmult4			;multiply again if we are not done
	xchg				;get lo'S IN (DE)
	pop h				;get pointer to number to multiply by
	ret				;all done
fmult3:	mov b,e				;multiply by zero: shift everything 8 right
	mov e,d
	mov d,c
	mov c,a				;shift in 8 zeros on the left
	ret				;all done
L13AB:	call pushf			;save number
	lxi b,8420H
	lxi d,Start
	call movfr
L13B7:	pop b
	pop d
L13B9:	rst 5
	jz 02C9H
	mvi l,0FFH
	call muldiv
	inr m
	inr m
	dcx h
	mov a,m
	sta 13E8H
	dcx h
	mov a,m
	sta 13E4H
	dcx h
	mov a,m
	sta 13E0H
	mov b,c				;B = LHS high mantissa byte
	xchg				;HL = LHS low mantissa
	xra a
	mov c,a				;Initialize result mantissa to 0
	mov d,a
	mov e,a
	sta 13EBH
fltget:	push h				;save deposit pointer
	push b
	mov a,l
	sui 00H
	mov l,a
	mov a,h
	sbi 00H
	mov h,a
	mov a,b
	sbi 00H
	mov b,a
	mvi a,00H
	sbi 00H
	cmc
	jnc 13F9H
	sta 13EBH
	pop psw
	pop psw
	stc
	jnc 0E1C1H
	mov a,c
	inr a				;Test if normalized
	dcr a
	rar				;Shift carry into result
	jm L12A8			;Done if normalized (A already set)
	ral				;Undo the shift
	mov a,e				;rotate everything left one
	ral				;rotate next bit of quotient in
	mov e,a
	mov a,d
	ral
	mov d,a
	mov a,c
	ral
	mov c,a
	dad h				;rotate a zero into right end of number
	mov a,b				;the ho byte, finally!
	ral
	mov b,a
	lda 13EBH
	ral
	sta 13EBH
	mov a,c
	ora d
	ora e
	jnz fltget
	push h
L141E:	lxi h,D0256
	dcr m
	pop h
	jnz fltget
	jmp L12C3			;Exponent underflow
muldiv:	mov a,b				;is number in registers zero?
	ora a
	jz L144B			;Exit early if LHS is zero
	mov a,l				;Get add/subtract flag
	lxi h,D0256			;Point to RHS exponent
	xra m				;XOR with RHS exponent (complement for subtract)
	add b				;Add LHS exponent
	mov b,a
	rar				;Move carry to bit 7
	xra b				;Check for overflow
	mov a,b
	jp L144A
	db 0C6H				;143B
	db 80H				;143C
	db 77H				;143D
	db 0CAH				;143E
	db 0A4H				;143F
	db 13H				;1440
	db 0CDH				;1441
	db 0C6H				;1442
	db 14H				;1443
	db 77H				;1444
	db 2BH				;1445
	db 0C9H				;1446
L1447:	rst 5
	cma				;pick overflow if positive
	pop h				;don'T SCREW UP STACK
L144A:	ora a				;is error overflow or undeflow?
L144B:	pop h				;get old return address off stack
	jp L1287
	db 0C3H				;144F
	db 0C3H				;1450
	db 12H				;1451
					;multiply fac by 10
					;alters a,b,c,d,e,h,l
					;multiply fac by 10
					;alters a,b,c,d,e,h,l
mul10:	call L14AC			;get number in registers
	mov a,b
	ora a
	rz
	adi 02H
	jc L12C3			;Check overflow
	mov b,a
	call FAdd			;Add to FACCUM (now FACCUM*5)
	lxi h,D0256			;Multiply by 2 (add 1 to exponent)
	inr m
	rnz
	jmp L12C3
L1469:	lda D0255
	cpi 2FH				;Compare to determine sign
	ral				;Rotate sign into carry
	sbb a				;A = -1 if negative, 0 if positive
	rnz				;Return if non-zero (negative)
	inr a				;Return 1 for positive
	ret
StmtEND: rst 5				;FTestSign
L1474:	mvi b,88H			;Exponent for 8-bit integer
	lxi d,Start
L1479:	lxi h,D0256
	mov c,a
	mov m,b
	mvi b,00H
	inx h
	mvi m,80H			;Set implicit high bit
	ral				;Get sign bit into carry
	jmp fadflt			;Normalize result
StmtNEXT: rst 5				;FTestSign
	rp				;Return if positive or zero
L1489:	lxi h,D0255
	mov a,m
	xri 80H				;Flip sign bit
	mov m,a
	ret
					;put fac on stack
					;alters d,e
					;put fac on stack
					;alters d,e
pushf:	xchg				;save (hl)
	lhld D0253			;Get low 2 bytes
	xthl				;Swap with return address
	push h				;Push return address
	lhld D0255			;get ho'S
	xthl				;switch ho'S AND RET ADDR
	push h				;put ret addr back on stack
	xchg				;get old (hl) back
	ret				;all done
L149E:	call lopnto			;get number in registers
					;fall into movfr and put it in fac
					;move registers (b,c,d,e) to fac
					;alters d,e
					;fall into movfr and put it in fac
					;move registers (b,c,d,e) to fac
					;alters d,e
movfr:	xchg				;get lo'S IN (HL)
	shld D0253			;put them where they belong
	mov h,b				;get ho'S IN (HL)
	mov l,c
	shld D0255			;put ho'S WHERE THEY BELONG
	xchg				;get old (hl) back
	ret				;all done
L14AC:	lxi h,D0253			;get pointer to fac
lopnto:	mov e,m				;get pointer to file data block in [d,e]
	inx h				;point to mo
	mov d,m				;get mo, entry for bill
	inx h				;point to ho
	mov c,m				;get ho
	inx h				;point to exponent
	mov b,m
L14B6:	inx h
	ret
L14B8:	lxi d,D0253
L14BB:	mvi b,04H
move1:	ldax d				;get word, entry from vmovmf
	mov m,a				;put it where it belongs
	inx d				;increment pointers to next word
	inx h
	dcr b
	jnz move1
	ret
L14C6:	lxi h,D0255			;point to ho and sign
	mov a,m				;get ho and sign
	rlc				;duplicate the sign in carry and the lsb
	stc				;restore the hidden one
	rar				;restore the number in a
	mov m,a				;save ho
	cmc				;get the complement of the sign
	rar				;get it in the sign bit
	inx h				;point to temporary sign byte
	inx h
	mov m,a				;save complement of sign
	mov a,c				;get ho and sign of the registers
	rlc				;duplicate the sign in carry and the lsb
	stc				;Set implicit bit
	rar				;Bit 7 = 1, bit 6 = old sign
	mov c,a
	rar				;Get sign for comparison
	xra m				;XOR with RHS sign
	ret				;A positive = same sign, negative = different
					;compare two single precision numbers
					;a=1 if arg .lt. fac
					;a=0 if arg=fac
					;a=-1 if arg .gt. fac
					;dorel depends upon the fact that fcomp returns with carry on
					;iff a has 377
					;alters a,h,l
fcomp:	mov a,b				;see if zero
	ora a
	jz FTestSign			;If zero, result depends on FACCUM sign
	lxi h,146DH
	push h
	rst 5
	mov a,c				;if it is, result is minus the sign of arg
	rz				;it is
	lxi h,D0255			;point to sign of fac
	xra m				;see if the signs are the same
	mov a,c				;if they are different, result is sign of arg
	rm				;they are different
	call fcomp2			;check the rest of the number
	rar				;numbers are different, change sign if
	xra c				;both numbers are negative
	ret				;go set up a
fcomp2:	inx h				;point to exponent
	mov a,b				;get exponent of arg
	cmp m				;compare the two
	rnz				;numbers are different
	dcx h				;point to ho
	mov a,c				;get ho of arg
	cmp m				;compare with ho of fac
	rnz				;they are different
	dcx h				;point to mo of fac
	mov a,d				;get mo of arg
	cmp m
	rnz
	dcx h				;Compare low mantissa
	mov a,e
	sub m
	rnz
	pop h				;Equal - discard return addresses
	pop h
	ret
					;quick greatest integer function
					;leaves int(fac) in c,d,e (signed)
					;assumes fac .lt. 2^23 = 8388608
					;assumes the exponent of fac is in a
					;alters a,b,c,d,e
					;quick greatest integer function
					;leaves int(fac) in c,d,e (signed)
					;assumes fac .lt. 2^23 = 8388608
					;assumes the exponent of fac is in a
					;alters a,b,c,d,e
qint:	mov b,a				;zero b,c,d,e in case the number is zero
	mov c,a
	mov d,a
	mov e,a
	ora a
	rz				;Return if FACCUM is zero
	push h
	call L14AC			;Copy FACCUM to BCDE
	call L14C6			;Unpack mantissa
	xra m				;Get sign relationship
	mov h,a
	cm qinta			;Negate if needed
	mvi a,98H			;24-bit integer exponent
	sub b				;Calculate shift count
	call L12E8			;Shift to integer
	mov a,h
	ral				;Check sign
	cc rounda			;Round up if needed
	mvi b,00H
	cc negr				;Negate if negative
	pop h
	ret
qinta:	dcx d				;subtract one from c,d,e
	mov a,d
	ana e
	inr a
	rnz
	dcx b
	ret
StmtFOR: lxi h,D0256			;Point to exponent
	mov a,m
	cpi 98H				;Check if already integer
	lda D0253
	rnc
	mov a,m
	call qint
	mvi m,98H
	mov a,e				;get lo
	push psw			;save it
	mov a,c				;negate number if it is negative
	ral				;put sign in carry
	call fadflt			;refloat number
	pop psw				;get lo back
	ret				;all done
L154A:	lxi h,Start			;get pointer to fac
	mov a,b
	ora c
	rz
	mvi a,10H
umult1:	dad h				;rotate (hl) left one
	jc L0D3C			;check for overflow, if so,
	xchg				;bad subscript (bs) error
	dad h				;rotate (de) left one
	xchg
	jnc L1560			;add in (bc) if ho was 1
	dad b
	jc L0D3C			;check for overflow
L1560:	dcr a				;see if done
	jnz umult1
	ret
L1565:	cpi 2DH
	push psw
	jz L1571
	cpi 2BH
	jz L1571
	dcx h				;Point to just before number
L1571:	call L1287			;Clear FACCUM
	mov b,a				;B = 0 (fractional digit count)
	mov d,a				;D = 0 (exponent sign)
	mov e,a				;E = 0 (exponent value)
	cma				;A = 0xFF
	mov c,a				;C = 0xFF (no decimal point yet)
L1579:	rst 2				;NextChar - get next character
	jc L15CE			;If digit, process it
	cpi 2EH				;Decimal point?
	jz L15A9			;Yes, mark decimal point seen
	cpi 45H				;'E' for exponent?
	jnz fine			;No, done parsing - scale result
	rst 2				;NextChar - get sign or first digit
	push h
	lxi h,L159D
	xthl
	dcr d
	cpi 0A5H
	rz
	cpi 2DH
	rz
	inr d
	cpi 2BH
	rz
	cpi 0A4H
	rz
	pop psw
	dcx h				;Back up to re-read char
L159D:	rst 2				;NextChar - get exponent digit
	jc L15F0			;If digit, accumulate exponent
	inr d				;D was -1? (negative exponent)
	jnz fine			;No, done with exponent
	xra a
	sub e				;E = -E
	mov e,a
	inr c				;Reset C (was 0xFF)
L15A9:	inr c				;Mark decimal point seen (C = 0)
	jz L1579			;Continue if first decimal point
					;here to finish up the number
					;here to finish up the number
fine:	push h				;save the text pointer
	mov a,e				;A = exponent
	sub b				;A = exponent - fractional digits
L15B0:	cp L15C6			;If positive, multiply by 10
	jp L15BC			;Check if done
	db 0F5H				;15B6
	db 0CDH				;15B7
	db 0ABH				;15B8
	db 13H				;15B9
	db 0F1H				;15BA
	db 3CH				;15BB
L15BC:	jnz L15B0
	pop d
	pop psw
	cz L1489
	xchg
	ret
L15C6:	rz				;Return if A = 0
bufcin:	push psw			;save line #
	call mul10
	pop psw
	dcr a				;Move toward zero
	ret
L15CE:	push d				;Save exponent info
	mov d,a				;D = digit character
	mov a,b				;Update fractional count
	adc c				;Add with carry (C = 0 after decimal)
	mov b,a
	push b				;Save BC
	push h				;Save program pointer
	push d				;Save digit
	call mul10			;FACCUM *= 10
	pop psw				;Get digit back in A
	sui 30H				;Convert ASCII to value
	call L15E5			;Save current FACCUM
	pop h
	pop b
	pop d
	jmp L1579			;get the flags off the stack and we are done
					;tangent function
					;tan(x)=sin(x)/cos(x)
L15E5:	call pushf			;save arg
	call L1474			;convert a to a floating point number
	pop b
	pop d
	jmp FAdd			;add it in
L15F0:	mov a,e				;exponent digit -- multiply exponent by 10
	rlc				;A = E*2
	rlc				;A = E*4
	add e				;A = E*5
	rlc				;A = E*10
	add m				;Add digit character
	sui 30H				;Convert from ASCII
	mov e,a				;Store back
	jmp L159D			;Continue reading exponent
L15FC:	push h
	lxi h,szIn			;" IN " string
	call finex			;Print (HL already at first char)
	pop h
;-----------------------------------------------------------------------------
;PrintInt - Print integer in HL (converts to float and prints)
;The integer occupies the lower 16 bits of mantissa with exponent=24
;-----------------------------------------------------------------------------
PrintInt: xchg				;DE = integer value
	xra a				;C = 0
	mvi b,98H			;B = exponent 24 (2^24)
	call L1479			;Convert to float (skip sign handling)
	lxi h,D0EE2			;Return to PrintString after FOut
	push h
L160F:	lxi h,D0258			;Output buffer
	push h
	rst 5
	mvi m,20H
	jp FOut
	db 36H				;1619
	db 2DH				;161A
					;floating output of fac
					;alters all registers
					;the original contents of the fac is lost
;
;	output the value in the fac according to the format specifications
;	in a,b,c
;	all registers are altered
;	the original contents of the fac is lost
;
;	the format is specified in a, b and c as follows:
;	the bits of a mean the following:
;bit 7	0 means free format output, i.e. the other bits of a must be zero,
;	trailing zeros are suppressed, a number is printed in fixed or floating
;	point notation according to its magnitude, the number is left
;	justified in its field, b and c are ignored.
;	1 means fixed format output, i.e. the other bits of a are checked for
;	formatting information, the number is right justified in its field,
;	trailing zeros are not suppressed.  this is used for print using.
;bit 6	1 means group the digits in the integer part of the number into groups
;	of three and separate the groups by commas
;	0 means don'T PRINT THE NUMBER WITH COMMAS
;bit 5	1 means fill the leading spaces in the field with asterisks ("*")
;bit 4	1 means output the number with a floating dollar sign ("$")
;bit 3	1 means print the sign of a positive number as a plus sign ("+")
;	instead of a space
;bit 2	1 means print the sign of the number after the number
;bit 1	unused
;bit 0	1 means print the number in floating point notation i.e. "E NOTATION"
;	if this bit is on, the comma specification (bit 6) is ignored.
;	0 means print the number in fixed point notation.  numbers .ge. 1e16
;	cannot be printed in fixed point notation.
;
;	b and c tell how big the field is:
;b   =	the number of places in the field to the left of the decimal point
;	(b does not include the decimal point)
;c   =	the number of places in the field to the right of the decimal point
;	(c includes the decimal point)
;	b and c do not include the 4 positions for the exponent if bit 0 is on
;	fout assumes b+c .le. 24 (decimal)
;	if the number is too big to fit in the field, a percent sign ("%") is
;	printed and the field is extended to hold the number.
;&
					;entry to print the fac in free format
FOut:	inx h
	mvi m,30H			;Write '0' (for zero case)
	jz L16D0			;If zero, done (just " 0")
	push h				;Save buffer position
	cm L1489			;Negate if negative
	xra a				;Initialize decimal exponent adjustment = 0
	push psw
	call L16D6			;Ensure FACCUM < 1,000,000
L162A:	lxi b,9143H			;BCDE = 100000.0
	lxi d,4FF8H
	call fcomp
	jpo FIn				;If FACCUM >= 100000, continue
	pop psw				;Get decimal exponent adjustment
	call bufcin			;Multiply by 10, decrement adjustment
	push psw
	jmp L162A
L163E:	call L13AB
	pop psw
	inr a				;Increment decimal exponent
	push psw
	call L16D6			;Check if under 1M again
FIn:	call L120F			;Add 0.5 (ONE_HALF)
	inr a
	call qint			;Convert to integer in CDE
	call movfr			;Store integer back to FACCUM
	lxi b,0306H
	pop psw
	add c
	inr a
	jm L1663
	cpi 08H
	jnc L1663
	inr a
	mov b,a
	mvi a,02H
L1663:	dcr a
	dcr a
	pop h				;HL = output buffer
	push psw			;Save exponent flag
	lxi d,D16E8			;Table of 100000, 10000, 1000...
	dcr b				;Decrement decimal point counter
	jnz L1674
	mvi m,2EH
	inx h
	mvi m,30H
	inx h
L1674:	dcr b				;Decrement decimal point counter
	mvi m,2EH			;Write '.' (may be overwritten)
	cz L14B6			;If B=0, actually keep the '.'
	push b
	push h
	push d
	call L14AC			;Get FACCUM to BCDE
	pop h				;HL points to power of 10 table
	mvi b,2FH			;B = '0' - 1
foucs2:	inr b				;add one to digit
	mov a,e				;Subtract 3-byte power from CDE
	sub m
	mov e,a
	inx h
	mov a,d
	sbb m
	mov d,a
	inx h
	mov a,c
	sbb m
	mov c,a
	dcx h
	dcx h
	jnc foucs2			;Continue until underflow
	call fadda			;Add back (undo last subtraction)
	inx h				;Move to next power
	call movfr			;Store result back
	xchg				;DE = power table ptr
	pop h				;HL = output buffer
	mov m,b				;Store digit
	inx h
	pop b
	dcr c				;More digits?
	jnz L1674			;Yes, continue
	dcr b
	jz L16B4			;Skip if no trailing zeros
L16A8:	dcx h
	mov a,m
	cpi 30H				;'0'?
	jz L16A8			;Strip it
	cpi 2EH				;Decimal point?
	cnz L14B6			;If not '.', keep this char
L16B4:	pop psw				;Get exponent flag
	jz Exp				;If 0, no exponent needed
	mvi m,45H			;'E'
	inx h
	mvi m,2BH			;Assume '+'
	jp L16C4			;If positive exponent
	db 36H				;16C0
	db 2DH				;16C1
	db 2FH				;16C2
	db 3CH				;16C3
L16C4:	mvi b,2FH			;B = '0' - 1
L16C6:	inr b				;Count tens digit
	sui 0AH
	jnc L16C6
	adi 3AH				;A = ones digit + '0'
	inx h
	mov m,b				;Store tens digit
L16D0:	inx h				;store [d,e]=pointer to free space
	mov m,a				;Store ones digit
	inx h
					;the function exp(x) calculates e^x where e=2.718282
					;	the technique used is to employ a couple
					;	of fundamental identities that allows us to
					;	use the base 2 through the difficult portions of
					;	the calculation:
					;
					;		(1)e^x=2^y  where y=x*log2(e) [log2(e) is
					;						log base 2
					;						of e ]
					;
					;		(2) 2^y=2^[ int(y)+(y-int(y)]
					;		(3) if ny=int(y) then
					;		    2^(ny+y-ny)=[2^ny]*[2^(y-ny)]
					;
					;	now, since 2^ny is easy to compute (an exponent
					;	calculation with mantissa bits of zero) the difficult
					;	portion is to compute 2^(y-ny) where 0.le.(y-ny).lt.1
					;	this is accomplished with a polynomial approximation
					;	to 2^z where 0.le.z.lt.1  . once this is computed we
					;	have to effect the multiply by 2^ny .
Exp:	mov m,c				;Null terminator (C=0)
	pop h				;Return buffer pointer
	ret
L16D6:	lxi b,9474H			;BCDE = 1000000.0
	lxi d,23F7H
	call fcomp
	pop h				;Get return address
	jpo L163E			;If >= 1M, divide by 10
	pchl				;Otherwise return normally
D16E4:	db 00H				;16E4
	db 00H				;16E5
	db 00H				;16E6
	db 80H				;16E7
D16E8:	db 0A0H				;16E8
	db 86H				;16E9
	db 01H				;16EA
	db 10H				;16EB
	db 27H				;16EC
	db 00H				;16ED
	db 0E8H				;16EE
	db 03H				;16EF
	db 00H				;16F0
	db 64H				;16F1
	db 00H				;16F2
	db 00H				;16F3
	db 0AH				;16F4
	db 00H				;16F5
	db 00H				;16F6
	db 01H				;16F7
	db 00H				;16F8
	db 00H				;16F9
L16FA:	lxi h,L1489			;get the address of neg
	xthl				;switch ret addr and addr of neg
	pchl				;return, the address of neg is on the stack
Log:	call pushf			;save arg x
	lxi h,D16E4			;get 1/2
	call L149E			;sqr(x)=x^.5
	pop b
	pop d
	rst 5
	mov a,b				;see if x is zero
	jz StmtDEF			;it is, result is one
	jp posexp			;positive exponent
	db 0B7H				;1712
	db 0CAH				;1713
	db 0C9H				;1714
	db 02H				;1715
posexp:	ora a				;is it zero to minus power?
	jz L1288			;give div by zero and continue
	push d
	push b
	mov a,c
	ori 7FH
	call L14AC
	jp fpwr1
	db 0D5H				;1725
	db 0C5H				;1726
	db 0CDH				;1727
	db 31H				;1728
	db 15H				;1729
	db 0C1H				;172A
	db 0D1H				;172B
	db 0F5H				;172C
	db 0CDH				;172D
	db 0DBH				;172E
	db 14H				;172F
	db 0E1H				;1730
	db 7CH				;1731
	db 1FH				;1732
fpwr1:	pop h				;get x back in fac
	shld D0255			;store ho'S
	pop h				;get lo'S OFF STACK
	shld D0253			;store them in fac
	cc L16FA			;negate number at end if y was odd
	cz L1489			;negate the negative number
	push d
	push b
	call FCompare			;compute  exp(y*log(x))
	pop b
	pop d
	call L135B			;log will blow him out of the water
StmtDEF: call pushf
	lxi b,8138H
	lxi d,0AA3BH
	call L135B
	lda D0256
	cpi 88H
	jnc L1447
	call StmtFOR
	adi 80H
	adi 02H
	jc L1447
	push psw
	lxi h,D130C
	call L1212
	call L1352
	pop psw
	pop b
	pop d
	push psw
	call L121E
	call L1489
	lxi h,D178B
	call poly
	lxi d,Start
	pop b
	mov c,d
	jmp L135B
D178B:	db 08H				;178B
	db 40H				;178C
	db 2EH				;178D
	db 94H				;178E
	db 74H				;178F
	db 70H				;1790
	db 4FH				;1791
	db 2EH				;1792
	db 77H				;1793
	db 6EH				;1794
	db 02H				;1795
	db 88H				;1796
	db 7AH				;1797
	db 0E6H				;1798
	db 0A0H				;1799
	db 2AH				;179A
	db 7CH				;179B
	db 50H				;179C
	db 0AAH				;179D
	db 0AAH				;179E
	db 7EH				;179F
	db 0FFH				;17A0
	db 0FFH				;17A1
	db 7FH				;17A2
	db 7FH				;17A3
	db 00H				;17A4
	db 00H				;17A5
	db 80H				;17A6
	db 81H				;17A7
	db 00H				;17A8
	db 00H				;17A9
	db 00H				;17AA
	db 81H				;17AB
L17AC:	call pushf
	lxi d,1359H
	push d				;return we will multiply by x
	push h				;save constant pointer
	call L14AC			;square x
	call L135B
	pop h				;get constant pointer
					;fall into poly
					;polynomial evaluator
					;pointer to degree+1 is in (hl), it is updated
					;the constants follow the degree
					;constants should be stored in reverse order, fac has x
					;we compute:
					;c0+c1*x+c2*x^2+c3*x^3+...+c(n-1)*x^(n-1)+c(n)*x^n
					;fall into poly
					;polynomial evaluator
					;pointer to degree+1 is in (hl), it is updated
					;the constants follow the degree
					;constants should be stored in reverse order, fac has x
					;we compute:
					;c0+c1*x+c2*x^2+c3*x^3+...+c(n-1)*x^(n-1)+c(n)*x^n
poly:	call pushf			;save x
	mov a,m				;get degree
	inx h				;increment pointer to first constant
	call L149E			;move first constant to fac
	mvi b,0F1H
	pop b
	pop d
	dcr a				;are we done?
	rz				;yes, return
	push d
	push b
	push psw			;save degree
	push h				;save constant pointer
	call L135B			;evaluate the poly, multiply by x
	pop h				;get location of constants
	call lopnto			;get constant
	push h				;store location of constants so fadd and fmult
	call FAdd			;will not screw them up, add in constant
	pop h				;move constant pointer to next constant
	jmp 17C4H
StmtGOTO: rst 5
	lxi h,D1845
	jm rndstr
	lxi h,D1866
	call L149E
	lxi h,D1845
	rz
	add m
	ani 07H
	mvi b,00H
	mov m,a
	inx h
	add a
	add a
	mov c,a
	dad b
	call lopnto
	call L135B
	lda D1844
	inr a
	ani 03H
	mvi b,00H
	cpi 01H
	adc b
	sta D1844
	lxi h,D1866
	add a
	add a
	mov c,a
	dad b
	call L1212
rnd1:	call L14AC			;switch ho and lo bytes,
	mov a,e				;get lo
	mov e,c				;put ho in lo byte
	xri 4FH
	mov c,a
	mvi m,80H			;Set FTEMP_SIGN = positive
	dcx h
	mov b,m				;Save exponent
	mvi m,80H			;Set exponent = 0 (value < 1)
	lxi h,D1843
	inr m
	mov a,m
	sui 0ABH
	jnz L1832
	mov m,a				;zero the counter
	inr c
	dcr d
	inr e
L1832:	call normal			;normalize the result
	lxi h,D1866			;save random number generated for next
	jmp L14B8			;time
rndstr:	mov m,a				;zero the counters
	dcx h
	mov m,a
	dcx h
	mov m,a
	jmp rnd1
D1843:	db 00H				;1843
D1844:	db 00H				;1844
D1845:	db 00H				;1845
	db 35H				;1846
	db 4AH				;1847
	db 0CAH				;1848
	db 99H				;1849
	db 39H				;184A
	db 1CH				;184B
	db 76H				;184C
	db 98H				;184D
	db 22H				;184E
	db 95H				;184F
	db 0B3H				;1850
	db 98H				;1851
	db 0AH				;1852
	db 0DDH				;1853
	db 47H				;1854
	db 98H				;1855
	db 53H				;1856
	db 0D1H				;1857
	db 99H				;1858
	db 99H				;1859
	db 0AH				;185A
	db 1AH				;185B
	db 9FH				;185C
	db 98H				;185D
	db 65H				;185E
	db 0BCH				;185F
	db 0CDH				;1860
	db 98H				;1861
	db 0D6H				;1862
	db 77H				;1863
	db 3EH				;1864
	db 98H				;1865
D1866:	db 52H				;1866
	db 0C7H				;1867
	db 4FH				;1868
	db 80H				;1869
	db 68H				;186A
	db 0B1H				;186B
	db 46H				;186C
	db 68H				;186D
	db 99H				;186E
	db 0E9H				;186F
	db 92H				;1870
	db 69H				;1871
	db 10H				;1872
	db 0D1H				;1873
	db 75H				;1874
	db 68H				;1875
;-----------------------------------------------------------------------------
;SIN - Sine Function (Optional Function #3)
;Uses Taylor series approximation after reducing angle to -0.25 to 0.25
;Input: angle in radians in FACCUM
;-----------------------------------------------------------------------------
Sin:	lxi h,D18BC
	call L1212
L187C:	call pushf
	lxi b,8349H
	lxi d,L0FDB
	call movfr			;Load 2*pi
	pop b				;Get x
	pop d
	call L13B9			;u = x / 2pi
	call pushf			;Push u
	call StmtFOR			;INT(u)
	pop b				;Get u
	pop d
	call L121E			;u = u - INT(u), now -1 < u < 1
	lxi h,D18C0
	call L1218
	rst 5
	stc
	jp L18A8
	db 0CDH				;18A3
	db 0FH				;18A4
	db 12H				;18A5
	db 0EFH				;18A6
	db 0B7H				;18A7
L18A8:	push psw
	cp L1489
	lxi h,D18C0
	call L1212
	pop psw
	cnc L1489
	lxi h,D18C4
	jmp L17AC
D18BC:	db 0DBH				;18BC
	db 0FH				;18BD
	db 49H				;18BE
	db 81H				;18BF
D18C0:	db 00H				;18C0
	db 00H				;18C1
	db 00H				;18C2
	db 7FH				;18C3
D18C4:	db 05H				;18C4
	db 0BAH				;18C5
	db 0D7H				;18C6
	db 1EH				;18C7
	db 86H				;18C8
	db 64H				;18C9
	db 26H				;18CA
	db 99H				;18CB
	db 87H				;18CC
	db 58H				;18CD
	db 34H				;18CE
	db 23H				;18CF
	db 87H				;18D0
	db 0E0H				;18D1
	db 5DH				;18D2
	db 0A5H				;18D3
	db 86H				;18D4
	db 0DAH				;18D5
	db 0FH				;18D6
	db 49H				;18D7
	db 83H				;18D8
					;tangent function
					;tan(x)=sin(x)/cos(x)
Cos:	call pushf			;save arg
	call L187C			;  tan(x)=sin(x)/cos(x)
	pop b				;get x off stack
	pop h				;pushf smashes (de)
	call pushf
	xchg				;get lo'S WHERE THEY BELONG
	call movfr
	call Sin
	jmp L13B7
StmtLET: rst 5
	cm L16FA
	cm L1489
	lda D0256
	cpi 81H
	jc L1909
	lxi b,8100H
	mov d,c
	mov e,c				;compute reciprocal to use the identity:
	call L13B9			; arctan(x)=pi/2-arctan(1/x)
	lxi h,L1218			;put fsubs on the stack so we will return
	push h				;to it and subtract the reult from pi/2
L1909:	lxi h,D1913			;evaluate approximation polynomial
	call L17AC
	lxi h,D18BC			;get pointer to pi/2 in case we have to
	ret				;subtract the result from pi/2
D1913:	db 09H				;1913
	db 4AH				;1914
	db 0D7H				;1915
	db 3BH				;1916
	db 78H				;1917
	db 02H				;1918
	db 6EH				;1919
	db 84H				;191A
	db 7BH				;191B
	db 0FEH				;191C
	db 0C1H				;191D
	db 2FH				;191E
	db 7CH				;191F
	db 74H				;1920
	db 31H				;1921
	db 9AH				;1922
	db 7DH				;1923
	db 84H				;1924
	db 3DH				;1925
	db 5AH				;1926
	db 7DH				;1927
	db 0C8H				;1928
	db 7FH				;1929
	db 91H				;192A
	db 7EH				;192B
	db 0E4H				;192C
	db 0BBH				;192D
	db 4CH				;192E
	db 7EH				;192F
	db 6CH				;1930
	db 0AAH				;1931
	db 0AAH				;1932
	db 7FH				;1933
	db 00H				;1934
	db 00H				;1935
	db 00H				;1936
	db 81H				;1937
D1938:	db 00H				;1938
	db 00H				;1939
					;tangent function
					;tan(x)=sin(x)/cos(x)
Tan:	in 0FFH				;Read sense switches
	ani 0F0H			;Mask upper nibble
	rrc				;Shift to get device type
	rrc
	cpi 3CH				;Check for specific device
	rz				;Return if match
	cpi 38H				;Check for alternate device
	stc				;Set carry
	jnz Atn				;Not found, use config table
	lxi h,D1FFF
	mov c,m				;Get config byte
	dcx h
	mov a,m				;Get another config byte
	ani 0F0H
	rrc
	rrc
					;idea: use identities to get arg between 0 and 1 and then use an
					;approximation polynomial to compute arctan(x)
Atn:	push psw
	mov l,a				;Index into config table
	mvi h,00H
	lxi d,D19B8
	dad d				;HL = table entry
	mov a,m				;Load configuration values
	inx h
	mov d,m
	inx h
	mov b,m
	inx h
	mov e,m
	mov h,a
	pop psw
	push psw
	mov a,h
	jc L196A
	mov a,c
L196A:	sta 19B6H
	pop psw
	lxi h,D19D4			;Return address after I/O config
	push h
	mvi c,0FFH
	cpi 10H
	lxi h,Start
	shld L0552			;Store jump address
	jz L198E
	cpi 08H
	rnc				;Return if device type >= 8
	adi 11H
	push psw
	mvi a,03H
	call L19B5
	pop psw
	jmp L19B5
L198E:	xra a
	call L19B5
	call L19B1
	call L19B1
L1998:	cma
	mvi c,01H
	call L19B1
	push h
	lhld L19B5
	mvi l,0DBH
	shld L0552
	pop h
	mvi a,2CH
	dcr m
	call L19B5
	dcr m
	dcr m
	dcr m
L19B1:	lxi h,19B6H
	inr m
L19B5:	out 10H
	ret
D19B8:	db 10H				;19B8
	db 0CAH				;19B9
	db 01H				;19BA
	db 02H				;19BB
	db 10H				;19BC
	db 0CAH				;19BD
	db 01H				;19BE
	db 02H				;19BF
	db 00H				;19C0
	db 0C2H				;19C1
	db 01H				;19C2
	db 80H				;19C3
	db 06H				;19C4
	db 0C2H				;19C5
	db 01H				;19C6
	db 80H				;19C7
	db 20H				;19C8
	db 0CAH				;19C9
	db 80H				;19CA
	db 80H				;19CB
	db 04H				;19CC
	db 0CAH				;19CD
	db 02H				;19CE
	db 01H				;19CF
	db 24H				;19D0
	db 0CAH				;19D1
	db 40H				;19D2
	db 40H				;19D3
D19D4:	db 62H				;19D4
	db 68H				;19D5
	db 22H				;19D6
	db 59H				;19D7
	db 05H				;19D8
	db 7CH				;19D9
	db 0E6H				;19DA
	db 0C8H				;19DB
	db 67H				;19DC
	db 22H				;19DD
	db 6BH				;19DE
	db 06H				;19DF
	db 0EEH				;19E0
	db 0CH				;19E1
	db 67H				;19E2
	db 22H				;19E3
	db 0FH				;19E4
	db 06H				;19E5
	db 0EBH				;19E6
	db 22H				;19E7
	db 4AH				;19E8
	db 05H				;19E9
	db 3AH				;19EA
	db 0B6H				;19EB
	db 19H				;19EC
	db 32H				;19ED
	db 57H				;19EE
	db 05H				;19EF
	db 32H				;19F0
	db 69H				;19F1
	db 06H				;19F2
	db 32H				;19F3
	db 0DH				;19F4
	db 06H				;19F5
	db 3CH				;19F6
	db 32H				;19F7
	db 5EH				;19F8
	db 05H				;19F9
	db 81H				;19FA
	db 32H				;19FB
	db 48H				;19FC
	db 05H				;19FD
	db 3CH				;19FE
	db 32H				;19FF
	db 50H				;1A00
	db 05H				;1A01
	db 0C9H				;1A02
	db 00H				;1A03
	db 00H				;1A04
L1A05:	lxi h,szMicrosoft
	call finex
;=============================================================================
;Init - Initialization Code
;This code runs once at startup, asks user for memory size and terminal
;width, then initializes BASIC and prints "XXXX BYTES FREE"
;This memory is reclaimed for program storage after init completes.
;=============================================================================
Init:	lxi h,D1C0F
	sphl				;Set stack pointer
	shld stack_top			;Save stack top
	call Tan			;Detect and configure I/O hardware
	lxi h,0FFFFH			;Current line = -1 (direct mode)
	shld current_line
	xra a
	sta suppress_output
	call L08ED
	lxi h,D022A
	shld D0228
L1A28:	lxi h,szMemorySize		;"MEMORY SIZE"
	call finex			;Print (HL already at first char)
	call L03EF			;Get user input with "? " prompt
	jc L1A28			;Retry on error
	rst 2				;NextChar
	cpi 41H
	jz L1A05
	ora a
	jnz L1A51
	lxi h,D1BC9
;
;here when passing over string literal in subscript of variable in input list
;on the first pass of input checking for type match and number
;
;
;here when passing over string literal in subscript of variable in input list
;on the first pass of input checking for type match and number
;
scnstr:	inx h				;look at the next character
	mov a,h				;Check for wrap to 0000
	ora l
	jz FindMemTop			;Wrapped, use previous address
	mov a,m				;Read memory
	cma				;Complement
	mov m,a				;Write back
	cmp m				;Did it stick?
	jz scnstr			;Yes, continue
	jmp FindMemTop			;No, found top of RAM
L1A51:	lxi h,D01D9			;Parse number from input
	call L0752
	mov a,m				;Check for trailing garbage
	ora a
	jnz SyntaxError
	xchg				;HL = memory size
FindMemTop: dcx h			;HL = last usable address (top-1)
	push h				;Save memory top on stack
L1A5F:	lxi h,szTerminalWidth
	call finex			;Print (HL already at first char)
	call L03EF			;Get input with "?" prompt
	jc L1A5F			;On break, ask again
	rst 2				;NextChar - get first char
	ora a				;Empty input?
	mvi a,48H			;Default width = 72 (0x48)
	mov e,a				;Save default in E
	jz L1A81			;If empty, use default
	call L0752			;Parse width from input
	mov a,d
	ora a
	jnz L1A5F
	mov a,e
	cpi 0FH
	jc L1A5F
L1A81:	sta 053FH
	sta D06C6
	sta D08CE			;Store terminal width
L1A8A:	sui 0EH				;Subtract 14
	jnc L1A8A			;Loop until negative
	adi 1CH				;Add 28 (14*2) to restore + offset
	cma				;Negate to get -remainder
	inr a
	add e				;Add to width: last_tab = width - (width % 14)
	sta D0906
	lxi d,0FFCFH
	pop h
	shld D0226
	dad d
	jnc OutOfMemory
	dcx h				;HL = last usable address (top-1)
	push h				;Save memory top on stack
L1AA4:	lxi h,szWantSinCosTanAtn
	call finex			;Print (HL already at first char)
	call L03EF			;Get input with "?" prompt
	jc L1AA4			;On break, ask again
	rst 2				;NextChar - get first char
	lxi h,StmtDATA
	cpi 59H
	lxi d,D1938
	jz SetupTrigFns
	cpi 41H
	jz L1AC6
	cpi 4EH
	jnz L1AA4
L1AC6:	lxi d,StmtLET
	shld D005F
	cpi 41H
	jz SetupTrigFns
	shld D0059
	shld D005D
	shld D005B
	lxi d,Sin
SetupTrigFns: xchg			;HL = program base address (from DE)
	mvi m,00H			;Write null byte at program base
	inx h
	shld program_base		;Store program base address
	xthl				;HL = memory top, push program base
	lxi d,D1C0F
	rst 4				;CompareHLDE - enough memory?
	jc OutOfMemory			;No, error
	pop d				;DE = program base
	sphl				;Set stack pointer to memory top
	shld stack_top			;Save stack top
	xchg				;HL = program base, DE = stack top
	call 02AFH
	mov a,e				;DE still has stack top
	sub l
	mov l,a
	mov a,d
	sbb h
	mov h,a				;HL = stack_top - program_base
	lxi b,0FFF0H			;-16 for overhead
	dad b				;HL = free bytes
	call L08ED			;Print free byte count
	call PrintInt
	lxi h,szBytesFree
	call finex
	lxi h,finex
	shld 0302H
	call InputLineWithQ
	lxi h,Main
	shld 0002H
	pchl
szWantSinCosTanAtn: db 57H		;1B1B
	db 41H				;1B1C
	db 4EH				;1B1D
	db 54H				;1B1E
	db 20H				;1B1F
	db 53H				;1B20
	db 49H				;1B21
	db 4EH				;1B22
	db 2DH				;1B23
	db 43H				;1B24
	db 4FH				;1B25
	db 53H				;1B26
	db 2DH				;1B27
	db 54H				;1B28
	db 41H				;1B29
	db 4EH				;1B2A
	db 2DH				;1B2B
	db 41H				;1B2C
	db 54H				;1B2D
	db 4EH				;1B2E
	db 00H				;1B2F
szMicrosoft: db 0DH			;1B30
	db 0AH				;1B31
	db 0AH				;1B32
	db 57H				;1B33
	db 52H				;1B34
	db 49H				;1B35
	db 54H				;1B36
	db 54H				;1B37
	db 45H				;1B38
	db 4EH				;1B39
	db 20H				;1B3A
	db 46H				;1B3B
	db 4FH				;1B3C
	db 52H				;1B3D
	db 20H				;1B3E
	db 52H				;1B3F
	db 4FH				;1B40
	db 59H				;1B41
	db 41H				;1B42
	db 4CH				;1B43
	db 54H				;1B44
	db 49H				;1B45
	db 45H				;1B46
	db 53H				;1B47
	db 20H				;1B48
	db 42H				;1B49
	db 59H				;1B4A
	db 20H				;1B4B
	db 4DH				;1B4C
	db 49H				;1B4D
	db 43H				;1B4E
	db 52H				;1B4F
	db 4FH				;1B50
	db 2DH				;1B51
	db 53H				;1B52
	db 4FH				;1B53
	db 46H				;1B54
	db 54H				;1B55
	db 0DH				;1B56
	db 0AH				;1B57
	db 00H				;1B58
szTerminalWidth: db 54H			;1B59
	db 45H				;1B5A
	db 52H				;1B5B
	db 4DH				;1B5C
	db 49H				;1B5D
	db 4EH				;1B5E
	db 41H				;1B5F
	db 4CH				;1B60
	db 20H				;1B61
	db 57H				;1B62
	db 49H				;1B63
	db 44H				;1B64
	db 54H				;1B65
	db 48H				;1B66
	db 00H				;1B67
szMemorySize: db 4DH			;1B68
	db 45H				;1B69
	db 4DH				;1B6A
	db 4FH				;1B6B
	db 52H				;1B6C
	db 59H				;1B6D
	db 20H				;1B6E
	db 53H				;1B6F
	db 49H				;1B70
	db 5AH				;1B71
	db 45H				;1B72
	db 00H				;1B73
szBytesFree: db 20H			;1B74
	db 42H				;1B75
	db 59H				;1B76
	db 54H				;1B77
	db 45H				;1B78
	db 53H				;1B79
	db 20H				;1B7A
	db 46H				;1B7B
	db 52H				;1B7C
	db 45H				;1B7D
	db 45H				;1B7E
	db 0DH				;1B7F
	db 0AH				;1B80
szVersion: db 41H			;1B81
	db 4CH				;1B82
	db 54H				;1B83
	db 41H				;1B84
	db 49H				;1B85
	db 52H				;1B86
	db 20H				;1B87
	db 42H				;1B88
	db 41H				;1B89
	db 53H				;1B8A
	db 49H				;1B8B
	db 43H				;1B8C
	db 20H				;1B8D
	db 52H				;1B8E
	db 45H				;1B8F
	db 56H				;1B90
	db 2EH				;1B91
	db 20H				;1B92
	db 34H				;1B93
	db 2EH				;1B94
	db 30H				;1B95
	db 0DH				;1B96
	db 0AH				;1B97
szEightK: db 5BH			;1B98
	db 45H				;1B99
	db 49H				;1B9A
	db 47H				;1B9B
	db 48H				;1B9C
	db 54H				;1B9D
	db 2DH				;1B9E
	db 4BH				;1B9F
	db 20H				;1BA0
	db 56H				;1BA1
	db 45H				;1BA2
	db 52H				;1BA3
	db 53H				;1BA4
	db 49H				;1BA5
	db 4FH				;1BA6
	db 4EH				;1BA7
	db 5DH				;1BA8
	db 0DH				;1BA9
	db 0AH				;1BAA
szCopyright: db 43H			;1BAB
	db 4FH				;1BAC
	db 50H				;1BAD
	db 59H				;1BAE
	db 52H				;1BAF
	db 49H				;1BB0
	db 47H				;1BB1
	db 48H				;1BB2
	db 54H				;1BB3
	db 20H				;1BB4
	db 31H				;1BB5
	db 39H				;1BB6
	db 37H				;1BB7
	db 36H				;1BB8
	db 20H				;1BB9
	db 42H				;1BBA
	db 59H				;1BBB
	db 20H				;1BBC
	db 4DH				;1BBD
	db 49H				;1BBE
	db 54H				;1BBF
	db 53H				;1BC0
	db 20H				;1BC1
	db 49H				;1BC2
	db 4EH				;1BC3
	db 43H				;1BC4
	db 2EH				;1BC5
	db 0DH				;1BC6
	db 0AH				;1BC7
	db 00H				;1BC8
D1BC9:	db 00H				;1BC9
	db 00H				;1BCA
	db 00H				;1BCB
	db 00H				;1BCC
	db 00H				;1BCD
	db 00H				;1BCE
	db 00H				;1BCF
	db 00H				;1BD0
	db 00H				;1BD1
	db 00H				;1BD2
	db 00H				;1BD3
	db 00H				;1BD4
	db 00H				;1BD5
	db 00H				;1BD6
	db 00H				;1BD7
	db 00H				;1BD8
	db 00H				;1BD9
	db 00H				;1BDA
	db 00H				;1BDB
	db 00H				;1BDC
	db 00H				;1BDD
	db 00H				;1BDE
	db 00H				;1BDF
	db 00H				;1BE0
	db 00H				;1BE1
	db 00H				;1BE2
	db 00H				;1BE3
	db 00H				;1BE4
	db 00H				;1BE5
	db 00H				;1BE6
	db 00H				;1BE7
	db 00H				;1BE8
	db 00H				;1BE9
	db 00H				;1BEA
	db 00H				;1BEB
	db 00H				;1BEC
	db 00H				;1BED
	db 00H				;1BEE
	db 00H				;1BEF
	db 00H				;1BF0
	db 00H				;1BF1
	db 00H				;1BF2
	db 00H				;1BF3
	db 00H				;1BF4
	db 00H				;1BF5
	db 00H				;1BF6
	db 00H				;1BF7
	db 00H				;1BF8
	db 00H				;1BF9
	db 00H				;1BFA
	db 00H				;1BFB
	db 00H				;1BFC
	db 00H				;1BFD
	db 00H				;1BFE
	db 00H				;1BFF
	db 00H				;1C00
	db 00H				;1C01
	db 00H				;1C02
	db 00H				;1C03
	db 00H				;1C04
	db 00H				;1C05
	db 00H				;1C06
	db 00H				;1C07
	db 00H				;1C08
	db 00H				;1C09
	db 00H				;1C0A
	db 00H				;1C0B
	db 00H				;1C0C
	db 00H				;1C0D
	db 00H				;1C0E
D1C0F:	db 00H				;1C0F
	db 00H				;1C10
	db 00H				;1C11
	db 00H				;1C12
	db 00H				;1C13
	db 00H				;1C14
	db 00H				;1C15
	db 00H				;1C16
	db 00H				;1C17
	db 00H				;1C18
	db 00H				;1C19
	db 00H				;1C1A
	db 00H				;1C1B
	db 00H				;1C1C
	db 00H				;1C1D
	db 00H				;1C1E
	db 00H				;1C1F
	db 00H				;1C20
	db 00H				;1C21
	db 00H				;1C22
	db 00H				;1C23
	db 00H				;1C24
	db 00H				;1C25
	db 00H				;1C26
	db 00H				;1C27
	db 00H				;1C28
	db 00H				;1C29
	db 00H				;1C2A
	db 00H				;1C2B
	db 00H				;1C2C
	db 00H				;1C2D
	db 00H				;1C2E
	db 00H				;1C2F
	db 00H				;1C30
	db 00H				;1C31
	db 00H				;1C32
	db 00H				;1C33
	db 00H				;1C34
	db 00H				;1C35
	db 00H				;1C36
	db 00H				;1C37
	db 00H				;1C38
	db 00H				;1C39
	db 00H				;1C3A
	db 00H				;1C3B
	db 00H				;1C3C
	db 00H				;1C3D
	db 00H				;1C3E
	db 00H				;1C3F
	db 00H				;1C40
	db 00H				;1C41
	db 00H				;1C42
	db 00H				;1C43
	db 00H				;1C44
	db 00H				;1C45
	db 00H				;1C46
	db 00H				;1C47
	db 00H				;1C48
	db 00H				;1C49
	db 00H				;1C4A
	db 00H				;1C4B
	db 00H				;1C4C
	db 00H				;1C4D
	db 00H				;1C4E
	db 00H				;1C4F
	db 00H				;1C50
	db 00H				;1C51
	db 00H				;1C52
	db 00H				;1C53
	db 00H				;1C54
	db 00H				;1C55
	db 00H				;1C56
	db 00H				;1C57
	db 00H				;1C58
	db 00H				;1C59
	db 00H				;1C5A
	db 00H				;1C5B
	db 00H				;1C5C
	db 00H				;1C5D
	db 00H				;1C5E
	db 00H				;1C5F
	db 00H				;1C60
	db 00H				;1C61
	db 00H				;1C62
	db 00H				;1C63
	db 00H				;1C64
	db 00H				;1C65
	db 00H				;1C66
	db 00H				;1C67
	db 00H				;1C68
	db 00H				;1C69
	db 00H				;1C6A
	db 00H				;1C6B
	db 00H				;1C6C
	db 00H				;1C6D
	db 00H				;1C6E
	db 00H				;1C6F
	db 00H				;1C70
	db 00H				;1C71
	db 00H				;1C72
	db 00H				;1C73
	db 00H				;1C74
	db 00H				;1C75
	db 00H				;1C76
	db 00H				;1C77
	db 00H				;1C78
	db 00H				;1C79
	db 00H				;1C7A
	db 00H				;1C7B
	db 00H				;1C7C
	db 00H				;1C7D
	db 00H				;1C7E
	db 00H				;1C7F
	db 00H				;1C80
	db 00H				;1C81
	db 00H				;1C82
	db 00H				;1C83
	db 00H				;1C84
	db 00H				;1C85
	db 00H				;1C86
	db 00H				;1C87
	db 00H				;1C88
	db 00H				;1C89
	db 00H				;1C8A
	db 00H				;1C8B
	db 00H				;1C8C
	db 00H				;1C8D
	db 00H				;1C8E
	db 00H				;1C8F
	db 00H				;1C90
	db 00H				;1C91
	db 00H				;1C92
	db 00H				;1C93
	db 00H				;1C94
	db 00H				;1C95
	db 00H				;1C96
	db 00H				;1C97
	db 00H				;1C98
	db 00H				;1C99
	db 00H				;1C9A
	db 00H				;1C9B
	db 00H				;1C9C
	db 00H				;1C9D
	db 00H				;1C9E
	db 00H				;1C9F
	db 00H				;1CA0
	db 00H				;1CA1
	db 00H				;1CA2
	db 00H				;1CA3
	db 00H				;1CA4
	db 00H				;1CA5
	db 00H				;1CA6
	db 00H				;1CA7
	db 00H				;1CA8
	db 00H				;1CA9
	db 00H				;1CAA
	db 00H				;1CAB
	db 00H				;1CAC
	db 00H				;1CAD
	db 00H				;1CAE
	db 00H				;1CAF
	db 00H				;1CB0
	db 00H				;1CB1
	db 00H				;1CB2
	db 00H				;1CB3
	db 00H				;1CB4
	db 00H				;1CB5
	db 00H				;1CB6
	db 00H				;1CB7
	db 00H				;1CB8
	db 00H				;1CB9
	db 00H				;1CBA
	db 00H				;1CBB
	db 00H				;1CBC
	db 00H				;1CBD
	db 00H				;1CBE
	db 00H				;1CBF
	db 00H				;1CC0
	db 00H				;1CC1
	db 00H				;1CC2
	db 00H				;1CC3
	db 00H				;1CC4
	db 00H				;1CC5
	db 00H				;1CC6
	db 00H				;1CC7
	db 00H				;1CC8
	db 00H				;1CC9
	db 00H				;1CCA
	db 00H				;1CCB
	db 00H				;1CCC
	db 00H				;1CCD
	db 00H				;1CCE
	db 00H				;1CCF
	db 00H				;1CD0
	db 00H				;1CD1
	db 00H				;1CD2
	db 00H				;1CD3
	db 00H				;1CD4
	db 00H				;1CD5
	db 00H				;1CD6
	db 00H				;1CD7
	db 00H				;1CD8
	db 00H				;1CD9
	db 00H				;1CDA
	db 00H				;1CDB
	db 00H				;1CDC
	db 00H				;1CDD
	db 00H				;1CDE
	db 00H				;1CDF
	db 00H				;1CE0
	db 00H				;1CE1
	db 00H				;1CE2
	db 00H				;1CE3
	db 00H				;1CE4
	db 00H				;1CE5
	db 00H				;1CE6
	db 00H				;1CE7
	db 00H				;1CE8
	db 00H				;1CE9
	db 00H				;1CEA
	db 00H				;1CEB
	db 00H				;1CEC
	db 00H				;1CED
	db 00H				;1CEE
	db 00H				;1CEF
	db 00H				;1CF0
	db 00H				;1CF1
	db 00H				;1CF2
	db 00H				;1CF3
	db 00H				;1CF4
	db 00H				;1CF5
	db 00H				;1CF6
	db 00H				;1CF7
	db 00H				;1CF8
	db 00H				;1CF9
	db 00H				;1CFA
	db 00H				;1CFB
	db 00H				;1CFC
	db 00H				;1CFD
	db 00H				;1CFE
	db 00H				;1CFF
	db 00H				;1D00
	db 00H				;1D01
	db 00H				;1D02
	db 00H				;1D03
	db 00H				;1D04
	db 00H				;1D05
	db 00H				;1D06
	db 00H				;1D07
	db 00H				;1D08
	db 00H				;1D09
	db 00H				;1D0A
	db 00H				;1D0B
	db 00H				;1D0C
	db 00H				;1D0D
	db 00H				;1D0E
	db 00H				;1D0F
	db 00H				;1D10
	db 00H				;1D11
	db 00H				;1D12
	db 00H				;1D13
	db 00H				;1D14
	db 00H				;1D15
	db 00H				;1D16
	db 00H				;1D17
	db 00H				;1D18
	db 00H				;1D19
	db 00H				;1D1A
	db 00H				;1D1B
	db 00H				;1D1C
	db 00H				;1D1D
	db 00H				;1D1E
	db 00H				;1D1F
	db 00H				;1D20
	db 00H				;1D21
	db 00H				;1D22
	db 00H				;1D23
	db 00H				;1D24
	db 00H				;1D25
	db 00H				;1D26
	db 00H				;1D27
	db 00H				;1D28
	db 00H				;1D29
	db 00H				;1D2A
	db 00H				;1D2B
	db 00H				;1D2C
	db 00H				;1D2D
	db 00H				;1D2E
	db 00H				;1D2F
	db 00H				;1D30
	db 00H				;1D31
	db 00H				;1D32
	db 00H				;1D33
	db 00H				;1D34
	db 00H				;1D35
	db 00H				;1D36
	db 00H				;1D37
	db 00H				;1D38
	db 00H				;1D39
	db 00H				;1D3A
	db 00H				;1D3B
	db 00H				;1D3C
	db 00H				;1D3D
	db 00H				;1D3E
	db 00H				;1D3F
	db 00H				;1D40
	db 00H				;1D41
	db 00H				;1D42
	db 00H				;1D43
	db 00H				;1D44
	db 00H				;1D45
	db 00H				;1D46
	db 00H				;1D47
	db 00H				;1D48
	db 00H				;1D49
	db 00H				;1D4A
	db 00H				;1D4B
	db 00H				;1D4C
	db 00H				;1D4D
	db 00H				;1D4E
	db 00H				;1D4F
	db 00H				;1D50
	db 00H				;1D51
	db 00H				;1D52
	db 00H				;1D53
	db 00H				;1D54
	db 00H				;1D55
	db 00H				;1D56
	db 00H				;1D57
	db 00H				;1D58
	db 00H				;1D59
	db 00H				;1D5A
	db 00H				;1D5B
	db 00H				;1D5C
	db 00H				;1D5D
	db 00H				;1D5E
	db 00H				;1D5F
	db 00H				;1D60
	db 00H				;1D61
	db 00H				;1D62
	db 00H				;1D63
	db 00H				;1D64
	db 00H				;1D65
	db 00H				;1D66
	db 00H				;1D67
	db 00H				;1D68
	db 00H				;1D69
	db 00H				;1D6A
	db 00H				;1D6B
	db 00H				;1D6C
	db 00H				;1D6D
	db 00H				;1D6E
	db 00H				;1D6F
	db 00H				;1D70
	db 00H				;1D71
	db 00H				;1D72
	db 00H				;1D73
	db 00H				;1D74
	db 00H				;1D75
	db 00H				;1D76
	db 00H				;1D77
	db 00H				;1D78
	db 00H				;1D79
	db 00H				;1D7A
	db 00H				;1D7B
	db 00H				;1D7C
	db 00H				;1D7D
	db 00H				;1D7E
	db 00H				;1D7F
	db 00H				;1D80
	db 00H				;1D81
	db 00H				;1D82
	db 00H				;1D83
	db 00H				;1D84
	db 00H				;1D85
	db 00H				;1D86
	db 00H				;1D87
	db 00H				;1D88
	db 00H				;1D89
	db 00H				;1D8A
	db 00H				;1D8B
	db 00H				;1D8C
	db 00H				;1D8D
	db 00H				;1D8E
	db 00H				;1D8F
	db 00H				;1D90
	db 00H				;1D91
	db 00H				;1D92
	db 00H				;1D93
	db 00H				;1D94
	db 00H				;1D95
	db 00H				;1D96
	db 00H				;1D97
	db 00H				;1D98
	db 00H				;1D99
	db 00H				;1D9A
	db 00H				;1D9B
	db 00H				;1D9C
	db 00H				;1D9D
	db 00H				;1D9E
	db 00H				;1D9F
	db 00H				;1DA0
	db 00H				;1DA1
	db 00H				;1DA2
	db 00H				;1DA3
	db 00H				;1DA4
	db 00H				;1DA5
	db 00H				;1DA6
	db 00H				;1DA7
	db 00H				;1DA8
	db 00H				;1DA9
	db 00H				;1DAA
	db 00H				;1DAB
	db 00H				;1DAC
	db 00H				;1DAD
	db 00H				;1DAE
	db 00H				;1DAF
	db 00H				;1DB0
	db 00H				;1DB1
	db 00H				;1DB2
	db 00H				;1DB3
	db 00H				;1DB4
	db 00H				;1DB5
	db 00H				;1DB6
	db 00H				;1DB7
	db 00H				;1DB8
	db 00H				;1DB9
	db 00H				;1DBA
	db 00H				;1DBB
	db 00H				;1DBC
	db 00H				;1DBD
	db 00H				;1DBE
	db 00H				;1DBF
	db 00H				;1DC0
	db 00H				;1DC1
	db 00H				;1DC2
	db 00H				;1DC3
	db 00H				;1DC4
	db 00H				;1DC5
	db 00H				;1DC6
	db 00H				;1DC7
	db 00H				;1DC8
	db 00H				;1DC9
	db 00H				;1DCA
	db 00H				;1DCB
	db 00H				;1DCC
	db 00H				;1DCD
	db 00H				;1DCE
	db 00H				;1DCF
	db 00H				;1DD0
	db 00H				;1DD1
	db 00H				;1DD2
	db 00H				;1DD3
	db 00H				;1DD4
	db 00H				;1DD5
	db 00H				;1DD6
	db 00H				;1DD7
	db 00H				;1DD8
	db 00H				;1DD9
	db 00H				;1DDA
	db 00H				;1DDB
	db 00H				;1DDC
	db 00H				;1DDD
	db 00H				;1DDE
	db 00H				;1DDF
	db 00H				;1DE0
	db 00H				;1DE1
	db 00H				;1DE2
	db 00H				;1DE3
	db 00H				;1DE4
	db 00H				;1DE5
	db 00H				;1DE6
	db 00H				;1DE7
	db 00H				;1DE8
	db 00H				;1DE9
	db 00H				;1DEA
	db 00H				;1DEB
	db 00H				;1DEC
	db 00H				;1DED
	db 00H				;1DEE
	db 00H				;1DEF
	db 00H				;1DF0
	db 00H				;1DF1
	db 00H				;1DF2
	db 00H				;1DF3
	db 00H				;1DF4
	db 00H				;1DF5
	db 00H				;1DF6
	db 00H				;1DF7
	db 00H				;1DF8
	db 00H				;1DF9
	db 00H				;1DFA
	db 00H				;1DFB
	db 00H				;1DFC
	db 00H				;1DFD
	db 00H				;1DFE
	db 00H				;1DFF
	db 00H				;1E00
	db 00H				;1E01
	db 00H				;1E02
	db 00H				;1E03
	db 00H				;1E04
	db 00H				;1E05
	db 00H				;1E06
	db 00H				;1E07
	db 00H				;1E08
	db 00H				;1E09
	db 00H				;1E0A
	db 00H				;1E0B
	db 00H				;1E0C
	db 00H				;1E0D
	db 00H				;1E0E
	db 00H				;1E0F
	db 00H				;1E10
	db 00H				;1E11
	db 00H				;1E12
	db 00H				;1E13
	db 00H				;1E14
	db 00H				;1E15
	db 00H				;1E16
	db 00H				;1E17
	db 00H				;1E18
	db 00H				;1E19
	db 00H				;1E1A
	db 00H				;1E1B
	db 00H				;1E1C
	db 00H				;1E1D
	db 00H				;1E1E
	db 00H				;1E1F
	db 00H				;1E20
	db 00H				;1E21
	db 00H				;1E22
	db 00H				;1E23
	db 00H				;1E24
	db 00H				;1E25
	db 00H				;1E26
	db 00H				;1E27
	db 00H				;1E28
	db 00H				;1E29
	db 00H				;1E2A
	db 00H				;1E2B
	db 00H				;1E2C
	db 00H				;1E2D
	db 00H				;1E2E
	db 00H				;1E2F
	db 00H				;1E30
	db 00H				;1E31
	db 00H				;1E32
	db 00H				;1E33
	db 00H				;1E34
	db 00H				;1E35
	db 00H				;1E36
	db 00H				;1E37
	db 00H				;1E38
	db 00H				;1E39
	db 00H				;1E3A
	db 00H				;1E3B
	db 00H				;1E3C
	db 00H				;1E3D
	db 00H				;1E3E
	db 00H				;1E3F
	db 00H				;1E40
	db 00H				;1E41
	db 00H				;1E42
	db 00H				;1E43
	db 00H				;1E44
	db 00H				;1E45
	db 00H				;1E46
	db 00H				;1E47
	db 00H				;1E48
	db 00H				;1E49
	db 00H				;1E4A
	db 00H				;1E4B
	db 00H				;1E4C
	db 00H				;1E4D
	db 00H				;1E4E
	db 00H				;1E4F
	db 00H				;1E50
	db 00H				;1E51
	db 00H				;1E52
	db 00H				;1E53
	db 00H				;1E54
	db 00H				;1E55
	db 00H				;1E56
	db 00H				;1E57
	db 00H				;1E58
	db 00H				;1E59
	db 00H				;1E5A
	db 00H				;1E5B
	db 00H				;1E5C
	db 00H				;1E5D
	db 00H				;1E5E
	db 00H				;1E5F
	db 00H				;1E60
	db 00H				;1E61
	db 00H				;1E62
	db 00H				;1E63
	db 00H				;1E64
	db 00H				;1E65
	db 00H				;1E66
	db 00H				;1E67
	db 00H				;1E68
	db 00H				;1E69
	db 00H				;1E6A
	db 00H				;1E6B
	db 00H				;1E6C
	db 00H				;1E6D
	db 00H				;1E6E
	db 00H				;1E6F
	db 00H				;1E70
	db 00H				;1E71
	db 00H				;1E72
	db 00H				;1E73
	db 00H				;1E74
	db 00H				;1E75
	db 00H				;1E76
	db 00H				;1E77
	db 00H				;1E78
	db 00H				;1E79
	db 00H				;1E7A
	db 00H				;1E7B
	db 00H				;1E7C
	db 00H				;1E7D
	db 00H				;1E7E
	db 00H				;1E7F
	db 00H				;1E80
	db 00H				;1E81
	db 00H				;1E82
	db 00H				;1E83
	db 00H				;1E84
	db 00H				;1E85
	db 00H				;1E86
	db 00H				;1E87
	db 00H				;1E88
	db 00H				;1E89
	db 00H				;1E8A
	db 00H				;1E8B
	db 00H				;1E8C
	db 00H				;1E8D
	db 00H				;1E8E
	db 00H				;1E8F
	db 00H				;1E90
	db 00H				;1E91
	db 00H				;1E92
	db 00H				;1E93
	db 00H				;1E94
	db 00H				;1E95
	db 00H				;1E96
	db 00H				;1E97
	db 00H				;1E98
	db 00H				;1E99
	db 00H				;1E9A
	db 00H				;1E9B
	db 00H				;1E9C
	db 00H				;1E9D
	db 00H				;1E9E
	db 00H				;1E9F
	db 00H				;1EA0
	db 00H				;1EA1
	db 00H				;1EA2
	db 00H				;1EA3
	db 00H				;1EA4
	db 00H				;1EA5
	db 00H				;1EA6
	db 00H				;1EA7
	db 00H				;1EA8
	db 00H				;1EA9
	db 00H				;1EAA
	db 00H				;1EAB
	db 00H				;1EAC
	db 00H				;1EAD
	db 00H				;1EAE
	db 00H				;1EAF
	db 00H				;1EB0
	db 00H				;1EB1
	db 00H				;1EB2
	db 00H				;1EB3
	db 00H				;1EB4
	db 00H				;1EB5
	db 00H				;1EB6
	db 00H				;1EB7
	db 00H				;1EB8
	db 00H				;1EB9
	db 00H				;1EBA
	db 00H				;1EBB
	db 00H				;1EBC
	db 00H				;1EBD
	db 00H				;1EBE
	db 00H				;1EBF
	db 00H				;1EC0
	db 00H				;1EC1
	db 00H				;1EC2
	db 00H				;1EC3
	db 00H				;1EC4
	db 00H				;1EC5
	db 00H				;1EC6
	db 00H				;1EC7
	db 00H				;1EC8
	db 00H				;1EC9
	db 00H				;1ECA
	db 00H				;1ECB
	db 00H				;1ECC
	db 00H				;1ECD
	db 00H				;1ECE
	db 00H				;1ECF
	db 00H				;1ED0
	db 00H				;1ED1
	db 00H				;1ED2
	db 00H				;1ED3
	db 00H				;1ED4
	db 00H				;1ED5
	db 00H				;1ED6
	db 00H				;1ED7
	db 00H				;1ED8
	db 00H				;1ED9
	db 00H				;1EDA
	db 00H				;1EDB
	db 00H				;1EDC
	db 00H				;1EDD
	db 00H				;1EDE
	db 00H				;1EDF
	db 00H				;1EE0
	db 00H				;1EE1
	db 00H				;1EE2
	db 00H				;1EE3
	db 00H				;1EE4
	db 00H				;1EE5
	db 00H				;1EE6
	db 00H				;1EE7
	db 00H				;1EE8
	db 00H				;1EE9
	db 00H				;1EEA
	db 00H				;1EEB
	db 00H				;1EEC
	db 00H				;1EED
	db 00H				;1EEE
	db 00H				;1EEF
	db 00H				;1EF0
	db 00H				;1EF1
	db 00H				;1EF2
	db 00H				;1EF3
	db 00H				;1EF4
	db 00H				;1EF5
	db 00H				;1EF6
	db 00H				;1EF7
	db 00H				;1EF8
	db 00H				;1EF9
	db 00H				;1EFA
	db 00H				;1EFB
	db 00H				;1EFC
	db 00H				;1EFD
	db 00H				;1EFE
	db 00H				;1EFF
	db 00H				;1F00
	db 00H				;1F01
	db 00H				;1F02
	db 00H				;1F03
	db 00H				;1F04
	db 00H				;1F05
	db 00H				;1F06
	db 00H				;1F07
	db 00H				;1F08
	db 00H				;1F09
	db 00H				;1F0A
	db 00H				;1F0B
	db 00H				;1F0C
	db 00H				;1F0D
	db 00H				;1F0E
	db 00H				;1F0F
	db 00H				;1F10
	db 00H				;1F11
	db 00H				;1F12
	db 00H				;1F13
	db 00H				;1F14
	db 00H				;1F15
	db 00H				;1F16
	db 00H				;1F17
	db 00H				;1F18
	db 00H				;1F19
	db 00H				;1F1A
	db 00H				;1F1B
	db 00H				;1F1C
	db 00H				;1F1D
	db 00H				;1F1E
	db 00H				;1F1F
	db 00H				;1F20
	db 00H				;1F21
	db 00H				;1F22
	db 00H				;1F23
	db 00H				;1F24
	db 00H				;1F25
	db 00H				;1F26
	db 00H				;1F27
	db 00H				;1F28
	db 00H				;1F29
	db 00H				;1F2A
	db 00H				;1F2B
	db 00H				;1F2C
	db 00H				;1F2D
	db 00H				;1F2E
	db 00H				;1F2F
	db 00H				;1F30
	db 00H				;1F31
	db 00H				;1F32
	db 00H				;1F33
	db 00H				;1F34
	db 00H				;1F35
	db 00H				;1F36
	db 00H				;1F37
	db 00H				;1F38
	db 00H				;1F39
	db 00H				;1F3A
	db 00H				;1F3B
	db 00H				;1F3C
	db 00H				;1F3D
	db 00H				;1F3E
	db 00H				;1F3F
	db 00H				;1F40
	db 00H				;1F41
	db 00H				;1F42
	db 00H				;1F43
	db 00H				;1F44
	db 00H				;1F45
	db 00H				;1F46
	db 00H				;1F47
	db 00H				;1F48
	db 00H				;1F49
	db 00H				;1F4A
	db 00H				;1F4B
	db 00H				;1F4C
	db 00H				;1F4D
	db 00H				;1F4E
	db 00H				;1F4F
	db 00H				;1F50
	db 00H				;1F51
	db 00H				;1F52
	db 00H				;1F53
	db 00H				;1F54
	db 00H				;1F55
	db 00H				;1F56
	db 00H				;1F57
	db 00H				;1F58
	db 00H				;1F59
	db 00H				;1F5A
	db 00H				;1F5B
	db 00H				;1F5C
	db 00H				;1F5D
	db 00H				;1F5E
	db 00H				;1F5F
	db 00H				;1F60
	db 00H				;1F61
	db 00H				;1F62
	db 00H				;1F63
	db 00H				;1F64
	db 00H				;1F65
	db 00H				;1F66
	db 00H				;1F67
	db 00H				;1F68
	db 00H				;1F69
	db 00H				;1F6A
	db 00H				;1F6B
	db 00H				;1F6C
	db 00H				;1F6D
	db 00H				;1F6E
	db 00H				;1F6F
	db 00H				;1F70
	db 00H				;1F71
	db 00H				;1F72
	db 00H				;1F73
	db 00H				;1F74
	db 00H				;1F75
	db 00H				;1F76
	db 00H				;1F77
	db 00H				;1F78
	db 00H				;1F79
	db 00H				;1F7A
	db 00H				;1F7B
	db 00H				;1F7C
	db 00H				;1F7D
	db 00H				;1F7E
	db 00H				;1F7F
	db 00H				;1F80
	db 00H				;1F81
	db 00H				;1F82
	db 00H				;1F83
	db 00H				;1F84
	db 00H				;1F85
	db 00H				;1F86
	db 00H				;1F87
	db 00H				;1F88
	db 00H				;1F89
	db 00H				;1F8A
	db 00H				;1F8B
	db 00H				;1F8C
	db 00H				;1F8D
	db 00H				;1F8E
	db 00H				;1F8F
	db 00H				;1F90
	db 00H				;1F91
	db 00H				;1F92
	db 00H				;1F93
	db 00H				;1F94
	db 00H				;1F95
	db 00H				;1F96
	db 00H				;1F97
	db 00H				;1F98
	db 00H				;1F99
	db 00H				;1F9A
	db 00H				;1F9B
	db 00H				;1F9C
	db 00H				;1F9D
	db 00H				;1F9E
	db 00H				;1F9F
	db 00H				;1FA0
	db 00H				;1FA1
	db 00H				;1FA2
	db 00H				;1FA3
	db 00H				;1FA4
	db 00H				;1FA5
	db 00H				;1FA6
	db 00H				;1FA7
	db 00H				;1FA8
	db 00H				;1FA9
	db 00H				;1FAA
	db 00H				;1FAB
	db 00H				;1FAC
	db 00H				;1FAD
	db 00H				;1FAE
	db 00H				;1FAF
	db 00H				;1FB0
	db 00H				;1FB1
	db 00H				;1FB2
	db 00H				;1FB3
	db 00H				;1FB4
	db 00H				;1FB5
	db 00H				;1FB6
	db 00H				;1FB7
	db 00H				;1FB8
	db 00H				;1FB9
	db 00H				;1FBA
	db 00H				;1FBB
	db 00H				;1FBC
	db 00H				;1FBD
	db 00H				;1FBE
	db 00H				;1FBF
	db 00H				;1FC0
	db 00H				;1FC1
	db 00H				;1FC2
	db 00H				;1FC3
	db 00H				;1FC4
	db 00H				;1FC5
	db 00H				;1FC6
	db 00H				;1FC7
	db 00H				;1FC8
	db 00H				;1FC9
	db 00H				;1FCA
	db 00H				;1FCB
	db 00H				;1FCC
	db 00H				;1FCD
	db 00H				;1FCE
	db 00H				;1FCF
	db 00H				;1FD0
	db 00H				;1FD1
	db 00H				;1FD2
	db 00H				;1FD3
	db 00H				;1FD4
	db 00H				;1FD5
	db 00H				;1FD6
	db 00H				;1FD7
	db 00H				;1FD8
	db 00H				;1FD9
	db 00H				;1FDA
	db 00H				;1FDB
	db 00H				;1FDC
	db 00H				;1FDD
	db 00H				;1FDE
	db 00H				;1FDF
	db 00H				;1FE0
	db 00H				;1FE1
	db 00H				;1FE2
	db 00H				;1FE3
	db 00H				;1FE4
	db 00H				;1FE5
	db 00H				;1FE6
	db 00H				;1FE7
	db 00H				;1FE8
	db 00H				;1FE9
	db 00H				;1FEA
	db 00H				;1FEB
	db 00H				;1FEC
	db 00H				;1FED
	db 00H				;1FEE
	db 00H				;1FEF
	db 00H				;1FF0
	db 00H				;1FF1
	db 00H				;1FF2
	db 00H				;1FF3
	db 00H				;1FF4
	db 00H				;1FF5
	db 00H				;1FF6
	db 00H				;1FF7
	db 00H				;1FF8
	db 00H				;1FF9
	db 00H				;1FFA
	db 00H				;1FFB
	db 00H				;1FFC
	db 00H				;1FFD
	db 00H				;1FFE
D1FFF:	db 00H				;1FFF

	end
