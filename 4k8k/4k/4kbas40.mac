; 4K BASIC Version 4.0 for Altair 8800
; Copyright 1976 MITS (Micro Instrumentation and Telemetry Systems)
; Written by Bill Gates, Paul Allen, and Monte Davidoff
;
; Annotated disassembly based on altairbasic.org reference for version 3.2
; Source file size: 3833 bytes

	.8080

; Macro: rdc - Reverse DC (high bit on FIRST character instead of last)
; Usage: rdc 'STRING' outputs first char with high bit set, rest normal
rdc	macro	str
	local	first
first	set	1
	irpc	ch,<str>
	if	first
	db	'&ch' + 80h
first	set	0
	else
	db	'&ch'
	endif
	endm
	endm

	aseg
	org	0000H

;=============================================================================
; RST 0 - Start / Cold Boot Entry Point
; The loader jumps here after loading BASIC from paper tape.
; Disables interrupts and jumps to initialization code.
;=============================================================================
Start:	di			; Disable interrupts
	jmp	Init		; Jump to initialization

; Unused function pointers (possibly for 8K BASIC compatibility)
	dw	049EH		; Unused pointer
	dw	0807H		; Unused pointer (FWordToFloat in 3.2)

;=============================================================================
; RST 1 - SyntaxCheck
; Elegant syntax checking at runtime. The byte following the RST 1 call
; is the expected token. If it doesn't match the current program byte,
; a Syntax Error is raised. If it matches, the return address is adjusted
; and execution falls into NextChar. This saves 2 bytes on every syntax check.
;=============================================================================
SyntaxCheck:
	mov	a,m		; A = current byte of BASIC program
	xthl			; HL = return address (points to expected byte)
	cmp	m		; Compare program byte to expected byte
	inx	hl		; Advance return address past expected byte
	xthl			; Restore HL, put adjusted return addr back
	jnz	SyntaxError	; Error if bytes don't match
				; Fall through to NextChar if match

;=============================================================================
; RST 2 - NextChar
; Returns next character of input from buffer at HL, skipping spaces.
; Carry flag is set if character is numeric (0-9).
; Zero flag is set if null terminator reached.
;=============================================================================
NextChar:
	inx	hl		; Advance to next character
	mov	a,m		; Get character
	cpi	':'		; Compare to colon (statement separator)
	rnc			; Return if >= ':' (not special)
	jmp	NextChar_tail	; Handle spaces and digits

;=============================================================================
; RST 3 - OutChar
; Outputs character in A to terminal, tracking cursor position.
;=============================================================================
OutChar:
	push	psw		; Save character
	lda	TERMINAL_X	; Get current X position
	jmp	OutChar_tail	; Continue in main code
	nop			; Pad to 8 bytes

;=============================================================================
; RST 4 - CompareHLDE
; Compares HL and DE with same logical results (Carry and Zero flags)
; as standard 8-bit compares. Returns Z if HL==DE.
;=============================================================================
CompareHLDE:
	mov	a,h		; Compare high bytes first
	sub	d
	rnz			; Return if high bytes differ
	mov	a,l		; Compare low bytes
	sub	e
	ret

; Terminal cursor position tracking
TERMINAL_Y:	db	01H	; Current Y position (row)
TERMINAL_X:	db	00H	; Current X position (column)

;=============================================================================
; RST 5 - FTestSign
; Tests sign of floating point accumulator (FACCUM).
; Returns: A=0 and Z set if FACCUM==0
;          A=0xFF and S set if negative
;          A=0x01 if positive
;=============================================================================
FTestSign:
	lda	FACCUM_EXP	; Get exponent byte of FACCUM
	ora	a		; Test if zero
	jnz	FTestSign_tail	; If not zero, determine sign
	ret			; Return with A=0, Z set

;=============================================================================
; RST 6 - PushNextWord (0x0030-0x0037)
; Effectively PUSH (HL). Pushes the 16-bit value pointed to by HL onto stack.
; Uses self-modifying code for the return jump.
; The first 8 bytes (RST 6 slot) set up and jump to continuation.
;=============================================================================
	xthl			; Get return address into HL
	shld	PushRetAddr	; Store return address for later jump
	pop	hl		; Restore original HL
	jmp	PushNextWord	; Continue at main code
;-----------------------------------------------------------------------------
; RST 7 slot (0x38-0x3A) - Data bytes for I/O patching
;-----------------------------------------------------------------------------
	ret			; RET opcode (used for I/O config)
	dw	0154H		; Additional I/O configuration bytes
;-----------------------------------------------------------------------------
; PushNextWord continuation (0x003B)
;-----------------------------------------------------------------------------
PushNextWord:
	mov	c,m		; Load low byte
	inx	hl
	mov	b,m		; Load high byte
	inx	hl		; Advance HL past the word
	push	bc		; Push the word onto stack
PushRet:
PushRetAddr	equ	$+1		; Self-modified: return address
	jmp	PushRet		; (operand patched at runtime)
;=============================================================================
; Function Pointer Tables for Inline Functions
; These are the math functions that can be used in expressions (SGN, INT, etc.)
;=============================================================================
KW_INLINE_FNS:
	dw	Sgn		; SGN - return sign of number
	dw	Int		; INT - truncate to integer
	dw	Abs		; ABS - absolute value
	dw	FunctionCallError ; USR - user function (not impl in 4K)
	dw	Sqr		; SQR - square root
	dw	Rnd		; RND - random number
SinEntry:
	db	0A0H		; Sin function entry byte
KW_INLINE_FNS_END:
	db	0CH		; End marker for inline functions

;=============================================================================
; Keyword String Table - exact bytes from reference binary
; Each keyword has its FIRST character with high bit set as start marker.
; Token values start at 80H for END, 81H for FOR, etc.
;=============================================================================
KEYWORDS:
	rdc	<END>
	rdc	<FOR>
	rdc	<NEXT>
	rdc	<DATA>
	rdc	<INPUT>
	rdc	<DIM>
	rdc	<READ>
	rdc	<LET>
	rdc	<GOTO>
	rdc	<RUN>
	rdc	<IF>
	rdc	<RESTORE>
	rdc	<GOSUB>
	rdc	<RETURN>
	rdc	<REM>
	rdc	<STOP>
	rdc	<PRINT>
	rdc	<LIST>
	rdc	<CLEAR>
	rdc	<NEW>
	rdc	<TAB(>
	rdc	<TO>
	rdc	<THEN>
	rdc	<STEP>
	rdc	<+>
	rdc	<->
	rdc	<*>
	rdc	</>
	rdc	<!>>
	rdc	<=>
	rdc	<!<>
	rdc	<SGN>
	rdc	<INT>
	rdc	<ABS>
	rdc	<USR>
	rdc	<SQR>
	rdc	<RND>
	rdc	<SIN>
	db	80h		; End of keyword table
;=============================================================================
; General Keyword Function Pointer Table
; Indexed by (token - 80H) * 2 to get function address
;=============================================================================
KW_GENERAL_FNS:
	dw	Stop		; 80 - END (same as STOP)
	dw	For		; 81 - FOR
	dw	Next		; 82 - NEXT
	dw	FindNextStatement ; 83 - DATA (skip to next statement)
	dw	Input		; 84 - INPUT
	dw	Dim		; 85 - DIM
	dw	Read		; 86 - READ
	dw	Let		; 87 - LET
	dw	Goto		; 88 - GOTO
	dw	Clear		; 89 - RUN (clear then run)
	dw	If		; 8A - IF
	dw	Restore		; 8B - RESTORE
	dw	Gosub		; 8C - GOSUB
	dw	Return		; 8D - RETURN
	dw	Rem		; 8E - REM
	dw	Stop		; 8F - STOP
	dw	Print		; 90 - PRINT
	dw	List		; 91 - LIST
	dw	ResetAll	; 92 - CLEAR
	dw	New		; 93 - NEW

;=============================================================================
; Arithmetic Operator Table
; Each entry: precedence (1 byte), function address (2 bytes)
;=============================================================================
KW_ARITH_OP_FNS:
	db	79H		; + precedence
	dw	FAddEntry	; + function (entry point with POP BC/DE)
	db	79H		; - precedence
	dw	FSubEntry	; - function (entry point with POP BC/DE)
	db	7CH		; * precedence (higher than +/-)
	dw	FMulEntry	; * function (entry point with POP BC/DE)
	db	7CH		; / precedence
	dw	FDivEntry	; / function (entry point with POP BC/DE)

;=============================================================================
; Error Code Table
; Two-character codes for each error type (indexed by error number)
;=============================================================================
ERROR_CODES:
	db	'NF'		; 00 - NEXT without FOR
	db	'SN'		; 02 - Syntax error
	db	'RG'		; 04 - RETURN without GOSUB
	db	'OD'		; 06 - Out of Data
	db	'FC'		; 08 - Illegal Function Call
	db	'OV'		; 0A - Overflow
	db	'OM'		; 0C - Out of Memory
	db	'UL'		; 0E - Undefined Line
	db	'BS'		; 10 - Bad Subscript
	db	'DD'		; 12 - Duplicate Definition
	db	'/0'		; 14 - Division by Zero
	db	'ID'		; 16 - Illegal Direct mode

;=============================================================================
; Global Variables
;=============================================================================
STACK_TOP:	dw	0F40H	; Highest memory address for stack
CURRENT_LINE:	dw	0FFFEH	; Line number being executed (FFFF = direct mode)
PROGRAM_BASE:	dw	0F41H	; Start of program storage
COMMA_PREFIX:	db	','	; Prefix for LINE_BUFFER (used by READ/INPUT)
LINE_BUFFER:	ds	8	; Input buffer (continues to 72 chars total)

;=============================================================================
; String Constants
;=============================================================================
szBytesFree:
	db	' BYTES FREE',0DH
szVersion:
	db	'4K BASIC 4.0',0DH
szCopyright:
	db	'COPYRIGHT MITS 1976',0
; Jump table for I/O routines (modified by Init for different hardware)
IO_WAIT_IN:	dw	0393H		; Wait for input ready routine
IO_GET_CHAR:	dw	0384H		; Get character routine
IO_PUT_CHAR:	dw	0481H		; Put character routine

; More global variables (initialized to 0)
	dw	0		; Reserved
RANDOM_SEED:	dw	0D69H		; Random number seed
EXPR_STACK:	dw	0D92H		; Expression evaluation stack pointer
	dw	0		; Reserved
	dw	0		; Reserved
	dw	0		; Reserved
	dw	0		; Reserved
	db	0		; Reserved (odd byte to match reference)
DIM_OR_EVAL:	db	0		; Flag: 0=evaluating, NZ=DIM'ing
INPUT_OR_READ:	db	0		; Flag: 0=INPUT, NZ=READ
PROG_PTR_TEMP:	dw	0		; Temporary program pointer
EXPR_PTR_TEMP:	dw	0		; Expression evaluator temp pointer
VAR_BASE:	dw	0		; Start of variable storage
VAR_ARRAY_BASE:	dw	0		; Start of array storage
VAR_TOP:	dw	0		; Top of variable/array storage
DATA_PROG_PTR:	dw	0		; Current DATA statement pointer

; Floating point accumulator (FACCUM) - 4 bytes
FACCUM:		db	0		; FACCUM byte 0 (low mantissa)
FACCUM_1:	db	0		; FACCUM byte 1
FACCUM_2:	db	0		; FACCUM byte 2 (high mantissa + sign)
FACCUM_EXP:	db	0		; FACCUM exponent

FTEMP_SIGN:	db	0		; Temp sign during FP operations

; FBUFFER - 13 byte buffer used by FOut and Sqr
FBUFFER:	ds	13		; Float output/sqrt buffer

;=============================================================================
; More String Constants
;=============================================================================
szError:
	db	' ERROR',0
szIn:
	db	' IN ',0
szOK:
	db	0DH,'OK',0DH,0
;=============================================================================
; GetFlowPtr - Find Flow Control Structure on Stack
; Sets HL to point to the appropriate flow struct (FOR/GOSUB) on stack.
; For NEXT, DE points to the loop variable to match against FOR structs.
; Returns with A = keyword ID byte (81H for FOR, 8CH for GOSUB)
;=============================================================================
GetFlowPtr:
	lxi	hl,4		; Skip past 2 return addresses on stack
	dad	sp		; HL = SP + 4
GetFlowLoop:
	mov	a,m		; Get keyword ID byte
	inx	hl		; Point to flow struct
	cpi	81H		; Is it FOR (81H)?
	rnz			; Return if not FOR (found GOSUB or end)
	; For FOR structs, check if variable matches
	rst	6		; Push (HL) = variable address from FOR
	xthl			; HL = variable address
	rst	4		; Compare HL with DE (NEXT's variable)
	lxi	bc,13		; Size of FOR flow struct
	pop	hl		; Restore HL
	rz			; Return if variables match
	dad	bc		; Skip to next flow struct
	jmp	GetFlowLoop	; Try next struct

;=============================================================================
; CopyMemoryUp - Copy Memory Block Upward
; Copies from HL to BC, going backwards (down) until HL==DE.
; Used to make room for inserting program lines.
;=============================================================================
CopyMemoryUp:
	call	CheckEnoughMemPushHL ; Entry at E5 byte (PUSH HL)
	push	bc		; Exchange BC and HL
	xthl
	pop	bc
CopyMemLoop:
	rst	4		; Compare HL and DE
	mov	a,m		; Get source byte
	stax	bc		; Store to destination
	rz			; Done when HL==DE
	dcx	bc		; Move backward
	dcx	hl
	jmp	CopyMemLoop

;=============================================================================
; CheckEnoughVarSpace - Check Variable Storage Space
; Checks that there's room for C*2 bytes on top of VAR_TOP before stack.
;=============================================================================
CheckEnoughVarSpace:
	push	hl
	lhld	VAR_TOP		; Get top of variable storage
	mvi	b,0		; BC = C * 2
	dad	bc
	dad	bc
; Fall through to CheckEnoughMem

;=============================================================================
; CheckEnoughMem - Check Stack Space
; Checks that HL is at least 32 bytes away from stack pointer.
; If not, falls through to OutOfMemory error.
;=============================================================================
CheckEnoughMem:
CheckEnoughMemPushHL	equ	$+1	; Entry +1: E5 byte executes as PUSH HL
	mvi	a,0E5H		; Calculate FFDE - HL (-34 bytes margin)
	mvi	a,0DEH		; (Self-modifying: first byte overwritten)
	sub	l
	mov	l,a
	mvi	a,0FFH
	sbb	h
	mov	h,a
	dad	sp		; Add stack pointer
	pop	hl
	rc			; Return if enough room (no carry)

;=============================================================================
; Error Entry Points
; Uses LXI trick: LXI B,xxxx is 01 xx xx, which skips over 2 bytes
;=============================================================================
OutOfMemory:
	mvi	e,0CH		; Error code 0C (OM - Out of Memory)
	db	01H		; LXI B opcode - skip next 2 bytes
SyntaxError:
	mvi	e,02H		; Error code 02 (SN - Syntax error)
	db	01H		; LXI B opcode - skip next 2 bytes
DivByZero:
	mvi	e,14H		; Error code 14 (/0 - Division by Zero)
;=============================================================================
; Error - Print Error Message and Return to Main Loop
; E = error code (offset into ERROR_CODES table)
;=============================================================================
Error:
	call	ResetStack	; Reset stack pointer
	call	NewLine		; Print newline
	lxi	hl,ERROR_CODES	; Point to error code table
	mov	d,a		; D = 0 (from NewLine)
	mvi	a,'?'		; Print '?'
	rst	3
	dad	de		; HL = ERROR_CODES + E
	mov	a,m		; Get first char of error code
	rst	3		; Print it
	rst	2		; Advance HL, get second char
	rst	3		; Print it
	lxi	hl,szError	; Point to " ERROR" string
	call	PrintStringLoop	; Print it (skip INX HL)
	lhld	CURRENT_LINE	; Get current line number
	mov	a,h		; Check if in direct mode (FFFF)
	ana	l
	inr	a		; A = 0 if FFFF (direct mode)
	cnz	PrintIN		; Print " IN <line>" if running program
	db	01H		; LXI B - skip next 2 bytes

;=============================================================================
; Stop / End - Stop Program Execution
; STOP and END keywords are synonymous
;=============================================================================
Stop:
	rnz			; Syntax error if arguments given
StopPop:
	pop	bc		; Discard return address
StopCont:
	mvi	a,0C1H		; (Placeholder byte - part of LXI trick)

;=============================================================================
; Main - The BASIC Prompt Loop
; Prints "OK", gets user input, and either executes or stores program lines
;=============================================================================
Main:
	lxi	hl,szOK		; Point to "\rOK\r" string
	call	Init		; First time: Init (patched to PrintString after)
;-----------------------------------------------------------------------------
; GetNonBlankLine - Get a line of input from the user
;-----------------------------------------------------------------------------
GetNonBlankLine:
	lxi	hl,0FFFFH	; Set line number to FFFF (direct mode)
	shld	CURRENT_LINE
	call	InputLine	; Get line of input
	rst	2		; Get first char
	inr	a		; Test if A==0 without affecting carry
	dcr	a		; (INR/DCR don't affect carry)
	jz	GetNonBlankLine	; Loop if blank line
	push	psw		; Save carry flag (set if first char is digit)
	call	LineNumberFromStr ; Try to parse line number into DE
	push	de		; Save line number
	call	Tokenize	; Tokenize the input line
	mov	b,a		; B = 0 (from Tokenize), BC = line length
	pop	de		; DE = line number
	pop	psw		; Restore carry flag
	jnc	Exec		; If no line number, execute immediately

;-----------------------------------------------------------------------------
; StoreProgramLine - Store a numbered line in program memory
;-----------------------------------------------------------------------------
StoreProgramLine:
	push	de		; Save line number
	push	bc		; Save line length
	rst	2		; Get first char of tokenized line
	ora	a		; Z set if line is empty (deleting line)
	push	psw		; Save empty-line flag
	call	FindProgramLine	; Find where line should go (BC=addr)
	push	bc		; Save line address
	jnc	InsertLine	; Jump if line doesn't exist yet

; Line exists - remove it first by moving rest of program down
RemoveLine:
	xchg			; DE = next line address
	lhld	VAR_BASE	; HL = end of program
RemoveLoop:
	ldax	de		; Copy byte from DE to BC
	stax	bc
	inx	bc
	inx	de
	rst	4		; Compare HL and DE
	jnz	RemoveLoop	; Loop until DE reaches VAR_BASE
	mov	h,b		; Update VAR_BASE
	mov	l,c
	shld	VAR_BASE

InsertLine:
	pop	de		; DE = line address
	pop	psw		; Restore empty-line flag
	jz	UpdateLinks	; If empty line, just update links
	; Make room for new line
	lhld	VAR_BASE	; HL = end of program
	xthl			; HL = line length, stack = VAR_BASE
	pop	bc		; BC = VAR_BASE
	dad	bc		; HL = new VAR_BASE
	push	hl
	call	CopyMemoryUp	; Move program up to make room
	pop	hl
	shld	VAR_BASE	; Update VAR_BASE
	xchg			; HL = line address
	mov	m,h		; Store (temporary) next-line pointer
	pop	de		; DE = line number
	inx	hl
	inx	hl
	mov	m,e		; Store line number (low)
	inx	hl
	mov	m,d		; Store line number (high)
	inx	hl
	; Copy tokenized line from buffer
	lxi	de,LINE_BUFFER
CopyLine:
	ldax	de		; Copy byte
	mov	m,a
	inx	hl
	inx	de
	ora	a		; Check for null terminator
	jnz	CopyLine

;-----------------------------------------------------------------------------
; UpdateLinks - Rebuild program line linked list
;-----------------------------------------------------------------------------
UpdateLinks:
	call	ClearVars	; Reset to start of program
	inx	hl
	xchg
UpdateLinkLoop:
	mov	h,d		; HL = current line
	mov	l,e
	mov	a,m		; Check for end of program
	inx	hl
	ora	m		; (next-line ptr is 0000)
	jz	GetNonBlankLine	; Done - go get next input
	inx	hl		; Skip line number
	inx	hl
	inx	hl
	xra	a		; Find end of line (null byte)
FindLineEnd:
	cmp	m
	inx	hl
	jnz	FindLineEnd
	xchg			; DE = next line address
	mov	m,e		; Store next-line pointer
	inx	hl
	mov	m,d
	jmp	UpdateLinkLoop
;=============================================================================
; FindProgramLine - Find Program Line by Number
; Input: DE = line number to find
; Output: BC = address of line (or where it should be inserted)
;         Carry set if line exists, clear if not found
;         HL = address of next line (if line exists)
;=============================================================================
FindProgramLine:
	lhld	PROGRAM_BASE	; Start at beginning of program
FindLineLoop:
	mov	b,h		; BC = current line address
	mov	c,l
	mov	a,m		; Check for end of program
	inx	hl
	ora	m		; (next-line ptr is 0000)
	dcx	hl
	rz			; Return if end of program (line not found)
	push	bc		; Save current line address
	rst	6		; Push next-line address
	rst	6		; Push line number
	pop	hl		; HL = line number from program
	rst	4		; Compare with DE (wanted line number)
	pop	hl		; HL = next line address
	pop	bc		; BC = current line address
	cmc			; Complement carry
	rz			; Return if line numbers match (found)
	cmc			; Restore carry
	rnc			; Return if current > wanted (not found)
	jmp	FindLineLoop	; Try next line

;=============================================================================
; New - NEW Command - Clear Program Memory
;=============================================================================
New:
	rnz			; Syntax error if arguments
; Fall through to Run for initialization
Run:
	lhld	PROGRAM_BASE	; Get program base
	xra	a		; Write null terminator (empty program)
	mov	m,a
	inx	hl
	mov	m,a
	inx	hl
	shld	VAR_BASE	; VAR_BASE = just after program

;=============================================================================
; Clear - CLEAR/RUN Command - Reset Variables
;=============================================================================
Clear:
	rnz			; Syntax error if arguments
ClearVars:
	lhld	PROGRAM_BASE	; Get program base
	dcx	hl		; Point to byte before program

;=============================================================================
; ResetAll - Reset All Variables and Pointers
;=============================================================================
ResetAll:
	shld	PROG_PTR_TEMP	; Save program pointer
	call	Restore		; Reset DATA pointer
	lhld	VAR_BASE	; Reset variable pointers
	shld	VAR_ARRAY_BASE	; No arrays yet
	shld	VAR_TOP		; No variables yet

;=============================================================================
; ResetStack - Reset Stack Pointer
;=============================================================================
ResetStack:
	pop	bc		; Get return address
	lhld	STACK_TOP	; Get stack top
	sphl			; Reset stack pointer
	xra	a		; Push 0 on stack (stack marker)
	mov	l,a
	push	hl
	push	bc		; Put return address back
	lhld	PROG_PTR_TEMP	; Restore program pointer
	ret
;=============================================================================
; InputLineWithPrompt - Get Input with "? " Prompt
; Used by INPUT statement
;=============================================================================
InputLineWithQ:
InputLineWithPrompt:
	mvi	a,'?'		; Print "? " prompt
	rst	3
	mvi	a,' '
	rst	3
	call	InputLine	; Get line of input
	inx	hl		; Point past comma prefix

;=============================================================================
; Tokenize - Convert Input Line to Tokenized Form
; Replaces keywords with single-byte tokens.
; Input: HL points to input buffer
; Output: C = length of tokenized line + overhead, A = 0
;=============================================================================
Tokenize:
	mvi	c,5		; Initialize length (4 bytes header + 1)
	lxi	de,LINE_BUFFER	; Output pointer
TokenLoop:
	mov	a,m		; Get input character
	cpi	' '		; Space?
	jz	WriteChar	; Just write spaces
	mov	b,a		; Save char in B
	cpi	'"'		; Quote (string literal)?
	jz	FreeCopy	; Copy string without tokenizing
	ora	a		; Null terminator?
	jz	TokenExit	; Exit if end of input
	; Try to match a keyword
	push	de		; Save output pointer
	lxi	de,KEYWORDS-1	; Point to keyword table
	push	bc		; Save current char
	mvi	b,7FH		; Initialize keyword ID counter
TryNextKeyword:
	mov	c,m		; Get input char (redundant but part of original)
	mov	c,m
	xchg			; HL = keyword ptr, DE = input ptr
NextKeyword:
	inx	hl		; Advance to next keyword char
	ora	m		; Check for end of keyword (bit 7 set)
	jp	NextKeyword	; Loop if not end of keyword yet
	; Found end of keyword - advance to next keyword
	inr	b		; Increment keyword ID
	mov	a,m		; Get keyword char
	ani	7FH		; Mask off bit 7
	jz	NotKeywordNoSwap ; If zero, end of keyword table
	cmp	c		; Compare to input char
	jnz	NextKeyword	; Try next keyword if no match
	; First char matches - check rest of keyword
	xchg			; DE = keyword ptr, HL = input ptr
	push	hl		; Save input position
KwCompare:
	inx	de		; Advance keyword ptr
	ldax	de		; Get keyword char
	ora	a		; Check bit 7 (end of keyword)
	jm	KwMatch		; Jump if matched entire keyword
	mov	c,a		; Save keyword char
	rst	2		; Get next input char
	cmp	c		; Compare
	jz	KwCompare	; Continue if match
	pop	hl		; Restore input position
	jmp	TryNextKeyword	; Try next keyword

KwMatch:
	; Keyword matched - B has keyword ID (with bit 7 already set)
	mov	c,b		; Save keyword ID in C
	; Fall through to cleanup code
NotKeyword_cleanup:
	pop	psw		; Clean up stack (discard saved position)
NotKeyword:
	; Entry point when keyword not found (jumps here skipping MOV C,B; POP PSW)
	xchg			; Restore pointers
NotKeywordNoSwap:			; Entry +1: skip first XCHG (end of table case)
	xchg
	mov	a,c		; A = character/keyword to output
	pop	bc		; Restore saved BC
	pop	de		; Restore output pointer
WriteToken:
WriteChar:
	inx	hl		; Advance input pointer
	stax	de		; Store character/token to output
	inx	de		; Advance output pointer
	inr	c		; Increment length counter
	; Check if we just wrote REM token
	sui	8EH		; REM token?
	jnz	TokenLoop	; No - continue tokenizing
	mov	b,a		; B = 0 (terminator for FreeCopy)
; Free copy loop - copy without tokenizing (for strings and REM)
FreeCopyLoop:
	mov	a,m		; Get character
	ora	a		; Null terminator?
	jz	TokenExit	; Exit if end
	cmp	b		; Terminator character?
	jz	WriteChar	; If so, write it and resume tokenizing
FreeCopy:
	inx	hl		; Advance input
	stax	de		; Copy character
	inr	c		; Increment length
	inx	de
	jmp	FreeCopyLoop

TokenExit:
	lxi	hl,COMMA_PREFIX	; Point to comma before LINE_BUFFER
	stax	de		; Write three null terminators
	inx	de
	stax	de
	inx	de
	stax	de
	ret

;=============================================================================
; InputLine - Get a Line of Input from Terminal
; Handles backspace ('_') and line cancel ('@')
; Output: HL = LINE_BUFFER
;=============================================================================
Backspace:
	dcr	b		; Decrement char count
	dcx	hl		; Back up pointer
	rst	3		; Echo backspace char
	jnz	InputNext	; Continue if not at start
LineCancel:
	rst	3		; Echo cancel char
	call	NewLine		; Print newline
InputLine:
	lxi	hl,LINE_BUFFER	; Point to input buffer
	mvi	b,1		; Initialize char count
InputNext:
	call	GetChar		; Get character from terminal
	mov	c,a		; Save in C
	cpi	0DH		; Carriage return?
	jz	TerminateInput	; Done if CR
	cpi	'@'		; Line cancel?
	jz	LineCancel
	cpi	'_'		; Backspace?
	jz	Backspace
	cpi	' '		; Control char?
	jc	InputNext	; Ignore if < space
	cpi	7DH		; DEL or higher?
	jnc	InputNext	; Ignore if >= 7D
	; Valid character - store it
	mov	a,b		; Check line length
	cpi	72		; Buffer full?
	mvi	a,07H		; Bell character
	jnc	EchoChar	; Ring bell if full
	mov	a,c		; Get character back
	mov	m,c		; Store in buffer
	inx	hl		; Advance pointer
	inr	b		; Increment count
EchoChar:
	rst	3		; Echo character
	jmp	InputNext	; Get next character

;=============================================================================
; I/O Routines (hardware-dependent, modified by Init)
;=============================================================================
OutChar_tail:
	cpi	72		; Check column position
TERMINAL_WIDTH	equ	OutChar_tail+1	; Terminal width operand (patched by Init)
	cz	NewLine		; Newline if at end
	inr	a		; Increment column
	sta	TERMINAL_X	; Save column
WaitTxReady:
	in	00H		; Check transmit ready (port 0 status)
D0385	equ	WaitTxReady+1	; Port number operand (patched by Init)
	ani	0C8H		; Mask ready bit
D0387	equ	WaitTxReady+3	; Mask operand (patched by Init)
	jnz	WaitTxReady	; Wait until ready
	pop	psw		; Restore character
	out	01H		; Send character (port 1 data)
D038D	equ	WaitTxReady+9	; Port number operand (patched by Init)
	push	psw		; Save again
D038F	equ	WaitTxReady+11	; IN opcode location (patched by Init)
	in	13H		; Check for paper tape mode
	pop	psw
	ret

;-----------------------------------------------------------------------------
; GetChar - Get Character from Terminal
;-----------------------------------------------------------------------------
GetChar:
GetChar_tail:                   ; Alias for code that calls GetChar_tail
	in	00H		; Check receive ready (port 0 status)
	ani	01H		; Mask ready bit
	jnz	GetChar		; Wait until ready
	in	01H		; Get character (port 1 data)
	ani	7FH		; Strip high bit
	ret
;=============================================================================
; LIST Handler
; Lists the program. As the stored program is in tokenised form (keywords are
; single-byte IDs), LIST decodes tokens back to keyword strings for display.
;=============================================================================
List:
	call	LineNumberFromStr	; Get line number argument into DE
	rnz			; Return if non-numeric argument
	pop	bc		; Discard return address (we loop ourselves)
	call	FindProgramLine	; Find starting line, BC=line addr
	push	bc		; Save line address
;-----------------------------------------------------------------------------
; ListNextLine - Loop through program lines
;-----------------------------------------------------------------------------
ListNextLine:
	pop	hl		; HL = current program line address
	rst	6		; Push (HL), (HL+1) - next line pointer
	pop	bc		; BC = next line address
	mov	a,b		; Check if next line is null (end of program)
	ora	c
	jz	Main		; Exit to Main if at end
	call	TestBreakKey	; Allow user to break listing
	push	bc		; Save next line address
	call	NewLine		; Print newline
	rst	6		; Push line number
	xthl			; HL=line number, (SP)=prog ptr
	call	PrintInt	; Print line number
	mvi	a,' '		; Prepare to print space
	pop	hl		; HL = program line content pointer
;-----------------------------------------------------------------------------
; ListChar - Print characters, expanding tokens to keywords
; This code uses overlapping instructions and must be exact bytes.
; The keyword expansion loop uses DE throughout (no PUSH/POP).
;-----------------------------------------------------------------------------
ListChar:
	rst	3		; DF - Print character in A
ListCharNext:				; Entry +1: skip RST 3 (char already printed)
	mov	a,m		; 7E - Get next character
	ora	a		; B7 - Test for null (end of line)
	inx	hl		; 23 - Advance pointer
	jz	ListNextLine	; CA xx xx - If null, go to next line
	jp	ListChar	; F2 xx xx - If bit 7 clear, continue
	; Bit 7 set - keyword token handler (overlapping instruction trick)
	sui	07fh		; Convert token to index
	mov	c,a		; Save count in C
	lxi	d,KEYWORDS
ToNextKeyword:
	ldax	d		; Get keyword char
	inx	d		; Advance
	ora	a		; Test bit 7
	jp	ToNextKeyword	; Loop until bit 7 set (end of keyword)
	dcr	c		; Decrement counter
	jnz	ToNextKeyword	; If not found, keep searching
PrintKeyword:
	rst	3		; Print char
	ldax	d		; Get next keyword char
	inx	d		; Advance
	ora	a		; Test bit 7
	jp	PrintKeyword	; Loop until bit 7 set
	jmp	ListCharNext	; Back to main loop, skip RST 3
;=============================================================================
; FOR Handler
; Although FOR indicates the beginning of a loop, the handler only gets called
; once. Subsequent iterations return to the statement AFTER FOR, not to FOR.
; FOR sets up a flow control structure (13 bytes) on the stack:
;   - 1 byte: KWID_FOR (81H)
;   - 2 bytes: loop variable address
;   - 4 bytes: STEP value (floating point)
;   - 1 byte: direction (01=forward, FF=backward)
;   - 4 bytes: TO value (limit, floating point)
;   - 2 bytes: line number of FOR statement
;   - 2 bytes: program pointer after FOR statement
;=============================================================================
For:
	call	Let		; Assign initial value to loop variable
	xthl			; Swap prog ptr with return addr
	call	GetFlowPtr	; Check for existing FOR with same var
	pop	de		; DE = program pointer
	jnz	ForNoReuse	; If no existing FOR, skip cleanup
	dad	bc		; HL = old SP + struct size (remove old struct)
	sphl			; Clean up old FOR structure
ForNoReuse:
	xchg			; HL = prog ptr, DE = stack ptr
	mvi	c,08H		; Check for 8*4=32 bytes stack space
	call	CheckEnoughVarSpace
	push	hl		; Save program pointer
	call	FindNextStatement	; Find end of FOR statement
	xthl			; Swap: (SP)=stmt end, HL=prog ptr
	push	hl		; Push program pointer
	lhld	CURRENT_LINE	; Get current line number
	xthl			; Swap: (SP)=line number, HL=prog ptr
	rst	1		; Syntax check for 'TO' token
	db	95H		; Token for TO
;-----------------------------------------------------------------------------
; Parse TO value and push onto stack
;-----------------------------------------------------------------------------
	call	ArithParse	; Evaluate TO expression
	push	hl		; Save program pointer
	call	FCopyToBCDE	; Get TO value into BCDE
	pop	hl		; Restore program pointer
	push	bc		; Push TO value (high word)
	push	de		; Push TO value (low word)
	; Initialize STEP value to 1.0 (8100 0000 = 1.0)
	lxi	bc,8100H	; B=81H (exponent), C=00
	mov	d,c		; D=00
	mov	e,d		; E=00
	; Check for optional STEP clause
	mov	a,m		; Get next token
	cpi	97H		; Is it STEP token?
	mvi	a,01H		; Default direction = forward
	jnz	PushStepValue	; If no STEP, use default 1.0
	; STEP clause present - evaluate it
	call	ArithParseLoop	; Skip token and evaluate STEP
	push	hl		; Save program pointer
	call	FCopyToBCDE	; Get STEP value into BCDE
	rst	5		; Test sign of STEP (sets A to direction)
	pop	hl		; Restore program pointer
PushStepValue:
	push	bc		; Push STEP value (high word)
	push	de		; Push STEP value (low word)
	push	psw		; Push direction byte (1 or -1)
	inx	sp		; Adjust SP (only push 1 byte)
	push	hl		; Push program pointer
	lhld	PROG_PTR_TEMP	; Get loop variable address
	xthl			; Swap: (SP)=var addr, HL=prog ptr
;-----------------------------------------------------------------------------
; EndOfForHandler - Push FOR token and fall into ExecNext
; This is the entry point for NEXT to re-enter a FOR loop
;-----------------------------------------------------------------------------
EndOfForHandler:
	mvi	b,81H		; FOR token ID
	push	bc		; Push token byte
	inx	sp		; Adjust SP (only push 1 byte)
;=============================================================================
; ExecNext - Execute next statement
; Having executed one statement, moves to the next statement on the line
; or to the next line if there are no more statements.
;=============================================================================
ExecNext:
	call	TestBreakKey	; Give user chance to break execution
	mov	a,m		; Get current character
	cpi	':'		; Is it statement separator?
	jz	Exec		; If colon, execute next statement
	ora	a		; Is it null (end of line)?
	jnz	SyntaxError	; If not null or colon, syntax error
	; End of line - move to next line
	inx	hl		; Skip null terminator
	mov	a,m		; Get low byte of next line address
	inx	hl
	ora	m		; OR with high byte
	jz	StopCont	; If both zero, end of program
	; More program lines exist
	inx	hl		; Point to line number
	mov	e,m		; Get line number low byte
	inx	hl
	mov	d,m		; Get line number high byte
	xchg			; HL = line number
	shld	CURRENT_LINE	; Store current line number
	xchg			; HL = program pointer
;-----------------------------------------------------------------------------
; Exec - Execute a statement of BASIC code pointed to by HL
;-----------------------------------------------------------------------------
Exec:
	rst	2		; Get first character of statement
	lxi	de,ExecNext	; Return address after statement
	push	de		; Push return address
ExecStatement:
	rz			; Return if empty statement
	sui	80H		; Subtract keyword base
	jc	Let		; If < 80H, implicit LET statement
	cpi	14H		; Is it a general keyword (0-19)?
	jnc	SyntaxError	; If >= 20, syntax error
	; Look up keyword handler in function table
	rlc			; Multiply by 2 (word table)
	mov	c,a		; BC = offset into table
	mvi	b,00H
	xchg			; DE = program pointer
	lxi	hl,KW_GENERAL_FNS	; HL = function table
	dad	bc		; HL = pointer to function address
	mov	c,m		; Get function address low byte
	inx	hl
	mov	b,m		; Get function address high byte
	push	bc		; Push function address
	xchg			; HL = program pointer
	rst	2		; Get next character
	ret			; Jump to keyword handler
;-----------------------------------------------------------------------------
; NextChar_tail - Continuation of RST 2 (NextChar)
; Skips spaces, sets carry if char >= '0', sets Z if char is null
;-----------------------------------------------------------------------------
NextChar_tail:
	cpi	' '		; Is it a space?
	jz	NextChar	; If space, get next char
	cpi	'0'		; Compare to '0'
	cmc			; Complement carry (C set if digit)
	inr	a		; Set Z flag if A was 0
	dcr	a		; (without changing A)
	ret
;-----------------------------------------------------------------------------
; RESTORE Handler
; Resets the DATA pointer to just before the start of the program
;-----------------------------------------------------------------------------
Restore:
	xchg			; Save HL in DE
	lhld	PROGRAM_BASE	; Get start of program
	dcx	hl		; Point to byte before program
SaveDataPtr:
	shld	DATA_PROG_PTR	; Store as DATA pointer
	xchg			; Restore HL
	ret
;-----------------------------------------------------------------------------
; TestBreakKey - Check if user pressed Ctrl-C to break
; Returns if no key or non-break key, jumps to Stop if Ctrl-C
;-----------------------------------------------------------------------------
TestBreakKey:
	in	00H		; Check if key pressed
	ani	01H		; Mask ready bit
	rnz			; Return if no key
	call	GetChar_tail	; Get the character
	cpi	03H		; Is it Ctrl-C (break)?
	jz	Stop		; If so, stop program
	; Fall through to CharIsAlpha (which returns to caller)
;-----------------------------------------------------------------------------
; CharIsAlpha - Check if character at (HL) is alphabetic
; Returns: Carry clear if A-Z, Carry set otherwise
;-----------------------------------------------------------------------------
CharIsAlpha:
	mov	a,m		; Get character
	cpi	'A'		; Compare to 'A'
	rc			; Return with carry if < 'A'
	cpi	'Z'+1		; Compare to 'Z'+1
	cmc			; Complement carry
	ret
;-----------------------------------------------------------------------------
; GetSubscript - Get array subscript as positive integer
; Evaluates expression and returns integer value in CDE
;-----------------------------------------------------------------------------
GetSubscript:
	rst	2		; Get next character
	call	ArithParse	; Evaluate expression
	rst	5		; Test sign of result
	jm	FunctionCallError	; Error if negative
	lda	FACCUM+3	; Get exponent
	cpi	90H		; Check if > 32767
	jc	FCompare	; Convert to integer if valid
FunctionCallError:
	mvi	e,08H		; FC - Function Call error
	jmp	Error
;=============================================================================
; LineNumberFromStr - Parse line number from string
; Input: HL = string pointer
; Output: DE = line number (0-65529), Z flag set if valid number found
; Returns NZ if string doesn't start with a digit
; Maximum line number is 65529 (errors if > 6552 before last digit)
;=============================================================================
LineNumberFromStr:
	dcx	hl		; Back up to get char before current
	lxi	de,0		; Initialize result to 0
NextLineNumChar:
	rst	2		; Get next non-space character
	rnc			; Return if not a digit (NC means < '0')
	push	hl		; Save string pointer
	push	psw		; Save digit character
	lxi	hl,6552		; Check if result > 6552
	rst	4		; Compare HL to DE
	jc	SyntaxError	; Error if > 6552 (result would be > 65529)
	; Multiply current result by 10: DE = DE*10
	mov	h,d		; HL = DE
	mov	l,e
	dad	de		; HL = DE*2
	dad	hl		; HL = DE*4
	dad	de		; HL = DE*5
	dad	hl		; HL = DE*10
	; Add new digit
	pop	psw		; Restore digit character
	sui	'0'		; Convert ASCII to value
	mov	e,a		; DE = digit value
	mvi	d,00H
	dad	de		; HL = result*10 + digit
	xchg			; DE = new result
	pop	hl		; Restore string pointer
	jmp	NextLineNumChar	; Continue parsing
;=============================================================================
; GOSUB Handler
; Sets up a flow control structure on stack and falls into GOTO.
; Stack structure: KWID_GOSUB (8CH), line number (2), prog ptr (2)
;=============================================================================
Gosub:
	mvi	c,03H		; Need 3 words (6 bytes) stack space
	call	CheckEnoughVarSpace
	pop	bc		; Preserve return address
	push	hl		; Push program pointer
	push	hl		; Push again (will become line number)
	lhld	CURRENT_LINE	; Get current line number
	xthl			; Swap with stacked prog ptr
	mvi	a,8CH		; KWID_GOSUB token
	push	psw		; Push token (high byte)
	inx	sp		; Adjust SP (only pushed 1 byte)
	push	bc		; Push return address
	; Fall through to GOTO
;=============================================================================
; GOTO Handler
; Sets program execution to continue from the line number argument.
;=============================================================================
Goto:
	call	LineNumberFromStr	; Get target line number in DE
	rnz			; Return (error) if no line number
	call	FindProgramLine	; Find the line, BC = address
	mov	h,b		; HL = line address
	mov	l,c
	dcx	hl		; Adjust (FindProgramLine returns +1)
	rc			; Return if line found (carry set)
	mvi	e,0EH		; UL - Undefined Line error
	jmp	Error
;=============================================================================
; RETURN Handler
; Returns program execution to statement after the last GOSUB.
; Information about where to return is kept in flow struct on stack.
;=============================================================================
Return:
	rnz			; No arguments allowed
	mvi	d,0FFH		; Search for any flow struct (not FOR)
	call	GetFlowPtr	; Find flow structure on stack
	sphl			; Set SP to flow structure
	cpi	8CH		; Is it KWID_GOSUB?
	mvi	e,04H		; RG - Return without Gosub error
	jnz	Error		; Error if not GOSUB
	pop	hl		; Get saved line number
	shld	CURRENT_LINE	; Restore current line
	lxi	hl,ExecNext	; Set return to ExecNext
	xthl			; Swap with prog ptr, HL = prog ptr
	; Fall through to FindNextStatement
;=============================================================================
; FindNextStatement - Find end of statement or end of line
; Uses LXI trick: entered normally, C=':' (colon)
; Scans forward until null or C character found
;=============================================================================
FindNextStatement:
	db	01H		; LXI B opcode - skip next 2 bytes
	db	':'		; Statement separator (skipped)
;-----------------------------------------------------------------------------
; REM Handler - Entry point when REM keyword encountered
; Uses MVI C,00 to scan for null only (skip rest of line)
;-----------------------------------------------------------------------------
Rem:
	mvi	c,00H		; Scan for null terminator only
FindStmtLoop:
	mov	a,m		; Get character
	ora	a		; Is it null?
	rz			; Return if end of line
	cmp	c		; Is it the target character?
	rz			; Return if found
	inx	hl		; Advance pointer
	jmp	FindStmtLoop	; Keep scanning
;=============================================================================
; LET Handler
; Assigns a value to a variable. LET A=5 or just A=5 (implicit LET)
;=============================================================================
Let:
	call	GetVar		; Get variable address in DE
	rst	1		; Syntax check for '='
	db	9DH		; Token for '='
;-----------------------------------------------------------------------------
; AssignVar - Assign expression result to variable at DE
; Input: DE = variable address, HL = expression to evaluate
;-----------------------------------------------------------------------------
AssignVar:
	push	de		; Save variable address
	call	ArithParse	; Evaluate expression into FACCUM
	xthl			; HL = var addr, (SP) = prog ptr
	shld	PROG_PTR_TEMP	; Save var addr (for FOR loop detection)
	push	hl		; Save var address
	call	FCopyToMem	; Copy FACCUM to variable
	pop	de		; DE = var address
	pop	hl		; HL = program pointer
	ret
;=============================================================================
; IF Handler
; Evaluates a condition (lhs <op> rhs) where <op> is >, =, <, or combination
; Comparison operators are converted to a bitmask:
;   bit 0 = '>' present, bit 1 = '=' present, bit 2 = '<' present
; So <= and =< both equal 6, >= and => equal 3, <> equals 5
;=============================================================================
If:
	call	ArithParse	; Evaluate left-hand side expression
	mov	a,m		; Get first char of comparison operator
	call	FPush		; Push LHS value onto stack
	mvi	d,00H		; D = comparison operator bitmask
GetCompareOpLoop:
	sui	9CH		; Subtract KWID_> (9C=>, 9D==, 9E=<)
	jc	GotCompareOp	; Exit loop if not a comparison token
	cpi	03H		; Check if it's one of the 3 comp ops
	jnc	GotCompareOp	; Exit if not
	; Set the appropriate bit in D
	cpi	01H		; Compare to '=' offset
	ral			; Rotate carry into bit 0
	ora	d		; OR with existing bits
	mov	d,a		; Save updated bitmask
	rst	2		; Get next character
	jmp	GetCompareOpLoop
GotCompareOp:
	mov	a,d		; Get comparison bitmask
	ora	a		; Any comparison operators?
	jz	SyntaxError	; Error if no comparison operator
	push	psw		; Save comparison bitmask
	call	ArithParse	; Evaluate right-hand side
	rst	1		; Syntax check for THEN
	db	96H		; Token for THEN
	dcx	hl		; Back up pointer
	pop	psw		; Restore comparison bitmask
	pop	bc		; Pop LHS high word
	pop	de		; Pop LHS low word
	push	hl		; Save program pointer
	push	psw		; Save comparison bitmask
	call	FCompareWithBCDE ; Compare LHS to RHS (result in A)
	; Convert FCompare result (-1,0,1) to bit pattern and test
	inr	a		; -1->0, 0->1, 1->2
	ral			; 0->0, 1->2, 2->4 (bits 0,1,2)
	pop	bc		; B = comparison bitmask
	ana	b		; Test if result matches required comparison
	pop	hl		; Restore program pointer
	jz	Rem		; If false, skip rest of line (like REM)
	; Condition is true - execute THEN clause
	rst	2		; Get first char after THEN
	jc	Goto		; If digit, implicit GOTO
	jmp	ExecStatement	; Otherwise execute statement
;-----------------------------------------------------------------------------
; PrintLoop re-entry point (backs up and gets next char)
;-----------------------------------------------------------------------------
PrintLoopEntry:
	dcx	hl		; Back up pointer
	rst	2		; Get next character
;=============================================================================
; PRINT Handler
; Prints expressions, string literals, with optional formatting (TAB, comma, ;)
;=============================================================================
Print:
	jz	NewLine		; If end of line, just print newline
PrintLoop:
	rz			; Return if end of statement
	cpi	'"'		; String literal?
	cz	PrintString	; Print string if so
	jz	PrintLoopEntry	; Loop back for more
	cpi	94H		; TAB( keyword?
	jz	Tab		; Handle TAB function
	push	hl		; Save program pointer
	cpi	','		; Comma (tab to next zone)?
	jz	ToNextTabBreak	; Handle comma
	cpi	';'		; Semicolon (no spacing)?
	jz	ExitTab		; Just continue (no spacing)
	; Must be an expression to print
	pop	bc		; Discard saved pointer
	call	ArithParse	; Evaluate expression
	push	hl		; Save program pointer
	call	FOut		; Convert FACCUM to string
	call	PrintStringLoop	; Print the string
	mvi	a,' '		; Print trailing space
	rst	3
	pop	hl		; Restore program pointer
	jmp	PrintLoopEntry	; Continue with more print items
;-----------------------------------------------------------------------------
; TerminateInput - End input line with null and reset pointer
;-----------------------------------------------------------------------------
TerminateInput:
	mvi	m,00H		; Write null terminator
	lxi	hl,COMMA_PREFIX	; Point to comma before LINE_BUFFER
;-----------------------------------------------------------------------------
; NewLine - Print CR/LF plus trailing nulls for teletype timing
;-----------------------------------------------------------------------------
NewLine:
	mvi	a,0DH		; Carriage return
	sta	TERMINAL_X	; Reset column counter
	rst	3		; Print CR
	mvi	a,0AH		; Line feed
	rst	3		; Print LF
	lda	TERMINAL_Y	; Get null count for timing
PrintNullLoop:
	dcr	a		; Decrement counter
	sta	TERMINAL_X	; Store as column position
	rz			; Return when done
	push	psw		; Save counter
	xra	a		; A = 0 (null character)
	rst	3		; Print null
	pop	psw		; Restore counter
	jmp	PrintNullLoop	; Loop
;-----------------------------------------------------------------------------
; PrintString - Print string literal (stops at null or closing quote)
;-----------------------------------------------------------------------------
PrintString:
	inx	hl		; Skip opening quote
PrintStringLoop:
	mov	a,m		; Get character
	ora	a		; Null terminator?
	rz			; Return if end
	inx	hl		; Advance pointer
	cpi	'"'		; Closing quote?
	rz			; Return if end of string
	rst	3		; Print character
	cpi	0DH		; Carriage return?
	cz	NewLine		; If CR, do full newline
	jmp	PrintStringLoop	; Continue
;-----------------------------------------------------------------------------
; ToNextTabBreak - Move to next 14-column tab zone (comma handler)
;-----------------------------------------------------------------------------
ToNextTabBreak:
	lda	TERMINAL_X	; Get current column
	cpi	56		; Past last tab zone?
	cnc	NewLine		; If so, go to new line
	jnc	ExitTab		; And continue
CalcSpaceCount:
	sui	14		; Subtract zone width
	jnc	CalcSpaceCount	; Loop until negative
	cma			; A = spaces to next zone - 1
	jmp	PrintSpaceLoop	; Print the spaces
;-----------------------------------------------------------------------------
; TAB Handler - Tab to absolute column position
; TAB(n) moves to column n
;-----------------------------------------------------------------------------
Tab:
	call	GetSubscript	; Get column number in E
	rst	1		; Syntax check for ')'
	db	')'
PrintSpaces:
	dcx	hl		; Back up pointer
	push	hl		; Save program pointer
	lda	TERMINAL_X	; Get current column
	cma			; Negate
	add	e		; Add target column
	jnc	ExitTab		; If already past target, skip
PrintSpaceLoop:
	inr	a		; A = number of spaces to print
	mov	b,a		; B = counter
	mvi	a,' '		; Space character
PrintSpaceInner:
	rst	3		; Print space
	dcr	b		; Decrement counter
	jnz	PrintSpaceInner	; Loop until done
ExitTab:
	pop	hl		; Restore program pointer
	rst	2		; Get next character
	jmp	PrintLoop	; Continue printing
;=============================================================================
; INPUT Handler
; Lets user input values at a '?' prompt. INPUT only works in program mode.
;=============================================================================
Input:
	push	hl		; Save program pointer
	lhld	CURRENT_LINE	; Get current line number
	mvi	e,16H		; ID - Illegal Direct mode error
	inx	hl		; Check if line# = FFFF (direct mode)
	mov	a,l
	ora	h
	jz	Error		; Error if in direct mode
	call	InputLineWithPrompt	; Get user input
	jmp	InputReadCommon	; Join common code
;=============================================================================
; READ Handler
; Reads data from DATA statements in the program
;=============================================================================
Read:
	push	hl		; Save program pointer
	lhld	DATA_PROG_PTR	; Get current DATA pointer
InputReadCommon	equ	$+1	; Entry at AF byte = XRA A (clears A for INPUT)
	ori	0AFH		; Set A to non-zero (marks as READ)
;-----------------------------------------------------------------------------
; Common code for INPUT and READ
; A=0 for INPUT, A<>0 for READ
;-----------------------------------------------------------------------------
	sta	INPUT_OR_READ	; Store INPUT/READ flag
	xthl			; HL=prog ptr, (SP)=data ptr
	db	01H		; LXI B - skip next 2 bytes
ReadNext:
	rst	1		; Syntax check for comma
	db	','
	call	GetVar		; Get variable address in DE
	xthl			; HL=data ptr, (SP)=prog ptr
	push	de		; Save variable address
	; Check what's at data pointer
	mov	a,m		; Get data character
	cpi	','		; Is it comma separator?
	jz	GotDataItem	; If comma, we have data
	ora	a		; Is it null (end of line)?
	jnz	SyntaxError	; Error if not null or comma
	; Need more data
	lda	INPUT_OR_READ	; Check if INPUT or READ
	ora	a
	inx	hl		; Advance past null
	jnz	ScanForData	; If READ, find next DATA line (skip POP HL)
	; INPUT needs another '?' prompt
	mvi	a,'?'		; Print question mark
	rst	3
	call	InputLineWithPrompt	; Get more input
GotDataItem:
	pop	de		; Restore variable address
	inx	hl		; Skip comma/advance to data
	call	AssignVar	; Assign data to variable
	xthl			; HL=prog ptr, (SP)=data ptr
	dcx	hl		; Back up (AssignVar advanced it)
	rst	2		; Get next character
	jnz	ReadNext	; If more vars, continue
	; Done with all variables
	pop	de		; DE = data pointer
	lda	INPUT_OR_READ	; Check if INPUT or READ
	ora	a
	rz			; Return if INPUT
	xchg			; HL = data pointer
	jnz	SaveDataPtr	; Save new DATA pointer
;-----------------------------------------------------------------------------
; NextDataLine - Scan for next DATA statement
;-----------------------------------------------------------------------------
NextDataLine:
	pop	hl		; Get current position
ScanForData:
	rst	6		; Get next line address
	mov	a,c		; Check if end of program
	ora	b
	mvi	e,06H		; OD - Out of Data error
	jz	Error		; Error if no more lines
	inx	hl		; Skip line number
	rst	2		; Get first keyword
	cpi	83H		; Is it DATA keyword?
	jnz	NextDataLine	; If not, try next line
	pop	bc		; Discard saved pointer
	jmp	GotDataItem	; Found DATA, get item
;=============================================================================
; NEXT Handler
; Increments FOR loop variable and tests against limit.
; If loop not complete, jumps back to statement after FOR.
; If complete, removes FOR structure from stack and continues.
;=============================================================================
Next:
	call	GetVar		; Get loop variable address in DE
	shld	PROG_PTR_TEMP	; Save prog ptr (end of NEXT stmt)
	call	GetFlowPtr	; Find FOR struct on stack
	sphl			; Set SP to FOR structure
	push	de		; Save loop variable address
	mov	a,m		; Get direction byte from struct
	inx	hl		; Point to STEP value
	push	psw		; Save direction byte
	push	de		; Save var address again
	mvi	e,00H		; NF - Next without For error
	jnz	Error		; Error if no FOR found
	; Load STEP value into FACCUM
	call	FLoadFromMem	; FACCUM = STEP value
	xthl			; HL = var addr, (SP) = struct ptr
	; Add STEP to loop variable
	push	hl		; Save var address
	call	FAddMem_load	; FACCUM = var + STEP
	pop	hl		; HL = var address
	call	FCopyToMem	; Store updated var value
	; Load TO limit value
	pop	hl		; HL = struct ptr (now at TO value)
	call	FLoadBCDEfromMem	; BCDE = TO limit
	; Compare var to limit
	push	hl		; Save struct ptr
	call	FCompareWithBCDE ; Compare var to limit (-1,0,1)
	pop	hl		; Restore struct ptr
	pop	bc		; B = direction byte (1=up, -1=down)
	; Check if loop complete: compare result - direction = 0 means done
	sub	b		; If result=direction, loop done
	call	FLoadBCDEfromMem	; BC=FOR stmt ptr, DE=line number
	jz	ForLoopDone	; Jump if loop complete
	; Loop not done - go back to FOR statement
	xchg			; HL = line number
	shld	CURRENT_LINE	; Set current line
	mov	l,c		; HL = FOR statement pointer
	mov	h,b
	jmp	EndOfForHandler	; Push FOR token and execute
ForLoopDone:
	sphl			; Remove FOR struct from stack
	lhld	PROG_PTR_TEMP	; Get ptr to end of NEXT
	jmp	ExecNext	; Continue after NEXT
;=============================================================================
; Expression Evaluation
; EvalExpression expects '(' first, ArithParse doesn't
; Returns result in FACCUM
;=============================================================================
EvalExpression:
	rst	1		; Syntax check for '('
	db	'('
;-----------------------------------------------------------------------------
; ArithParse - Parse and evaluate arithmetic expression
; Uses operator precedence parsing with the KW_ARITH_OP_FNS table
;-----------------------------------------------------------------------------
ArithParse:
	dcx	hl		; Back up (will be advanced by NextChar)
ArithParseLoop:
	mvi	d,00H		; D = current precedence level
ArithParsePrecedence:
	push	de		; Save precedence
	mvi	c,01H		; Need 1 word stack space
	call	CheckEnoughVarSpace
	call	EvalTerm	; Evaluate a term (number, var, function)
	shld	EXPR_PTR_TEMP	; Save program pointer
;-----------------------------------------------------------------------------
; ArithParseOp - Check for arithmetic operator after term
;-----------------------------------------------------------------------------
ArithParseOp:
	lhld	EXPR_PTR_TEMP	; Restore program pointer
	pop	bc		; B = previous precedence
	mov	a,m		; Get next character
	mvi	d,00H
	sui	98H		; Subtract KWID_+ (first arith op)
	rc			; Return if < '+' token
	cpi	04H		; Check if +, -, *, /
	rnc			; Return if not arithmetic operator
	; Calculate offset into KW_ARITH_OP_FNS table (3 bytes per entry)
	mov	e,a		; E = operator index
	rlc			; A = index * 2
	add	e		; A = index * 3
	mov	e,a		; DE = offset
	lxi	hl,KW_ARITH_OP_FNS
	dad	de		; HL points to table entry
	; Check operator precedence
	mov	a,b		; A = previous precedence
	mov	d,m		; D = this operator's precedence
	cmp	d		; Compare precedences
	rnc			; Return if prev >= this (lower precedence)
	; Higher precedence - need to evaluate this operator first
	inx	hl		; Point to function address
	push	bc		; Save previous precedence
	lxi	bc,ArithParseOp	; Return address after operation
	push	bc
	mov	c,d		; Save new precedence in C
	call	FPush		; Push current value onto stack
	mov	d,c		; Restore precedence to D
	rst	6		; Push function address from (HL)
	lhld	EXPR_PTR_TEMP	; Restore program pointer
	jmp	ArithParsePrecedence	; Parse next term with new precedence
;-----------------------------------------------------------------------------
; EvalTerm - Evaluate a single term in an expression
; Can be: number, variable, function call, or (expression)
;-----------------------------------------------------------------------------
EvalTerm:
	rst	2		; Get next character
	jc	FIn		; If digit, parse number
	call	CharIsAlpha	; Check if alphabetic
	jnc	EvalVarTerm	; If letter, evaluate variable
	cpi	98H		; Is it '+' (unary plus)?
	jz	EvalTerm	; Ignore leading '+'
	cpi	'.'		; Decimal point?
	jz	FIn		; Parse number starting with '.'
	cpi	99H		; Is it '-' (unary minus)?
	jz	EvalMinusTerm	; Handle negation
	sui	9FH		; Subtract first inline function token
	jnc	EvalInlineFn	; If inline function, evaluate it
	; Must be parenthesized expression
EvalBracketed:
	call	EvalExpression	; Evaluate (expects and consumes '(')
	rst	1		; Syntax check for ')'
	db	')'
	ret
;-----------------------------------------------------------------------------
; EvalMinusTerm - Evaluate negated term (-x)
;-----------------------------------------------------------------------------
EvalMinusTerm:
	call	EvalTerm	; Evaluate the term
	push	hl		; Save program pointer
	call	FNegate		; Negate FACCUM
PopHLRet:
	pop	hl		; Restore program pointer
	ret
;-----------------------------------------------------------------------------
; EvalVarTerm - Evaluate a variable reference
;-----------------------------------------------------------------------------
EvalVarTerm:
	call	GetVar		; Get variable address in DE
EvalVarTermPush	equ	$		; Address checked by FAssign (+3)
	push	hl		; Save program pointer
	xchg			; HL = variable address
	call	FLoadFromMem	; Load variable value into FACCUM
	pop	hl		; Restore program pointer
	ret
;-----------------------------------------------------------------------------
; EvalInlineFn - Evaluate inline function (SGN, INT, ABS, etc.)
;-----------------------------------------------------------------------------
EvalInlineFn:
	mvi	b,00H		; Calculate offset into KW_INLINE_FNS
	rlc			; A = function index * 2
	mov	c,a		; BC = offset
	push	bc		; Save offset
	rst	2		; Get next char
	call	EvalBracketed	; Evaluate argument
	xthl			; HL = offset, (SP) = prog ptr
	lxi	de,PopHLRet	; Return address (POP HL; RET)
	push	de
	lxi	bc,KW_INLINE_FNS
	dad	bc		; HL = function address ptr
	rst	6		; Push function address
	ret			; Jump to function
;=============================================================================
; DIM Statement Handler
; Declares arrays. DimContd is the continuation point for multiple dims.
; Format: DIM A(10), B(20), ...
;=============================================================================
DimContd:
	dcx	hl		; Back up program pointer
	rst	2		; NextChar - get next char
	rz			; Return if end of line
	rst	1		; SyntaxCheck for comma
	db	','
Dim:	lxi	bc,DimContd	; Set return address for next DIM item
	push	bc
	db	0F6H		; ORI 0AFH - Set A non-zero for DIM
				; Fall through to GetVar which starts with AF (XRA A)
				; When entered at Dim+5, executes ORI 0AFH, A=non-zero
				; When entered at GetVar, executes XRA A, A=0
;=============================================================================
; GetVar - Variable Lookup/Creation
; Given variable name at HL, returns pointer to variable value in DE.
; If variable doesn't exist, allocates and initializes it.
; Entry: HL=program pointer to variable name
;        A=0 for normal access, NZ if called from DIM
; Exit:  DE=pointer to variable value (4 bytes)
;        HL=updated program pointer
;=============================================================================
GetVar:	xra	a		; Clear A (also serves as operand for ORI above)
	sta	DIM_OR_EVAL	; Store DIM/EVAL flag
	mov	b,m		; B = first char of variable name
	call	CharIsAlpha	; Check if alphabetic
	jc	SyntaxError	; Error if not alpha
	xra	a		; Clear A
	mov	c,a		; C = 0 (default second char)
	rst	2		; NextChar
	jnc	GetVarCheckArray ; If not alphanumeric, skip to array check
	mov	c,a		; C = second char of variable name
	rst	2		; NextChar
; Check if next char is '(' - if so, it's an array access
GetVarCheckArray:
	sui	'('		; Subtract '(' (28H)
	jz	GetArrayVar	; Jump if array variable
	; Simple variable lookup - search VAR_BASE to VAR_ARRAY_BASE
	push	hl		; Save program pointer
	lhld	VAR_ARRAY_BASE	; DE = end of simple variables
	xchg
	lhld	VAR_BASE	; HL = start of simple variables
; Loop through existing variables looking for name match
FindVarLoop:
	rst	4		; CompareHLDE - at end of variables?
	jz	AllocNewVar	; Not found, allocate new variable
	mov	a,c		; Compare second char of name
	sub	m		; With stored variable name
	inx	hl
	jnz	FindVarNext	; No match on second char
	mov	a,b		; Compare first char
	sub	m
FindVarNext:
	inx	hl
	jz	VarFound	; Names match - variable found
	inx	hl		; Skip over 4-byte value
	inx	hl
	inx	hl
	inx	hl
	jmp	FindVarLoop	; Try next variable
; Allocate new variable - but first check if called from EvalTerm
; If so, don't allocate (undeclared variable in expression = 0)
AllocNewVar:
	pop	hl		; HL = prog ptr
	xthl			; (SP) = prog ptr, HL = return address
	push	de		; Save DE
	lxi	de,EvalVarTermPush ; Address inside EvalVarTerm
	rst	4		; Compare return address
	pop	de		; Restore DE
	jz	CalledFromEval	; If from evaluator, don't allocate
	; OK to allocate - restore stack and proceed
	xthl			; (SP) = ret addr, HL = prog ptr
	push	hl		; Prog ptr back on stack
	push	bc		; Save variable name BC
	lxi	bc,6		; Need 6 bytes (2 name + 4 value)
	lhld	VAR_TOP		; Get current top
	push	hl		; Save old top
	dad	bc		; HL = new top
	pop	bc		; BC = old top
	push	hl		; Save new top
	call	CopyMemoryUp	; Move array block up 6 bytes
	pop	hl
	shld	VAR_TOP		; Update VAR_TOP
	mov	h,b		; HL = old VAR_TOP (where arrays were)
	mov	l,c
	shld	VAR_ARRAY_BASE	; Update VAR_ARRAY_BASE
; Initialize new variable to zero (6 bytes)
InitVarLoop:
	dcx	hl
	mvi	m,0
	rst	4		; CompareHLDE - done?
	jnz	InitVarLoop
	; Write variable name at start
	pop	de		; DE = variable name (BC was pushed)
	mov	m,e		; Store second char of name
	inx	hl
	mov	m,d		; Store first char of name
	inx	hl
; Variable found or allocated - return with DE pointing to value
VarFound:
	xchg			; DE = ptr to variable value
	pop	hl		; HL = program pointer
	ret
; Called from expression evaluator - return with FACCUM = 0
CalledFromEval:
	sta	FACCUM_EXP	; A=0 from compare, zero the exponent
	pop	hl		; Restore program pointer
	ret
;=============================================================================
; GetArrayVar - Array Variable Access/Allocation
; BC = variable name, HL = prog ptr (after '(')
; DIM_OR_EVAL: 0 = accessing element, NZ = declaring array
;=============================================================================
GetArrayVar:
	push	bc		; Save variable name
	lda	DIM_OR_EVAL	; Get DIM/EVAL flag
	push	psw		; Save it
	call	GetSubscript	; Get subscript into DE
	rst	1		; SyntaxCheck for ')'
	db	')'
	pop	psw		; Restore DIM/EVAL flag
	sta	DIM_OR_EVAL
	xthl			; HL = var name, (SP) = prog ptr
	xchg			; DE = var name, HL = subscript
	; Multiply subscript by 4 (each element is 4 bytes)
	dad	hl		; *2
	dad	hl		; *4
	push	hl		; Save subscript*4
	lhld	VAR_ARRAY_BASE	; Start of array storage
	db	01H		; LXI BC,... (skip next 2 bytes)
; Find array loop - search through arrays for matching name
FindArrayLoop:
	pop	bc		; BC = subscript*4 (or junk first time)
	dad	bc		; Advance pointer
	xchg			; DE = current array ptr
	push	hl		; Save subscript*4
	lhld	VAR_TOP		; End of array storage
	rst	4		; CompareHLDE - at end?
	xchg
	pop	de		; DE = subscript*4
	jz	AllocArray	; Not found, allocate new array
	; Check if this array matches our variable name
	rst	6		; PushNextWord - get array name
	xthl			; (SP) = array name, HL = subscript*4
	rst	4		; Compare names
	pop	hl		; HL = array name from this array
	rst	6		; PushNextWord - get array size
	jnz	FindArrayLoop	; No match, try next array
	; Array found - check if we're in DIM (error - redim)
	lda	DIM_OR_EVAL
	ora	a
	mvi	e,12H		; DD error - Duplicate Definition
	jnz	Error
; Array element retrieval - check subscript is in bounds
GetArrayElement:
	pop	de		; DE = subscript*4
	dcx	de		; Adjust for compare
	xthl			; HL = subscript*4 from stack, (SP) = array size
	rst	4		; Compare subscript vs array size
	mvi	e,10H		; BS error - Bad Subscript
	jnc	Error		; Error if subscript >= size
	; Calculate element address
	pop	de		; DE = array base (after size word)
	dad	de		; HL = element address
	pop	de		; DE = prog ptr
	xchg			; DE = element ptr, HL = prog ptr
	ret
;=============================================================================
; AllocArray - Allocate space for new array
; DE = variable name, HL = ptr to where array will be stored
; Stack has subscript*4 (the size requested)
;=============================================================================
AllocArray:
	mov	m,e		; Store array name (2 bytes)
	inx	hl
	mov	m,d
	inx	hl
	; Set default size to 44 bytes (11 elements * 4 bytes)
	; This is for implicit DIM (first use without DIM statement)
	lxi	de,44		; Default size: 11 elements (0-10)
	lda	DIM_OR_EVAL
	ora	a
	jz	StoreArraySize	; If not DIM, use default
	; DIM statement - get requested size from stack
	pop	de		; DE = subscript*4 (requested size)
	push	de		; Put it back
	inx	de		; Add 4 for one extra element
	inx	de		; (subscript is 0-based)
	inx	de
	inx	de
StoreArraySize:
	push	de		; Save size
	mov	m,e		; Store array size (2 bytes)
	inx	hl
	mov	m,d
	inx	hl
	; Check memory and update VAR_TOP
	push	hl		; Save ptr to array data area
	dad	de		; HL = new VAR_TOP
	call	CheckEnoughMemPushHL ; Entry at E5 byte (PUSH HL)
	shld	VAR_TOP		; Update VAR_TOP
	pop	de		; DE = array data start
; Initialize all array elements to zero
InitArrayElements:
	dcx	hl
	mvi	m,0
	rst	4		; CompareHLDE - done?
	jnz	InitArrayElements
	jmp	GetArrayElement	; Return element pointer
;=============================================================================
; Floating Point Math Routines
; FACCUM format: 4 bytes - 3 bytes mantissa + 1 byte exponent
; Mantissa is stored with implicit high bit, sign in bit 7 of high byte
; Exponent is biased by 128 (80H)
;=============================================================================

;-----------------------------------------------------------------------------
; FWordToFloat - Convert 16-bit integer (AB) to floating point
; Entry: A=high byte, B=low byte of integer
; Exit: Result in FACCUM
; NOTE: This routine is unused in 4K BASIC (for 8K compatibility)
;-----------------------------------------------------------------------------
FWordToFloat:
	mov	d,b		; D = low byte
	mvi	e,0		; E = 0 (low mantissa)
	mvi	b,90H		; Exponent = 2^16 (144 decimal)
	jmp	FCharToFloat2	; Continue in conversion routine

;-----------------------------------------------------------------------------
; FAddMem - Add 0.5 to FACCUM (for rounding)
;-----------------------------------------------------------------------------
FAddMem:
	lxi	hl,ONE_HALF	; Point to 0.5 constant
FAddMem_load:
	call	FLoadBCDEfromMem ; Load BCDE from memory
	jmp	FAdd		; Add to FACCUM

;-----------------------------------------------------------------------------
; FSub - Floating point subtraction: FACCUM = stack - FACCUM
; Entry: LHS on stack, RHS in FACCUM
; Overlapping instruction trick: Entry at FSub-2 pops BC/DE from stack
;-----------------------------------------------------------------------------
FSubEntry:
	pop	bc		; (or part of LXI operand when skipped)
	pop	de		; (or part of LXI operand when skipped)
FSub:	call	FNegate		; Negate RHS
FAddEntry	equ	$+1	; Entry point at C1 D1 (POP BC; POP DE when jumped to)
	lxi	hl,0D1C1H	; Skip to FAdd (C1 D1 operand = POP BC; POP DE trick)
;-----------------------------------------------------------------------------
; FAdd - Floating point addition: FACCUM = BCDE + FACCUM
; Entry: LHS in BCDE, RHS in FACCUM
; Exit: Result in FACCUM
;-----------------------------------------------------------------------------
FAdd:	mov	a,b		; Check LHS exponent
	ora	a		; If LHS is zero
	rz			; Just return (FACCUM unchanged)
	lda	FACCUM_EXP	; Check RHS exponent
	ora	a
	jz	FLoadFromBCDE	; If RHS=0, result is LHS
	; Compare exponents to align mantissas
	sub	b		; A = RHS exp - LHS exp
	jnc	FAddAligned	; If RHS exp >= LHS exp, continue
	; Swap LHS and RHS (make larger exponent in FACCUM)
	cma			; Negate exponent difference
	inr	a
	xchg			; Swap DE
	call	FPush		; Push FACCUM to stack
	xchg
	call	FLoadFromBCDE	; Copy BCDE to FACCUM
	pop	bc		; Pop old FACCUM to BCDE
	pop	de
FAddAligned:
	push	psw		; Save exponent difference
	call	FUnpackMantissas ; Unpack mantissas, A = sign relationship
	mov	h,a		; H = sign relationship
	pop	psw		; A = exponent difference
	call	FMantissaRtMult	; Shift LHS right by exp diff
	ora	h		; Check sign relationship
	lxi	hl,FACCUM	; Point to FACCUM
	jp	FSubMantissas	; If signs differ, subtract
	; Signs same - add mantissas
	call	FAddMantissas
	jnc	FRoundUp	; No overflow, round up
	inx	hl		; Point to exponent
	inr	m		; Increment exponent
	jz	Overflow	; Error if overflow
	call	FMantissaRtOnce	; Shift right once
	jmp	FRoundUp
;-----------------------------------------------------------------------------
; FSubMantissas - Subtract LHS from RHS mantissa
; Entry: HL points to FACCUM, LHS in BCDE
; Exit: Result in BCDE
;-----------------------------------------------------------------------------
FSubMantissas:
	xra	a		; B = 0 - B
	sub	b
	mov	b,a
	mov	a,m		; E = (FACCUM) - E
	sbb	e
	mov	e,a
	inx	hl
	mov	a,m		; D = (FACCUM+1) - D
	sbb	d
	mov	d,a
	inx	hl
	mov	a,m		; C = (FACCUM+2) - C
	sbb	c
	mov	c,a
; Fall into FNormalise

;-----------------------------------------------------------------------------
; FNormalise - Normalize result and store in FACCUM
; Entry: Result mantissa in CDEB (4 bytes), carry set if need negate
; Exit: Normalized result in FACCUM
;-----------------------------------------------------------------------------
FNormalise:
	cc	FNegateInt	; Negate if carry set
FNormaliseNoNeg:
	mvi	h,0		; H = shift count
	mov	a,c		; Check high byte of mantissa
	ora	a
	jm	FRoundUp	; Already normalized (bit 7 set)
; Shift left until bit 7 of C is set
FNormaliseLoop:
	cpi	0E0H		; Have we shifted 32 times?
	jz	FZero		; Result is zero
	dcr	h		; Count shifts
	mov	a,b		; Left-shift extra mantissa byte
	add	a
	mov	b,a
	call	FMantissaLeft	; Left-shift CDE
	mov	a,h
	jp	FNormaliseLoop	; Loop if not done
	; Adjust exponent by shift count (H is negative)
	lxi	hl,FACCUM_EXP	; Point to exponent
	add	m		; Add (negative) shift count
	mov	m,a
	jnc	FZero		; Underflow = zero
	rz
;-----------------------------------------------------------------------------
; FRoundUp - Round up mantissa and set sign
; Entry: CDEB = mantissa (B is extra precision byte)
; Exit: Result stored in FACCUM
;-----------------------------------------------------------------------------
FRoundUp:
	mov	a,b		; A = extra mantissa byte
FRoundUpNoB:				; Entry +1: skip MOV A,B (A already set)
	lxi	hl,FACCUM_EXP	; Point to exponent
	ora	a		; If bit 7 of extra byte set
	cm	FMantissaInc	; Round up the mantissa
	; Set sign and store result
	mov	b,m		; B = exponent
	inx	hl
	mov	a,m		; A = FTEMP_SIGN
	ani	80H		; Isolate sign bit
	xra	c		; Combine with mantissa high bit
	mov	c,a		; C = signed high mantissa
	jmp	FLoadFromBCDE	; Store result

;-----------------------------------------------------------------------------
; FMantissaLeft - Shift mantissa CDE left by one bit
; Entry: CDE = mantissa, carry contains bit to shift in
; Exit: CDE shifted left, carry = bit shifted out
;-----------------------------------------------------------------------------
FMantissaLeft:
	mov	a,e		; Shift E left
	ral
	mov	e,a
	mov	a,d		; Shift D left with carry
	ral
	mov	d,a
	mov	a,c		; Shift C left with carry
	adc	a
	mov	c,a
	ret

;-----------------------------------------------------------------------------
; FMantissaInc - Increment mantissa CDE
; Handles overflow by setting C=80H and incrementing exponent
;-----------------------------------------------------------------------------
FMantissaInc:
	inr	e
	rnz
	inr	d
	rnz
	inr	c
	rnz
	mvi	c,80H		; Mantissa overflowed, set to 1.0
	inr	m		; Increment exponent
	rnz
Overflow:
	mvi	e,0AH		; OV error
	jmp	Error

;-----------------------------------------------------------------------------
; FAddMantissas - Add mantissa at HL to mantissa in CDE
; Entry: HL points to 3-byte mantissa, CDE = mantissa
; Exit: CDE = sum, carry set on overflow
;-----------------------------------------------------------------------------
FAddMantissas:
	mov	a,m		; Add low bytes
	add	e
	mov	e,a
	inx	hl
	mov	a,m		; Add middle bytes with carry
	adc	d
	mov	d,a
	inx	hl
	mov	a,m		; Add high bytes with carry
	adc	c
	mov	c,a
	ret

;-----------------------------------------------------------------------------
; FNegateInt - Negate 32-bit integer CDEB (for sign handling)
; Also complements FTEMP_SIGN
;-----------------------------------------------------------------------------
FNegateInt:
	lxi	hl,FTEMP_SIGN	; Complement sign
	mov	a,m
	cma
	mov	m,a
	xra	a		; CDEB = 0 - CDEB
	mov	l,a
	sub	b
	mov	b,a
	mov	a,l
	sbb	e
	mov	e,a
	mov	a,l
	sbb	d
	mov	d,a
	mov	a,l
	sbb	c
	mov	c,a
	ret

;-----------------------------------------------------------------------------
; FMantissaRtMult - Shift mantissa CDE right by A places
; Entry: A = shift count, CDE = mantissa
; Exit: CDEB = shifted mantissa (B = extra precision byte)
;-----------------------------------------------------------------------------
FMantissaRtMult:
	mvi	b,0		; Initialize extra byte
	inr	a		; Adjust count
	mov	l,a
FMantissaRtLoop:
	xra	a
	dcr	l
	rz			; Done
	call	FMantissaRtOnce
	jmp	FMantissaRtLoop

;-----------------------------------------------------------------------------
; FMantissaRtOnce - Shift mantissa CDEB right by one bit
;-----------------------------------------------------------------------------
FMantissaRtOnce:
	mov	a,c		; Shift C right
FMantissaRtNoC:				; Entry +1: skip MOV A,C (continue shift)
	rar
	mov	c,a
	mov	a,d		; Shift D right with carry
	rar
	mov	d,a
	mov	a,e		; Shift E right with carry
	rar
	mov	e,a
	mov	a,b		; Shift B right with carry
	rar
	mov	b,a
	ret
;-----------------------------------------------------------------------------
; FMul - Floating point multiplication: FACCUM = stack * FACCUM
; Uses shift-and-add algorithm for mantissa multiplication
;-----------------------------------------------------------------------------
FMulEntry:
	pop	bc		; Get LHS from stack
	pop	de
FMul:	rst	5		; FTestSign - check if RHS is zero
	rz			; Return if zero
	; Add exponents (L=0 means add)
	mvi	l,0
	call	FExponentAdd
	; Store LHS mantissa in self-modifying code locations
	mov	a,c
	sta	FMulLHSHigh	; High byte of LHS mantissa
	xchg
	shld	FMulLHSLow	; Low two bytes of LHS mantissa
	; Initialize result mantissa to 0
	lxi	bc,0
	mov	d,b
	mov	e,b
	; Set return address to FNormalise
	lxi	hl,FNormaliseNoNeg
	push	hl
	; Push outer loop address twice (for 3 bytes of mantissa)
	lxi	hl,FMulOuterLoop
	push	hl
	push	hl
	lxi	hl,FACCUM	; Point to RHS mantissa
; Outer loop: process one byte of RHS mantissa at a time
FMulOuterLoop:
	mov	a,m		; Get RHS mantissa byte
	inx	hl
	push	hl		; Save pointer
	mvi	l,8		; 8 bits per byte
; Inner loop: shift-and-add for each bit
FMulInnerLoop:
	rar			; Test low bit of RHS byte
	mov	h,a		; Save remaining bits
	mov	a,c		; A = result high byte
	jnc	FMulNoAdd	; Skip add if bit was 0
	; Add LHS mantissa to result
	push	hl
FMulLHSLow	equ	$+1		; Self-modified: LHS low bytes (+8)
	lxi	hl,0		; (operand patched at runtime)
	dad	de
	pop	de
FMulLHSHigh	equ	$+1		; Self-modified: LHS high byte (+13)
	aci	0		; (operand patched at runtime)
	xchg
FMulNoAdd:
	call	FMantissaRtNoC	; Shift result right (skip MOV A,C)
	dcr	l		; Count bits
	mov	a,h		; Restore RHS byte
	jnz	FMulInnerLoop
FMulReturn:
	pop	hl		; Restore FACCUM pointer
	ret			; Return (to outer loop or FNormalise)
;-----------------------------------------------------------------------------
; FDivByTen - Divide FACCUM by 10.0
; Used in number output to bring values into range
;-----------------------------------------------------------------------------
FDivByTen:
	call	FPush		; Push FACCUM to stack
	lxi	bc,8420H	; BCDE = 10.0 (exponent 84H, mantissa 20 00 00)
	lxi	de,0
	call	FLoadFromBCDE	; Load 10.0 into FACCUM
	; Fall into FDiv

;-----------------------------------------------------------------------------
; FDiv - Floating point division: FACCUM = stack / FACCUM
; Uses repeated subtraction (long division) algorithm
;-----------------------------------------------------------------------------
FDivEntry:
	pop	bc		; Get LHS (dividend) from stack
	pop	de
FDiv:	rst	5		; FTestSign - check if RHS (divisor) is zero
	jz	DivByZero	; Error if divide by zero
	; Subtract exponents (L=FF means subtract)
	mvi	l,0FFH
	call	FExponentAdd
	; Multiply FACCUM by 4 (add 2 to exponent)
	inr	m
	inr	m
	; Store RHS mantissa in self-modifying code locations
	dcx	hl
	mov	a,m
	sta	FDivDivisorHigh	; High byte
	dcx	hl
	mov	a,m
	sta	FDivDivisorMid	; Middle byte
	dcx	hl
	mov	a,m
	sta	FDivDivisorLow	; Low byte
	; Initialize for long division
	mov	b,c		; B = LHS high mantissa byte
	xchg			; HL = LHS low mantissa
	xra	a
	mov	c,a		; Initialize result mantissa to 0
	mov	d,a
	mov	e,a
	sta	FDivCarryByte	; Initialize carry byte
; Long division loop
FDivLoop:
	push	hl		; Save dividend
	push	bc
	; Subtract divisor from dividend (self-modifying operands)
	mov	a,l
FDivDivisorLow	equ	$+1		; Self-modified: divisor low byte (+4)
	sui	0		; (operand patched at runtime)
	mov	l,a
	mov	a,h
FDivDivisorMid	equ	$+1		; Self-modified: divisor middle byte (+8)
	sbi	0		; (operand patched at runtime)
	mov	h,a
	mov	a,b
FDivDivisorHigh	equ	$+1		; Self-modified: divisor high byte (+12)
	sbi	0		; (operand patched at runtime)
	mov	b,a
FDivCarryByte	equ	$+1		; Self-modified: carry byte (+15)
	mvi	a,0		; (operand patched at runtime)
	sbi	0
	cmc			; Complement carry for comparison
	jnc	FDivNoSubtract
	; Subtraction succeeded - keep result
	sta	FDivCarryByte	; Update carry
	pop	psw		; Discard old values
	pop	psw
	stc			; Set carry for quotient bit
	db	0D2H		; JNC to skip restore (opcode only)
FDivNoSubtract:
	pop	bc		; Restore original values
	pop	hl
	; Shift quotient bit into result
	mov	a,c
	inr	a		; Test if normalized
	dcr	a
	rar			; Shift carry into result
	jm	FRoundUpNoB	; Done if normalized (A already set)
	ral			; Undo the shift
	call	FMantissaLeft	; Shift result left
	; Shift dividend left (multiply by 2)
	dad	hl
	mov	a,b
	ral
	mov	b,a
	lda	FDivCarryByte	; Shift carry byte
	ral
	sta	FDivCarryByte
	; Check if dividend is zero
	mov	a,c
	ora	d
	ora	e
	jnz	FDivLoop
	; Decrement exponent and continue
	push	hl
	lxi	hl,FACCUM_EXP
	dcr	m
	pop	hl
	jnz	FDivLoop
	jmp	Overflow	; Exponent underflow
;-----------------------------------------------------------------------------
; FExponentAdd - Add or subtract exponents for FMul/FDiv
; Entry: L=0 for add (FMul), L=FF for subtract (FDiv)
;        BCDE = LHS, FACCUM = RHS
; Exit: Combined exponent stored in FACCUM, mantissas unpacked
;-----------------------------------------------------------------------------
FExponentAdd:
	mov	a,b		; Check if LHS is zero
	ora	a
	jz	FExpAddZero	; Exit early if LHS is zero
	mov	a,l		; Get add/subtract flag
	lxi	hl,FACCUM_EXP	; Point to RHS exponent
	xra	m		; XOR with RHS exponent (complement for subtract)
	add	b		; Add LHS exponent
	mov	b,a
	rar			; Move carry to bit 7
	xra	b		; Check for overflow
	mov	a,b
	jp	FExpAddStore	; No overflow, continue
	; Add bias and store exponent
	adi	80H		; Add bias
	mov	m,a		; Store in FACCUM
	jz	FMulReturn	; Zero = underflow, exit via POP HL; RET
	; Unpack mantissas and store sign
	call	FUnpackMantissas
	mov	m,a		; Store sign relationship
	dcx	hl		; Point to mantissa high byte
	ret
FExpAddStore:
	ora	a		; Set flags
FExpAddZero:
	pop	hl		; Remove return address
	jm	Overflow	; Negative = overflow error
; Fall into FZero

;-----------------------------------------------------------------------------
; FZero - Set FACCUM to zero
;-----------------------------------------------------------------------------
FZero:	xra	a
	sta	FACCUM_EXP	; Zero exponent = zero value
	ret
;-----------------------------------------------------------------------------
; FMulByTen - Multiply FACCUM by 10.0 (optimized)
; Uses: FACCUM * 10 = (FACCUM * 4 + FACCUM) * 2
;-----------------------------------------------------------------------------
FMulByTen:
	call	FCopyToBCDE	; Copy FACCUM to BCDE
	mov	a,b		; Check if zero
	ora	a
	rz			; Return if zero
	adi	2		; Multiply by 4 (add 2 to exponent)
	jc	Overflow	; Check overflow
	mov	b,a
	call	FAdd		; Add to FACCUM (now FACCUM*5)
	lxi	hl,FACCUM_EXP	; Multiply by 2 (add 1 to exponent)
	inr	m
	rnz
	jmp	Overflow

;-----------------------------------------------------------------------------
; FTestSign_tail - Continuation of RST 5 (FTestSign)
; Returns: A=0 if FACCUM=0, A=1 if positive, A=-1 if negative
;-----------------------------------------------------------------------------
FTestSign_tail:
	lda	FACCUM+2	; Get sign byte
FTestSignCMA	equ	$+1		; Entry +4: 2FH = CMA (complement A)
	cpi	2FH		; Compare to determine sign
	ral			; Rotate sign into carry
	sbb	a		; A = -1 if negative, 0 if positive
	rnz			; Return if non-zero (negative)
	inr	a		; Return 1 for positive
	ret

;-----------------------------------------------------------------------------
; Sgn - SGN function: returns -1, 0, or 1 based on sign of FACCUM
;-----------------------------------------------------------------------------
Sgn:	rst	5		; FTestSign
; Fall through to convert result to float

;-----------------------------------------------------------------------------
; FCharToFloat - Convert signed byte in A to floating point
; Entry: A = signed byte (-128 to 127)
; Exit: Result in FACCUM
;-----------------------------------------------------------------------------
FCharToFloat:
	mvi	b,88H		; Exponent for 8-bit integer
	lxi	de,0		; Low mantissa bytes = 0
FCharToFloat2:
	lxi	hl,FACCUM_EXP	; Point to exponent
	mov	c,a		; C = mantissa high byte
	mov	m,b		; Store exponent
	mvi	b,0		; B = 0 (extra precision)
	inx	hl
	mvi	m,80H		; Set implicit high bit
	ral			; Get sign bit into carry
	jmp	FNormalise	; Normalize result

;-----------------------------------------------------------------------------
; Abs - ABS function: absolute value
;-----------------------------------------------------------------------------
Abs:	rst	5		; FTestSign
	rp			; Return if positive or zero
; Fall into FNegate

;-----------------------------------------------------------------------------
; FNegate - Negate FACCUM (flip sign bit)
;-----------------------------------------------------------------------------
FNegate:
	lxi	hl,FACCUM+2	; Point to sign byte
	mov	a,m
	xri	80H		; Flip sign bit
	mov	m,a
	ret

;-----------------------------------------------------------------------------
; FPush - Push FACCUM onto stack
; Preserves return address, pushes FACCUM as 2 words (BCDE format)
;-----------------------------------------------------------------------------
FPush:	xchg			; Save DE
	lhld	FACCUM		; Get low 2 bytes
	xthl			; Swap with return address
	push	hl		; Push return address
	lhld	FACCUM+2	; Get high 2 bytes (mantissa high + exponent)
	xthl			; Swap with return address (now on stack)
	push	hl		; Push high 2 bytes
	xchg			; Restore DE
	ret

;-----------------------------------------------------------------------------
; FLoadFromMem - Load FACCUM from memory
; Entry: HL = pointer to 4-byte float
;-----------------------------------------------------------------------------
FLoadFromMem:
	call	FLoadBCDEfromMem ; Load BCDE from memory
; Fall into FLoadFromBCDE

;-----------------------------------------------------------------------------
; FLoadFromBCDE - Load FACCUM from BCDE
;-----------------------------------------------------------------------------
FLoadFromBCDE:
	xchg			; HL = low mantissa
	shld	FACCUM		; Store low mantissa
	mov	h,b		; HL = exponent/high mantissa
	mov	l,c
	shld	FACCUM+2	; Store high mantissa and exponent
	xchg			; Restore HL
	ret

;-----------------------------------------------------------------------------
; FCopyToBCDE - Copy FACCUM to BCDE registers
;-----------------------------------------------------------------------------
FCopyToBCDE:
	lxi	hl,FACCUM	; Point to mantissa
FLoadBCDEfromMem:
	mov	e,m		; E = low mantissa byte
	inx	hl
	mov	d,m		; D = middle mantissa byte
	inx	hl
	mov	c,m		; C = high mantissa byte (with sign)
	inx	hl
	mov	b,m		; B = exponent
IncHL:
	inx	hl
	ret
;-----------------------------------------------------------------------------
; FCopyToMem - Copy FACCUM to memory location
; Entry: HL = destination pointer
;-----------------------------------------------------------------------------
FCopyToMem:
	lxi	de,FACCUM	; Source = FACCUM mantissa
	mvi	b,4		; 4 bytes to copy
FCopyLoop:
	ldax	de
	mov	m,a
	inx	de
	inx	hl
	dcr	b
	jnz	FCopyLoop
	ret

;-----------------------------------------------------------------------------
; FUnpackMantissas - Unpack mantissas for arithmetic operations
; Sets implicit high bit, determines sign relationship
; Entry: BCDE = LHS number, FACCUM = RHS number
; Exit: A = sign relationship (positive if same sign, negative if different)
;       C, FACCUM mantissas have implicit bit set
;-----------------------------------------------------------------------------
FUnpackMantissas:
	lxi	hl,FACCUM+2	; Point to RHS sign byte
	mov	a,m		; Get RHS sign
	rlc			; Rotate sign to carry
	stc			; Set carry (implicit high bit)
	rar			; Combine: bit 7=1, bit 6=old sign
	mov	m,a		; Store back
	cmc			; Complement for sign extraction
	rar			; A = sign indicator
	inx	hl		; Skip to FTEMP_SIGN
	inx	hl
	mov	m,a		; Store sign indicator
	; Same for LHS mantissa in C
	mov	a,c
	rlc			; Get sign to carry
	stc			; Set implicit bit
	rar			; Bit 7 = 1, bit 6 = old sign
	mov	c,a
	rar			; Get sign for comparison
	xra	m		; XOR with RHS sign
	ret			; A positive = same sign, negative = different
;-----------------------------------------------------------------------------
; FCompare - Compare BCDE with FACCUM
; Entry: BCDE = number to compare
; Exit: A = -1 if BCDE < FACCUM, 0 if equal, 1 if BCDE > FACCUM
;       Zero flag set if equal
;-----------------------------------------------------------------------------
FCompareWithBCDE:
	mov	a,b		; Check if BCDE is zero
	ora	a
	jz	FTestSign	; If zero, result depends on FACCUM sign
	lxi	hl,FTestSignCMA	; Return address: 2FH = CMA opcode
	push	hl
	rst	5		; FTestSign - check FACCUM
	mov	a,c		; Get BCDE sign
	rz			; Return if FACCUM is zero
	lxi	hl,FACCUM+2	; Compare signs
	xra	m
	mov	a,c
	rm			; Different signs - return sign of BCDE
	call	FCompareBytes	; Same sign - compare magnitudes
	rar			; Move result to low bit
	xra	c		; Adjust for sign
	ret

; Compare bytes of BCDE with FACCUM
FCompareBytes:
	inx	hl		; Point to exponent
	mov	a,b		; Compare exponents
	cmp	m
	rnz
	dcx	hl		; Compare high mantissa
	mov	a,c
	cmp	m
	rnz
	dcx	hl		; Compare middle mantissa
	mov	a,d
	cmp	m
	rnz
	dcx	hl		; Compare low mantissa
	mov	a,e
	sub	m
	rnz
	pop	hl		; Equal - discard return addresses
	pop	hl
	ret

;-----------------------------------------------------------------------------
; FCompare - Convert FACCUM to integer in BCDE for comparison
; Used by INT function and comparisons
;-----------------------------------------------------------------------------
FCompare:
	mov	b,a		; Initialize BCDE to 0
	mov	c,a
	mov	d,a
	mov	e,a
	ora	a
	rz			; Return if FACCUM is zero
	push	hl
	call	FCopyToBCDE	; Copy FACCUM to BCDE
	call	FUnpackMantissas ; Unpack mantissa
	xra	m		; Get sign relationship
	mov	h,a
	cm	FCompareNeg	; Negate if needed
	mvi	a,98H		; 24-bit integer exponent
	sub	b		; Calculate shift count
	call	FMantissaRtMult	; Shift to integer
	mov	a,h
	ral			; Check sign
	cc	FMantissaInc	; Round up if needed
	mvi	b,0
	cc	FNegateInt	; Negate if negative
	pop	hl
	ret

FCompareNeg:
	dcx	de		; Decrement for negate
	mov	a,d
	ana	e
	inr	a
	rnz
	dcx	bc
	ret

;-----------------------------------------------------------------------------
; Int - INT function: truncate to integer
;-----------------------------------------------------------------------------
Int:	lxi	hl,FACCUM_EXP	; Point to exponent
	mov	a,m
	cpi	98H		; Check if already integer
	rnc			; Return if exponent >= 24 bits
	call	FCompare	; Convert to integer in BCDE
	mvi	m,98H		; Set exponent for integer
	mov	a,c		; Get sign
	ral			; Rotate sign to carry
	jmp	FNormalise	; Normalize result
;-----------------------------------------------------------------------------
; FIn - Read ASCII string and convert to floating point in FACCUM
; Input: HL points to before the number string
; Variables used:
;   B = count of fractional digits (after decimal point)
;   C = decimal point flag (0xFF = not seen, 0x00 = seen)
;   D = exponent sign (0xFF = negative, 0x01 = positive)
;   E = exponent value
;-----------------------------------------------------------------------------
FIn:
FInInit:
	dcx	hl		; Point to just before number
	call	FZero		; Clear FACCUM
	mov	b,a		; B = 0 (fractional digit count)
	mov	d,a		; D = 0 (exponent sign)
	mov	e,a		; E = 0 (exponent value)
	cma			; A = 0xFF
	mov	c,a		; C = 0xFF (no decimal point yet)
; Main parsing loop - process one character at a time
FInCharLoop:
	rst	2		; NextChar - get next character
	jc	FInDigit	; If digit, process it
	cpi	2EH		; Decimal point?
	jz	FInDecPt	; Yes, mark decimal point seen
	cpi	45H		; 'E' for exponent?
	jnz	FInScale	; No, done parsing - scale result
	; Process exponent after 'E'
	rst	2		; NextChar - get sign or first digit
	dcr	d		; Assume negative (D = -1)
	cpi	99H		; Minus token?
	jz	FInExpDigit	; Yes, keep D = -1
	inr	d		; No, restore D = 0
	cpi	98H		; Plus token?
	jz	FInExpDigit	; Yes, D = 0 (positive)
	dcx	hl		; Back up to re-read char
FInExpDigit:
	rst	2		; NextChar - get exponent digit
	jc	FInExpAccum	; If digit, accumulate exponent
	inr	d		; D was -1? (negative exponent)
	jnz	FInScale	; No, done with exponent
	; Negate exponent for negative
	xra	a
	sub	e		; E = -E
	mov	e,a
	inr	c		; Reset C (was 0xFF)
FInDecPt:
	inr	c		; Mark decimal point seen (C = 0)
	jz	FInCharLoop	; Continue if first decimal point
; Scale the result by 10^(E-B) where E=exponent, B=fractional digits
FInScale:
	push	hl		; Save program pointer
	mov	a,e		; A = exponent
	sub	b		; A = exponent - fractional digits
FInScaleLoop:
	cp	FInMulTen	; If positive, multiply by 10
	jp	FInScaleEnd	; Check if done
	; Negative - divide by 10
	push	psw
	call	FDivByTen
	pop	psw
	inr	a		; Move toward zero
FInScaleEnd:
	jnz	FInScaleLoop	; Continue until A = 0
	pop	hl		; Restore program pointer
	ret
; Multiply by 10 helper (for positive scaling)
FInMulTen:
	rz			; Return if A = 0
FInMulTenNoRZ:				; Entry +1: skip RZ (unconditional multiply)
	push	psw
	call	FMulByTen
	pop	psw
	dcr	a		; Move toward zero
	ret
; Process a digit: multiply current value by 10, add digit
FInDigit:
	push	de		; Save exponent info
	mov	d,a		; D = digit character
	mov	a,b		; Update fractional count
	adc	c		; Add with carry (C = 0 after decimal)
	mov	b,a
	push	bc		; Save BC
	push	hl		; Save program pointer
	push	de		; Save digit
	call	FMulByTen	; FACCUM *= 10
	pop	psw		; Get digit back in A
	sui	30H		; Convert ASCII to value
	call	FPush		; Save current FACCUM
	call	FCharToFloat	; Convert digit to float
	pop	bc		; Get old FACCUM
	pop	de
	call	FAdd		; Add digit to total
	pop	hl		; Restore program pointer
	pop	bc		; Restore BC
	pop	de		; Restore exponent info
	jmp	FInCharLoop	; Continue parsing
; Accumulate exponent digit: E = E*10 + digit
FInExpAccum:
	mov	a,e		; A = current exponent
	rlc			; A = E*2
	rlc			; A = E*4
	add	e		; A = E*5
	rlc			; A = E*10
	add	m		; Add digit character
	sui	30H		; Convert from ASCII
	mov	e,a		; Store back
	jmp	FInExpDigit	; Continue reading exponent
;-----------------------------------------------------------------------------
; PrintIN - Print " IN " followed by line number (for error messages)
;-----------------------------------------------------------------------------
PrintIN:
	push	hl
	lxi	hl,szIn		; " IN " string
	call	PrintStringLoop	; Print (HL already at first char)
	pop	hl
;-----------------------------------------------------------------------------
; PrintInt - Print integer in HL (converts to float and prints)
; The integer occupies the lower 16 bits of mantissa with exponent=24
;-----------------------------------------------------------------------------
PrintInt:
	xchg			; DE = integer value
	xra	a		; C = 0
	mvi	b,98H		; B = exponent 24 (2^24)
	call	FCharToFloat2	; Convert to float (skip sign handling)
	lxi	hl,PrintString	; Return to PrintString after FOut
	push	hl
;-----------------------------------------------------------------------------
; FOut - Float Output: Convert FACCUM to ASCII string in FBUFFER
; Output string is then printed by returning to PrintString
;-----------------------------------------------------------------------------
FOut:
FOutStart:
	lxi	hl,FBUFFER	; Output buffer
	push	hl
	rst	5		; FTestSign - check FACCUM sign
	mvi	m,20H		; Assume positive: leading space
	jp	FOutSetZero	; If positive, skip
	mvi	m,2DH		; Negative: leading '-'
FOutSetZero:
	inx	hl
	mvi	m,30H		; Write '0' (for zero case)
	jz	FOut_tail	; If zero, done (just " 0")
	; Make FACCUM positive for processing
	push	hl		; Save buffer position
	cm	FNegate		; Negate if negative
	xra	a		; Initialize decimal exponent adjustment = 0
	push	psw
	call	FOutUnder1M	; Ensure FACCUM < 1,000,000
; Loop to bring FACCUM >= 100,000
FOutOver100K:
	lxi	bc,9143H	; BCDE = 100000.0
	lxi	de,4FF8H
	call	FCompareWithBCDE
	jpo	FOutPrepare	; If FACCUM >= 100000, continue
	pop	psw		; Get decimal exponent adjustment
	call	FInMulTenNoRZ	; Multiply by 10, decrement adjustment
	push	psw
	jmp	FOutOver100K
; Divide by 10 and increment exponent adjustment
FOutDiv10:
	call	FDivByTen
	pop	psw
	inr	a		; Increment decimal exponent
	push	psw
	call	FOutUnder1M	; Check if under 1M again
; FACCUM is now between 100,000 and 1,000,000
; Add 0.5 for rounding and convert to integer
FOutPrepare:
	call	FAddMem		; Add 0.5 (ONE_HALF)
	inr	a
	call	FCompare	; Convert to integer in CDE
	call	FLoadFromBCDE	; Store integer back to FACCUM
	; Determine output format (scientific or normal)
	lxi	bc,0206H	; B=2, C=6 (6 digits)
	pop	psw		; A = decimal exponent adjustment
	add	c		; A = adjustment + 6
	jm	FOutUseExp	; If A < 0, use scientific
	cpi	07H
	jnc	FOutUseExp	; If A >= 7, use scientific
	inr	a		; Use normal format
	mov	b,a		; B = decimal point position
	mvi	a,01H		; A=1 means no exponent output
FOutUseExp:
	dcr	a
	pop	hl		; HL = output buffer
	push	psw		; Save exponent flag
	lxi	de,DECIMAL_POWERS ; Table of 100000, 10000, 1000...
; Output each digit by repeated subtraction
FOutDigitLoop:
	dcr	b		; Decrement decimal point counter
	mvi	m,2EH		; Write '.' (may be overwritten)
	cz	IncHL		; If B=0, actually keep the '.'
	push	bc
	push	hl
	push	de
	call	FCopyToBCDE	; Get FACCUM to BCDE
	pop	hl		; HL points to power of 10 table
	mvi	b,2FH		; B = '0' - 1
; Subtract power of 10 until underflow
FOutSubLoop:
	inr	b		; Increment digit
	mov	a,e		; Subtract 3-byte power from CDE
	sub	m
	mov	e,a
	inx	hl
	mov	a,d
	sbb	m
	mov	d,a
	inx	hl
	mov	a,c
	sbb	m
	mov	c,a
	dcx	hl
	dcx	hl
	jnc	FOutSubLoop	; Continue until underflow
	call	FAddMantissas	; Add back (undo last subtraction)
	inx	hl		; Move to next power
	call	FLoadFromBCDE	; Store result back
	xchg			; DE = power table ptr
	pop	hl		; HL = output buffer
	mov	m,b		; Store digit
	inx	hl
	pop	bc
	dcr	c		; More digits?
	jnz	FOutDigitLoop	; Yes, continue
	; Strip trailing zeros
	dcr	b
	jz	FOutExpPart	; Skip if no trailing zeros
FOutStripZeros:
	dcx	hl
	mov	a,m
	cpi	30H		; '0'?
	jz	FOutStripZeros	; Strip it
	cpi	2EH		; Decimal point?
	cnz	IncHL		; If not '.', keep this char
FOutExpPart:
	pop	psw		; Get exponent flag
	jz	FOutNullTerm	; If 0, no exponent needed
	; Write scientific notation exponent
	mvi	m,45H		; 'E'
	inx	hl
	mvi	m,2BH		; Assume '+'
	jp	FOutExpDigits	; If positive exponent
	mvi	m,2DH		; Negative: '-'
	cma			; Negate exponent
	inr	a
FOutExpDigits:
	mvi	b,2FH		; B = '0' - 1
FOutExpLoop:
	inr	b		; Count tens digit
	sui	0AH
	jnc	FOutExpLoop
	adi	3AH		; A = ones digit + '0'
	inx	hl
	mov	m,b		; Store tens digit
FOut_tail:
	inx	hl
	mov	m,a		; Store ones digit
	inx	hl
FOutNullTerm:
	mov	m,c		; Null terminator (C=0)
	pop	hl		; Return buffer pointer
	ret
;-----------------------------------------------------------------------------
; FOutUnder1M - Ensure FACCUM < 1,000,000 by dividing by 10
;-----------------------------------------------------------------------------
FOutUnder1M:
	lxi	bc,9474H	; BCDE = 1000000.0
	lxi	de,23F7H
	call	FCompareWithBCDE
	pop	hl		; Get return address
	jpo	FOutDiv10	; If >= 1M, divide by 10
	pchl			; Otherwise return normally
;-----------------------------------------------------------------------------
; Floating Point Constants
;-----------------------------------------------------------------------------
ONE_HALF:
	db	00H,00H,00H,80H	; 0.5 (mantissa 00 00 00, exp 80)
; Table of powers of 10 as 24-bit integers (for digit extraction)
DECIMAL_POWERS:
	db	0A0H,86H,01H	; 100000
	db	10H,27H,00H	; 10000
	db	0E8H,03H,00H	; 1000
	db	64H,00H,00H	; 100
	db	0AH,00H,00H	; 10
	db	01H,00H,00H	; 1
;-----------------------------------------------------------------------------
; SQR - Square Root (Optional Function #1)
; Uses Newton's method: x[n+1] = (x[n] + N/x[n]) / 2
; Iterates 4 times for convergence
;-----------------------------------------------------------------------------
Sqr:	rst	5		; FTestSign - check argument
	jm	FunctionCallError ; Negative: FC error
	rz			; Zero: return zero
	; Extract exponent/2 for later (sqrt scales exponent by half)
	lxi	hl,FACCUM_EXP	; Point to exponent
	mov	a,m		; Get exponent
	rar			; Divide by 2 (into carry too)
	push	psw		; Save exponent/2 + carry
	push	hl		; Save exponent pointer
	; Set exponent to 0x80 or 0x81 (normalize to ~1.0)
	mvi	a,40H		; Base 0x40
	ral			; Add carry from above
	mov	m,a		; Set new exponent
	; Copy FACCUM to FBUFFER as initial guess
	lxi	hl,FBUFFER
	call	FCopyToMem
	; Newton's method: 4 iterations
	mvi	a,04H		; Iteration count
SqrLoop:
	push	psw		; Save count
	call	FPush		; Push current estimate
	lxi	hl,FBUFFER	; Original value
	call	FLoadBCDEfromMem
	call	FDiv		; FACCUM = original / estimate
	pop	bc		; Get pushed estimate
	pop	de
	call	FAdd		; FACCUM = estimate + original/estimate
	; Multiply by 0.5 (divide by 2)
	lxi	bc,8000H	; BCDE = 0.5
	mov	d,c
	mov	e,c
	call	FMul		; FACCUM = (estimate + N/estimate) / 2
	pop	psw		; Get iteration count
	dcr	a
	jnz	SqrLoop		; Continue if not done
	; Restore exponent correction
	pop	hl		; HL = exponent pointer
	pop	psw		; A = original exponent/2
	adi	0C0H		; Adjust for bias (0x80 - 0x40)
	add	m		; Add to computed exponent
	mov	m,a		; Store final exponent
	ret
;-----------------------------------------------------------------------------
; RND - Random Number Generator (Optional Function #2)
; Uses linear congruential generator: seed = seed * 11879546 + offset
; Returns random number 0 <= x < 1
; If argument is negative, reseeds from argument
;-----------------------------------------------------------------------------
Rnd:	rst	5		; FTestSign - check argument
	lxi	hl,RND_SEED	; Point to current seed
	call	FLoadFromMem	; Load seed to FACCUM
	rz			; If zero, return zero
	; Linear congruential: seed * 11879546
	lxi	bc,9835H	; Multiplier constant
	lxi	de,447AH
	call	FMul
	; Add small constant
	lxi	bc,6828H	; Addend constant
	lxi	de,0B146H
	call	FAdd
	; Scramble mantissa bytes and normalize to 0-1 range
	call	FCopyToBCDE	; Get result to BCDE
	mov	a,e		; Swap low and high mantissa bytes
	mov	e,c
	mov	c,a
	mvi	m,80H		; Set FTEMP_SIGN = positive
	dcx	hl
	mov	b,m		; Save exponent
	mvi	m,80H		; Set exponent = 0 (value < 1)
	call	FNormaliseNoNeg	; Normalize result (skip negation)
	; Save new seed and return
	lxi	hl,RND_SEED
	jmp	FCopyToMem	; Store new seed and return
RND_SEED:
	db	52H,0C7H,4FH,80H ; Initial seed: 0.811635
;-----------------------------------------------------------------------------
; SIN - Sine Function (Optional Function #3)
; Uses Taylor series approximation after reducing angle to -0.25 to 0.25
; Input: angle in radians in FACCUM
;-----------------------------------------------------------------------------
Sin:	call	FPush		; Push x (radians)
	; Scale to turns: u = x / (2*pi)
	lxi	bc,8349H	; BCDE = 2*pi = 6.283185
	lxi	de,0FDBH
	call	FLoadFromBCDE	; Load 2*pi
	pop	bc		; Get x
	pop	de
	call	FDiv		; u = x / 2pi
	; Get fractional part: u = u - INT(u)
	call	FPush		; Push u
	call	Int		; INT(u)
	pop	bc		; Get u
	pop	de
	call	FSub		; u = u - INT(u), now -1 < u < 1
	; Reduce to quadrant: subtract 0.25
	lxi	bc,7F00H	; BCDE = 0.25
	mov	d,c
	mov	e,c
	call	FSub		; u = u - 0.25
	; Check sign for quadrant adjustment
	rst	5		; FTestSign
	stc			; Set carry (no negate needed)
	jp	SinQuadrant	; If positive, continue
	; Negative: add 0.5 and check again
	call	FAddMem		; Add ONE_HALF
	rst	5		; FTestSign again
	ora	a		; Clear carry (negate needed)
SinQuadrant:
	push	psw		; Save carry (negate flag)
	cp	FNegate		; If positive, negate
	; Add 0.25 back
	lxi	bc,7F00H	; BCDE = 0.25
	mov	d,c
	mov	e,c
	call	FAdd		; Adjust quadrant
	pop	psw
	cnc	FNegate		; Final sign adjustment
	; Now compute Taylor series for sine
	; sin(q)  q * (c0 + q * (c1 + q * (c2 + q * (c3 + q * c4))))
	call	FPush		; Push q
	call	FCopyToBCDE	; Get q to BCDE
	call	FMul		; q = q * q
	call	FPush		; Push q
	lxi	hl,SIN_COEFFS	; Taylor coefficients table
	call	FLoadFromMem	; Load first coefficient
	pop	bc		; Get q
	pop	de
	mvi	a,04H		; 4 iterations
SinTaylorLoop:
	push	psw		; Save count
	push	de		; Push q
	push	bc
	push	hl		; Save coefficient pointer
	call	FMul		; acc = acc * q
	pop	hl		; Get coefficient pointer
	call	FLoadBCDEfromMem ; Load next coefficient
	push	hl		; Save updated pointer
	call	FAdd		; acc = acc * q + coeff
	pop	hl		; Restore pointer
	pop	bc		; Get q
	pop	de
	pop	psw		; Get count
	dcr	a
	jnz	SinTaylorLoop	; Continue if not done
	jmp	FMulEntry	; Final multiply by q and return (pops BC/DE from stack)
;-----------------------------------------------------------------------------
; Taylor series coefficients for sine
; These approximate: sin(pi*x) / (pi*x) for small x
;-----------------------------------------------------------------------------
SIN_COEFFS:
	db	0BAH,0D7H,1EH,86H ; 39.710670
	db	64H,26H,99H,87H	  ; -76.574982
	db	58H,34H,23H,87H	  ; 81.602234
	db	0E0H,5DH,0A5H,86H ; -41.341675
	db	0DAH,0FH,49H,83H  ; 6.283185 (2*pi)
	db	00H,00H		  ; End marker
;=============================================================================
; INITIALIZATION CODE (Part 1 - I/O Detection)
; This code runs once at cold start to detect terminal hardware
; and configure I/O ports. Memory is reclaimed after initialization.
;=============================================================================
DetectIO:
	in	0FFH		; Read sense switches
	ani	0F0H		; Mask upper nibble
	rrc			; Shift to get device type
	rrc
	cpi	3CH		; Check for specific device
	rz			; Return if match
	cpi	38H		; Check for alternate device
	stc			; Set carry
	jnz	IOConfigTable	; Not found, use config table
	; Read device-specific configuration
	lxi	hl,0FFFH	; Top of memory
	mov	c,m		; Get config byte
	dcx	hl
	mov	a,m		; Get another config byte
	ani	0F0H
	rrc
	rrc
IOConfigTable:
	push	psw
	mov	l,a		; Index into config table
	mvi	h,00H
	lxi	de,IO_CONFIG_TABLE
	dad	de		; HL = table entry
	mov	a,m		; Load configuration values
	inx	hl
	mov	d,m
	inx	hl
	mov	b,m
	inx	hl
	mov	e,m
	mov	h,a
	pop	psw
	push	psw
	mov	a,h
	jc	StoreIOConfig
	mov	a,c
StoreIOConfig:
	sta	0DA0H		; Store I/O port
	pop	psw
	lxi	hl,DoOptionalFns ; Return address after I/O config
	push	hl
	mvi	c,0FFH
	cpi	10H
	lxi	hl,Start
	shld	D038F		; Store jump address
	jz	IOConfigAlt
	cpi	08H
	rnc			; Return if device type >= 8
	adi	11H
	push	psw
	mvi	a,03H
	call	IOPortOut
	pop	psw
	jmp	IOPortOut
IOConfigAlt:
	xra	a
	call	IOPortOut
	call	IOPortInc
	call	IOPortInc
	cma
	mvi	c,01H
	call	IOPortInc
	push	hl
	lhld	IOPortOut
	mvi	l,0DBH
	shld	D038F
	pop	hl
	mvi	a,2CH
	dcr	m
	call	IOPortOut
	dcr	m
	dcr	m
	dcr	m
IOPortInc:
	lxi	hl,0DA0H
	inr	m
IOPortOut:
	out	10H		; Output to I/O port
	ret
;-----------------------------------------------------------------------------
; I/O Configuration Table
; Contains device-specific parameters for different terminal types
;-----------------------------------------------------------------------------
IO_CONFIG_TABLE:
	db	10H,0CAH,01H,02H ; Device 0 config
	db	10H,0CAH,01H,02H ; Device 1 config
	db	00H,0C2H,01H,80H ; Device 2 config
	db	06H,0C2H,01H,80H ; Device 3 config
	db	20H,0CAH,80H,80H ; Device 4 config
	db	04H,0CAH,02H,01H ; Device 5 config
	db	24H,0CAH	 ; Device 6 config (partial)
	db	40H,40H		 ; More config data
;-----------------------------------------------------------------------------
; ConfigIO - Configure I/O code with detected hardware settings
; Called after DetectIO to set up I/O port addresses in the code
;-----------------------------------------------------------------------------
DoOptionalFns:
ConfigIO:
	mov	h,d		; Get detected I/O parameters
	mov	l,b
	shld	0396H		; Patch InputChar device-ready check
	mov	a,h
	ani	0C8H		; Mask for TestBreakKey
	mov	h,a
	shld	0484H		; Patch TestBreakKey
	xchg
	shld	D0387		; Patch output port address
	lda	0DA0H		; Get input port number
	sta	0394H		; Patch InputChar port
	sta	0482H		; Patch TestBreakKey port
	inr	a
	sta	039BH		; Patch another I/O reference
	add	c
	sta	D0385		; Store print buffer offset
	inr	a
	sta	D038D		; Store another buffer offset
	ret

	db	0, 0		; Padding/unused

;=============================================================================
; Init - Initialization Code
; This code runs once at startup, asks user for memory size and terminal
; width, then initializes BASIC and prints "XXXX BYTES FREE"
; This memory is reclaimed for program storage after init completes.
;=============================================================================
Init:	lxi	hl,0F40H	; Default top of memory (3904 bytes)
	sphl			; Set stack pointer
	shld	STACK_TOP	; Save stack top
	call	DetectIO	; Detect and configure I/O hardware
	lxi	hl,0FFFFH	; Current line = -1 (direct mode)
	shld	CURRENT_LINE
	call	NewLine		; Print newline
; Ask user for memory size
AskMemorySize:
	lxi	hl,szMemorySize	; "MEMORY SIZE"
	call	PrintStringLoop	; Print (HL already at first char)
	call	InputLineWithQ	; Get user input with "? " prompt
	jc	AskMemorySize	; Retry on error
	rst	2		; NextChar
	ora	a		; Empty input?
	jnz	ParseMemorySize	; No, parse the number
	; Auto-detect memory size
	lxi	hl,0EFAH	; Start just above init code
AutoDetectMem:
	inx	hl		; Check next byte
	mov	a,h		; Check for wrap to 0000
	ora	l
	jz	GotMemoryTop	; Wrapped, use previous address
	mov	a,m		; Read memory
	cma			; Complement
	mov	m,a		; Write back
	cmp	m		; Did it stick?
	jz	AutoDetectMem	; Yes, continue
	jmp	GotMemoryTop	; No, found top of RAM
ParseMemorySize:
	lxi	hl,LINE_BUFFER	; Parse number from input
	call	LineNumberFromStr
	mov	a,m		; Check for trailing garbage
	ora	a
	jnz	SyntaxError
	xchg			; HL = memory size
GotMemoryTop:
	dcx	hl		; HL = last usable address (top-1)
	push	hl		; Save memory top on stack
;-----------------------------------------------------------------------
; Ask user for terminal width (default 72 if empty)
;-----------------------------------------------------------------------
AskTerminalWidth:
	lxi	hl,szTerminalWidth
	call	PrintStringLoop	; Print (HL already at first char)
	call	InputLineWithQ	; Get input with "?" prompt
	jc	AskTerminalWidth ; On break, ask again
	rst	2		; NextChar - get first char
	ora	a		; Empty input?
	mvi	a,48H		; Default width = 72 (0x48)
	mov	e,a		; Save default in E
	jz	SetTermWidth	; If empty, use default
	call	LineNumberFromStr ; Parse width from input
	mov	a,e		; Get parsed width
	cpi	0FH		; Minimum width = 15
	jc	AskTerminalWidth ; Too small, ask again
SetTermWidth:
	sta	TERMINAL_WIDTH	; Store terminal width
;-----------------------------------------------------------------------
; Calculate last tab stop position
; Tab stops are every 14 characters. Calculate: width - (width % 14)
;-----------------------------------------------------------------------
CalcTabStop:
	sui	0EH		; Subtract 14
	jnc	CalcTabStop	; Loop until negative
	adi	1CH		; Add 28 (14*2) to restore + offset
	cma			; Negate to get -remainder
	inr	a
	add	e		; Add to width: last_tab = width - (width % 14)
	sta	05C5H		; Store last tab position
;-----------------------------------------------------------------------
; Optional function configuration (SIN, RND, SQR)
; User can disable functions to reclaim memory for program storage.
; Each function descriptor contains: base addr, prompt string, jump table entry
;-----------------------------------------------------------------------
AskOptionalFns:
	lxi	hl,OPT_FN_DESCS	; Point to function descriptors
OptFnLoop:
	rst	6		; PushNextWord - push program base for this fn
	lxi	de,szSIN	; End marker (first string after descriptors)
	rst	4		; CompareHLDE - past end of table?
	jz	OptFnDone	; Yes, done with optional functions
	rst	6		; PushNextWord - get prompt string address
	xthl			; HL = prompt string, stack has descriptor ptr
	call	PrintStringLoop	; Print prompt (HL already at first char)
	call	InputLineWithQ	; Get Y/N response
	rst	2		; NextChar - get first char of response
	pop	hl		; Restore descriptor pointer
	cpi	59H		; 'Y' - want this function?
OptFnDone:
	pop	de		; Get program base address
	jz	InitComplete	; Yes or end of table, keep function
	cpi	4EH		; 'N' - don't want this function?
	jnz	AskOptionalFns	; Invalid response, start over
	; User said No - disable the function
	rst	6		; PushNextWord - get jump table entry address
	xthl			; HL = jump table entry, stack has descriptor ptr
	lxi	de,FunctionCallError ; Error handler address
	mov	m,e		; Patch jump table to point to error
	inx	hl
	mov	m,d
	pop	hl		; Restore descriptor pointer
	jmp	OptFnLoop	; Process next function
;-----------------------------------------------------------------------
; Initialization complete - set up program base and memory
;-----------------------------------------------------------------------
InitComplete:
	xchg			; HL = program base address (from DE)
	mvi	m,00H		; Write null byte at program base
	inx	hl
	shld	PROGRAM_BASE	; Store program base address
	xthl			; HL = memory top, push program base
	lxi	de,0F40H	; Minimum memory required
	rst	4		; CompareHLDE - enough memory?
	jc	OutOfMemory	; No, error
	pop	de		; DE = program base
	sphl			; Set stack pointer to memory top
	shld	STACK_TOP	; Save stack top
	xchg			; HL = program base, DE = stack top
	call	CheckEnoughMemPushHL ; Entry at E5 byte (PUSH HL)
	; Calculate free bytes: (stack_top - program_base) - 16
	mov	a,e		; DE still has stack top
	sub	l
	mov	l,a
	mov	a,d
	sbb	h
	mov	h,a		; HL = stack_top - program_base
	lxi	bc,0FFF0H	; -16 for overhead
	dad	bc		; HL = free bytes
	call	PrintInt	; Print free byte count
	lxi	hl,szBytesFree	; " BYTES FREE" message
	call	PrintStringLoop	; Print (HL already at first char)
	; Patch startup code for subsequent runs
	lxi	hl,PrintStringLoop ; After first run, Main should call
	shld	0205H		;   PrintStringLoop (skip INX HL)
	call	Run		; Initialize variables (NEW without msg)
	; Redirect cold start to warm start
	lxi	hl,Main		; Future starts go to Main
	shld	0002H		;   instead of Init
	pchl			; Jump to Main
;-----------------------------------------------------------------------
; Optional Function Descriptors
; Each entry: program_base (DW), prompt_string (DW), jump_table_entry (DW)
; If user says Yes, program_base becomes the start of user program storage
; If No, the jump_table_entry is patched to point to FunctionCallError
;-----------------------------------------------------------------------
OPT_FN_DESCS:
	; SIN function descriptor
	dw	0D22H		; Program base if SIN enabled
	dw	szSIN		; Prompt string "SIN"
	dw	004FH		; Jump table entry for SIN
	; RND function descriptor
	dw	0CA0H		; Program base if RND enabled (SIN disabled)
	dw	szRND		; Prompt string "RND"
	dw	004DH		; Jump table entry for RND
	; SQR function descriptor
	dw	0C6DH		; Program base if SQR enabled (SIN,RND disabled)
	dw	szSQR		; Prompt string "SQR"
	dw	004BH		; Jump table entry for SQR
	; End marker / minimum program base
	dw	0C2FH		; Program base if all optional fns disabled
;-----------------------------------------------------------------------
; Initialization String Constants
;-----------------------------------------------------------------------
szSIN:	db	'SIN',0		; Optional function prompts
szRND:	db	'RND',0
szSQR:	db	'SQR',0
szTerminalWidth:
	db	'TERMINAL WIDTH',0
szMemorySize:
	db	'MEMORY SIZE'

	end