; 4K BASIC Version 4.0 for Altair 8800
; Copyright 1976 MITS (Micro Instrumentation and Telemetry Systems)
; Written by Bill Gates, Paul Allen, and Monte Davidoff
;
; Annotated disassembly based on altairbasic.org reference for version 3.2
; Source file size: 3833 bytes

	.8080

	ORG	0000H

;=============================================================================
; RST 0 - Start / Cold Boot Entry Point
; The loader jumps here after loading BASIC from paper tape.
; Disables interrupts and jumps to initialization code.
;=============================================================================
Start:	DI			; Disable interrupts
	JMP	Init		; Jump to initialization

; Unused function pointers (possibly for 8K BASIC compatibility)
	DW	049EH		; Unused pointer
	DW	0807H		; Unused pointer (FWordToFloat in 3.2)

;=============================================================================
; RST 1 - SyntaxCheck
; Elegant syntax checking at runtime. The byte following the RST 1 call
; is the expected token. If it doesn't match the current program byte,
; a Syntax Error is raised. If it matches, the return address is adjusted
; and execution falls into NextChar. This saves 2 bytes on every syntax check.
;=============================================================================
SyntaxCheck:
	MOV	A,M		; A = current byte of BASIC program
	XTHL			; HL = return address (points to expected byte)
	CMP	M		; Compare program byte to expected byte
	INX	HL		; Advance return address past expected byte
	XTHL			; Restore HL, put adjusted return addr back
	JNZ	SyntaxError	; Error if bytes don't match
				; Fall through to NextChar if match

;=============================================================================
; RST 2 - NextChar
; Returns next character of input from buffer at HL, skipping spaces.
; Carry flag is set if character is numeric (0-9).
; Zero flag is set if null terminator reached.
;=============================================================================
NextChar:
	INX	HL		; Advance to next character
	MOV	A,M		; Get character
	CPI	':'		; Compare to colon (statement separator)
	RNC			; Return if >= ':' (not special)
	JMP	NextChar_tail	; Handle spaces and digits

;=============================================================================
; RST 3 - OutChar
; Outputs character in A to terminal, tracking cursor position.
;=============================================================================
OutChar:
	PUSH	PSW		; Save character
	LDA	TERMINAL_X	; Get current X position
	JMP	OutChar_tail	; Continue in main code
	NOP			; Pad to 8 bytes

;=============================================================================
; RST 4 - CompareHLDE
; Compares HL and DE with same logical results (Carry and Zero flags)
; as standard 8-bit compares. Returns Z if HL==DE.
;=============================================================================
CompareHLDE:
	MOV	A,H		; Compare high bytes first
	SUB	D
	RNZ			; Return if high bytes differ
	MOV	A,L		; Compare low bytes
	SUB	E
	RET

; Terminal cursor position tracking
TERMINAL_Y:	DB	01H	; Current Y position (row)
TERMINAL_X:	DB	00H	; Current X position (column)

;=============================================================================
; RST 5 - FTestSign
; Tests sign of floating point accumulator (FACCUM).
; Returns: A=0 and Z set if FACCUM==0
;          A=0xFF and S set if negative
;          A=0x01 if positive
;=============================================================================
FTestSign:
	LDA	FACCUM_EXP	; Get exponent byte of FACCUM
	ORA	A		; Test if zero
	JNZ	FTestSign_tail	; If not zero, determine sign
	RET			; Return with A=0, Z set

;=============================================================================
; RST 6 - PushNextWord
; Effectively PUSH (HL). Pushes the 16-bit value pointed to by HL onto stack.
; Uses self-modifying code for the return jump.
;=============================================================================
PushNextWord:
	XTHL			; Get return address into HL
	SHLD	PushRet+1	; Store return address in jump instruction
	POP	HL		; Restore original HL
	MOV	C,M		; Load low byte
	INX	HL
	MOV	B,M		; Load high byte
	INX	HL		; Advance HL past the word
	PUSH	BC		; Push the word onto stack
PushRet:
	JMP	PushRet		; Self-modifying: jump to return address
;=============================================================================
; Function Pointer Tables for Inline Functions
; These are the math functions that can be used in expressions (SGN, INT, etc.)
;=============================================================================
KW_INLINE_FNS:
	DW	Sgn		; SGN - return sign of number
	DW	Int		; INT - truncate to integer
	DW	Abs		; ABS - absolute value
	DW	FunctionCallError ; USR - user function (not impl in 4K)
	DW	Sqr		; SQR - square root
	DW	Rnd		; RND - random number
	DW	Sin		; SIN - sine function

;=============================================================================
; Keyword String Table
; All keywords stored with last character having bit 7 set.
; Token values start at 80H for END, 81H for FOR, etc.
;=============================================================================
KEYWORDS:
; General keywords (tokens 80H-93H)
	DB	'EN','D'+80H	; 80 - END
	DB	'FO','R'+80H	; 81 - FOR
	DB	'NEX','T'+80H	; 82 - NEXT
	DB	'DAT','A'+80H	; 83 - DATA
	DB	'INPU','T'+80H	; 84 - INPUT
	DB	'DI','M'+80H	; 85 - DIM
	DB	'REA','D'+80H	; 86 - READ
	DB	'LE','T'+80H	; 87 - LET
	DB	'GOT','O'+80H	; 88 - GOTO
	DB	'RU','N'+80H	; 89 - RUN
	DB	'I','F'+80H	; 8A - IF
	DB	'RESTOR','E'+80H ; 8B - RESTORE
	DB	'GOSU','B'+80H	; 8C - GOSUB
	DB	'RETUR','N'+80H	; 8D - RETURN
	DB	'RE','M'+80H	; 8E - REM
	DB	'STO','P'+80H	; 8F - STOP
	DB	'PRIN','T'+80H	; 90 - PRINT
	DB	'LIS','T'+80H	; 91 - LIST
	DB	'CLEA','R'+80H	; 92 - CLEAR
	DB	'NE','W'+80H	; 93 - NEW

; Supplementary keywords (tokens 94H-97H)
	DB	'TAB',28H+80H	; 94 - TAB(
	DB	'T','O'+80H	; 95 - TO
	DB	'THE','N'+80H	; 96 - THEN
	DB	'STE','P'+80H	; 97 - STEP

; Arithmetic/logical operators (tokens 98H-9EH)
	DB	'+'+80H		; 98 - +
	DB	'-'+80H		; 99 - -
	DB	'*'+80H		; 9A - *
	DB	'/'+80H		; 9B - /
	DB	'>'+80H		; 9C - >
	DB	'='+80H		; 9D - =
	DB	'<'+80H		; 9E - <

; Inline function keywords (tokens 9FH-A5H)
	DB	'SG','N'+80H	; 9F - SGN
	DB	'IN','T'+80H	; A0 - INT
	DB	'AB','S'+80H	; A1 - ABS
	DB	'US','R'+80H	; A2 - USR
	DB	'SQ','R'+80H	; A3 - SQR
	DB	'RN','D'+80H	; A4 - RND
	DB	'SI','N'+80H	; A5 - SIN

	DB	0		; Null terminator for keyword table
;=============================================================================
; General Keyword Function Pointer Table
; Indexed by (token - 80H) * 2 to get function address
;=============================================================================
KW_GENERAL_FNS:
	DW	Stop		; 80 - END (same as STOP)
	DW	For		; 81 - FOR
	DW	Next		; 82 - NEXT
	DW	FindNextStatement ; 83 - DATA (skip to next statement)
	DW	Input		; 84 - INPUT
	DW	Dim		; 85 - DIM
	DW	Read		; 86 - READ
	DW	Let		; 87 - LET
	DW	Goto		; 88 - GOTO
	DW	Clear		; 89 - RUN (clear then run)
	DW	If		; 8A - IF
	DW	Restore		; 8B - RESTORE
	DW	Gosub		; 8C - GOSUB
	DW	Return		; 8D - RETURN
	DW	Rem		; 8E - REM
	DW	Stop		; 8F - STOP
	DW	Print		; 90 - PRINT
	DW	List		; 91 - LIST
	DW	ResetAll	; 92 - CLEAR
	DW	New		; 93 - NEW

;=============================================================================
; Arithmetic Operator Table
; Each entry: precedence (1 byte), function address (2 bytes)
;=============================================================================
KW_ARITH_OP_FNS:
	DB	79H		; + precedence
	DW	FAdd		; + function
	DB	79H		; - precedence
	DW	FSub		; - function
	DB	7CH		; * precedence (higher than +/-)
	DW	FMul		; * function
	DB	7CH		; / precedence
	DW	FDiv		; / function

;=============================================================================
; Error Code Table
; Two-character codes for each error type (indexed by error number)
;=============================================================================
ERROR_CODES:
	DB	'NF'		; 00 - NEXT without FOR
	DB	'SN'		; 02 - Syntax error
	DB	'RG'		; 04 - RETURN without GOSUB
	DB	'OD'		; 06 - Out of Data
	DB	'FC'		; 08 - Illegal Function Call
	DB	'OV'		; 0A - Overflow
	DB	'OM'		; 0C - Out of Memory
	DB	'UL'		; 0E - Undefined Line
	DB	'BS'		; 10 - Bad Subscript
	DB	'DD'		; 12 - Duplicate Definition
	DB	'/0'		; 14 - Division by Zero
	DB	'ID'		; 16 - Illegal Direct mode

;=============================================================================
; Global Variables
;=============================================================================
STACK_TOP:	DW	0F40H	; Highest memory address for stack
CURRENT_LINE:	DW	0FFFEH	; Line number being executed (FFFF = direct mode)
PROGRAM_BASE:	DW	0F41H	; Start of program storage
COMMA_PREFIX:	DB	','	; Prefix for LINE_BUFFER (used by READ/INPUT)
LINE_BUFFER:	DS	8	; Input buffer (continues to 72 chars total)

;=============================================================================
; String Constants
;=============================================================================
szBytesFree:
	DB	' BYTES FREE',0DH
szVersion:
	DB	'4K BASIC 4.0',0DH
szCopyright:
	DB	'COPYRIGHT MITS 1976',0
; Jump table for I/O routines (modified by Init for different hardware)
IO_WAIT_IN:	DW	0393H		; Wait for input ready routine
IO_GET_CHAR:	DW	0384H		; Get character routine
IO_PUT_CHAR:	DW	0481H		; Put character routine

; More global variables (initialized to 0)
	DW	0		; Reserved
RANDOM_SEED:	DW	0D69H		; Random number seed
EXPR_STACK:	DW	0D92H		; Expression evaluation stack pointer
	DW	0		; Reserved
	DW	0		; Reserved
	DW	0		; Reserved
	DW	0		; Reserved
	DW	0		; Reserved
DIM_OR_EVAL:	DB	0		; Flag: 0=evaluating, NZ=DIM'ing
INPUT_OR_READ:	DB	0		; Flag: 0=INPUT, NZ=READ
PROG_PTR_TEMP:	DW	0		; Temporary program pointer
EXPR_PTR_TEMP:	DW	0		; Expression evaluator temp pointer
VAR_BASE:	DW	0		; Start of variable storage
VAR_ARRAY_BASE:	DW	0		; Start of array storage
VAR_TOP:	DW	0		; Top of variable/array storage
DATA_PROG_PTR:	DW	0		; Current DATA statement pointer

; Floating point accumulator (FACCUM) - 4 bytes
FACCUM:		DB	0		; FACCUM byte 0 (low mantissa)
FACCUM_1:	DB	0		; FACCUM byte 1
FACCUM_2:	DB	0		; FACCUM byte 2 (high mantissa + sign)
FACCUM_EXP:	DB	0		; FACCUM exponent

FTEMP_SIGN:	DB	0		; Temp sign during FP operations

; FBUFFER - 12 byte buffer used by FOut and Sqr
FBUFFER:	DS	12		; Float output/sqrt buffer

;=============================================================================
; More String Constants
;=============================================================================
szError:
	DB	' ERROR',0
szIn:
	DB	' IN ',0
szOK:
	DB	0DH,'OK',0DH,0
;=============================================================================
; GetFlowPtr - Find Flow Control Structure on Stack
; Sets HL to point to the appropriate flow struct (FOR/GOSUB) on stack.
; For NEXT, DE points to the loop variable to match against FOR structs.
; Returns with A = keyword ID byte (81H for FOR, 8CH for GOSUB)
;=============================================================================
GetFlowPtr:
	LXI	HL,4		; Skip past 2 return addresses on stack
	DAD	SP		; HL = SP + 4
GetFlowLoop:
	MOV	A,M		; Get keyword ID byte
	INX	HL		; Point to flow struct
	CPI	81H		; Is it FOR (81H)?
	RNZ			; Return if not FOR (found GOSUB or end)
	; For FOR structs, check if variable matches
	RST	6		; Push (HL) = variable address from FOR
	XTHL			; HL = variable address
	RST	4		; Compare HL with DE (NEXT's variable)
	LXI	BC,13		; Size of FOR flow struct
	POP	HL		; Restore HL
	RZ			; Return if variables match
	DAD	BC		; Skip to next flow struct
	JMP	GetFlowLoop	; Try next struct

;=============================================================================
; CopyMemoryUp - Copy Memory Block Upward
; Copies from HL to BC, going backwards (down) until HL==DE.
; Used to make room for inserting program lines.
;=============================================================================
CopyMemoryUp:
	CALL	CheckEnoughMem	; Make sure there's room
	PUSH	BC		; Exchange BC and HL
	XTHL
	POP	BC
CopyMemLoop:
	RST	4		; Compare HL and DE
	MOV	A,M		; Get source byte
	STAX	BC		; Store to destination
	RZ			; Done when HL==DE
	DCX	BC		; Move backward
	DCX	HL
	JMP	CopyMemLoop

;=============================================================================
; CheckEnoughVarSpace - Check Variable Storage Space
; Checks that there's room for C*2 bytes on top of VAR_TOP before stack.
;=============================================================================
CheckEnoughVarSpace:
	PUSH	HL
	LHLD	VAR_TOP		; Get top of variable storage
	MVI	B,0		; BC = C * 2
	DAD	BC
	DAD	BC
; Fall through to CheckEnoughMem

;=============================================================================
; CheckEnoughMem - Check Stack Space
; Checks that HL is at least 32 bytes away from stack pointer.
; If not, falls through to OutOfMemory error.
;=============================================================================
CheckEnoughMem:
	MVI	A,0E5H		; Calculate FFDE - HL (-34 bytes margin)
	MVI	A,0DEH		; (Self-modifying: first byte overwritten)
	SUB	L
	MOV	L,A
	MVI	A,0FFH
	SBB	H
	MOV	H,A
	DAD	SP		; Add stack pointer
	POP	HL
	RC			; Return if enough room (no carry)

;=============================================================================
; Error Entry Points
; Uses LXI trick: LXI B,xxxx is 01 xx xx, which skips over 2 bytes
;=============================================================================
OutOfMemory:
	MVI	E,0CH		; Error code 0C (OM - Out of Memory)
	DB	01H		; LXI B opcode - skip next 2 bytes
SyntaxError:
	MVI	E,02H		; Error code 02 (SN - Syntax error)
	DB	01H		; LXI B opcode - skip next 2 bytes
DivByZero:
	MVI	E,14H		; Error code 14 (/0 - Division by Zero)
;=============================================================================
; Error - Print Error Message and Return to Main Loop
; E = error code (offset into ERROR_CODES table)
;=============================================================================
Error:
	CALL	ResetStack	; Reset stack pointer
	CALL	NewLine		; Print newline
	LXI	HL,ERROR_CODES	; Point to error code table
	MOV	D,A		; D = 0 (from NewLine)
	MVI	A,'?'		; Print '?'
	RST	3
	DAD	DE		; HL = ERROR_CODES + E
	MOV	A,M		; Get first char of error code
	RST	3		; Print it
	RST	2		; Advance HL, get second char
	RST	3		; Print it
	LXI	HL,szError	; Point to " ERROR" string
	CALL	PrintStr	; Print it
	LHLD	CURRENT_LINE	; Get current line number
	MOV	A,H		; Check if in direct mode (FFFF)
	ANA	L
	INR	A		; A = 0 if FFFF (direct mode)
	CNZ	PrintIN		; Print " IN <line>" if running program
	DB	01H		; LXI B - skip next 2 bytes

;=============================================================================
; Stop / End - Stop Program Execution
; STOP and END keywords are synonymous
;=============================================================================
Stop:
	RNZ			; Syntax error if arguments given
StopPop:
	POP	BC		; Discard return address
StopCont:
	MVI	A,0C1H		; (Placeholder byte - part of LXI trick)

;=============================================================================
; Main - The BASIC Prompt Loop
; Prints "OK", gets user input, and either executes or stores program lines
;=============================================================================
Main:
	LXI	HL,szOK		; Point to "\rOK\r" string
	CALL	PrintStr	; Print "OK" prompt
;-----------------------------------------------------------------------------
; GetNonBlankLine - Get a line of input from the user
;-----------------------------------------------------------------------------
GetNonBlankLine:
	LXI	HL,0FFFFH	; Set line number to FFFF (direct mode)
	SHLD	CURRENT_LINE
	CALL	InputLine	; Get line of input
	RST	2		; Get first char
	INR	A		; Test if A==0 without affecting carry
	DCR	A		; (INR/DCR don't affect carry)
	JZ	GetNonBlankLine	; Loop if blank line
	PUSH	PSW		; Save carry flag (set if first char is digit)
	CALL	LineNumberFromStr ; Try to parse line number into DE
	PUSH	DE		; Save line number
	CALL	Tokenize	; Tokenize the input line
	MOV	B,A		; B = 0 (from Tokenize), BC = line length
	POP	DE		; DE = line number
	POP	PSW		; Restore carry flag
	JNC	Exec		; If no line number, execute immediately

;-----------------------------------------------------------------------------
; StoreProgramLine - Store a numbered line in program memory
;-----------------------------------------------------------------------------
StoreProgramLine:
	PUSH	DE		; Save line number
	PUSH	BC		; Save line length
	RST	2		; Get first char of tokenized line
	ORA	A		; Z set if line is empty (deleting line)
	PUSH	PSW		; Save empty-line flag
	CALL	FindProgramLine	; Find where line should go (BC=addr)
	PUSH	BC		; Save line address
	JNC	InsertLine	; Jump if line doesn't exist yet

; Line exists - remove it first by moving rest of program down
RemoveLine:
	XCHG			; DE = next line address
	LHLD	VAR_BASE	; HL = end of program
RemoveLoop:
	LDAX	DE		; Copy byte from DE to BC
	STAX	BC
	INX	BC
	INX	DE
	RST	4		; Compare HL and DE
	JNZ	RemoveLoop	; Loop until DE reaches VAR_BASE
	MOV	H,B		; Update VAR_BASE
	MOV	L,C
	SHLD	VAR_BASE

InsertLine:
	POP	DE		; DE = line address
	POP	PSW		; Restore empty-line flag
	JZ	UpdateLinks	; If empty line, just update links
	; Make room for new line
	LHLD	VAR_BASE	; HL = end of program
	XTHL			; HL = line length, stack = VAR_BASE
	POP	BC		; BC = VAR_BASE
	DAD	BC		; HL = new VAR_BASE
	PUSH	HL
	CALL	CopyMemoryUp	; Move program up to make room
	POP	HL
	SHLD	VAR_BASE	; Update VAR_BASE
	XCHG			; HL = line address
	MOV	M,H		; Store (temporary) next-line pointer
	POP	DE		; DE = line number
	INX	HL
	INX	HL
	MOV	M,E		; Store line number (low)
	INX	HL
	MOV	M,D		; Store line number (high)
	INX	HL
	; Copy tokenized line from buffer
	LXI	DE,LINE_BUFFER
CopyLine:
	LDAX	DE		; Copy byte
	MOV	M,A
	INX	HL
	INX	DE
	ORA	A		; Check for null terminator
	JNZ	CopyLine

;-----------------------------------------------------------------------------
; UpdateLinks - Rebuild program line linked list
;-----------------------------------------------------------------------------
UpdateLinks:
	CALL	ResetAll	; Reset to start of program
	INX	HL
	XCHG
UpdateLinkLoop:
	MOV	H,D		; HL = current line
	MOV	L,E
	MOV	A,M		; Check for end of program
	INX	HL
	ORA	M		; (next-line ptr is 0000)
	JZ	GetNonBlankLine	; Done - go get next input
	INX	HL		; Skip line number
	INX	HL
	INX	HL
	XRA	A		; Find end of line (null byte)
FindLineEnd:
	CMP	M
	INX	HL
	JNZ	FindLineEnd
	XCHG			; DE = next line address
	MOV	M,E		; Store next-line pointer
	INX	HL
	MOV	M,D
	JMP	UpdateLinkLoop
;=============================================================================
; FindProgramLine - Find Program Line by Number
; Input: DE = line number to find
; Output: BC = address of line (or where it should be inserted)
;         Carry set if line exists, clear if not found
;         HL = address of next line (if line exists)
;=============================================================================
FindProgramLine:
	LHLD	PROGRAM_BASE	; Start at beginning of program
FindLineLoop:
	MOV	B,H		; BC = current line address
	MOV	C,L
	MOV	A,M		; Check for end of program
	INX	HL
	ORA	M		; (next-line ptr is 0000)
	DCX	HL
	RZ			; Return if end of program (line not found)
	PUSH	BC		; Save current line address
	RST	6		; Push next-line address
	RST	6		; Push line number
	POP	HL		; HL = line number from program
	RST	4		; Compare with DE (wanted line number)
	POP	HL		; HL = next line address
	POP	BC		; BC = current line address
	CMC			; Complement carry
	RZ			; Return if line numbers match (found)
	CMC			; Restore carry
	RNC			; Return if current > wanted (not found)
	JMP	FindLineLoop	; Try next line

;=============================================================================
; New - NEW Command - Clear Program Memory
;=============================================================================
New:
	RNZ			; Syntax error if arguments
; Fall through to Run for initialization
Run:
	LHLD	PROGRAM_BASE	; Get program base
	XRA	A		; Write null terminator (empty program)
	MOV	M,A
	INX	HL
	MOV	M,A
	INX	HL
	SHLD	VAR_BASE	; VAR_BASE = just after program

;=============================================================================
; Clear - CLEAR/RUN Command - Reset Variables
;=============================================================================
Clear:
	RNZ			; Syntax error if arguments
ClearVars:
	LHLD	PROGRAM_BASE	; Get program base
	DCX	HL		; Point to byte before program

;=============================================================================
; ResetAll - Reset All Variables and Pointers
;=============================================================================
ResetAll:
	SHLD	PROG_PTR_TEMP	; Save program pointer
	CALL	Restore		; Reset DATA pointer
	LHLD	VAR_BASE	; Reset variable pointers
	SHLD	VAR_ARRAY_BASE	; No arrays yet
	SHLD	VAR_TOP		; No variables yet

;=============================================================================
; ResetStack - Reset Stack Pointer
;=============================================================================
ResetStack:
	POP	BC		; Get return address
	LHLD	STACK_TOP	; Get stack top
	SPHL			; Reset stack pointer
	XRA	A		; Push 0 on stack (stack marker)
	MOV	L,A
	PUSH	HL
	PUSH	BC		; Put return address back
	LHLD	PROG_PTR_TEMP	; Restore program pointer
	RET
;=============================================================================
; InputLineWithPrompt - Get Input with "? " Prompt
; Used by INPUT statement
;=============================================================================
InputLineWithPrompt:
	MVI	A,'?'		; Print "? " prompt
	RST	3
	MVI	A,' '
	RST	3
	CALL	InputLine	; Get line of input
	INX	HL		; Point past comma prefix

;=============================================================================
; Tokenize - Convert Input Line to Tokenized Form
; Replaces keywords with single-byte tokens.
; Input: HL points to input buffer
; Output: C = length of tokenized line + overhead, A = 0
;=============================================================================
Tokenize:
	MVI	C,5		; Initialize length (4 bytes header + 1)
	LXI	DE,LINE_BUFFER	; Output pointer
TokenLoop:
	MOV	A,M		; Get input character
	CPI	' '		; Space?
	JZ	WriteChar	; Just write spaces
	MOV	B,A		; Save char in B
	CPI	'"'		; Quote (string literal)?
	JZ	FreeCopy	; Copy string without tokenizing
	ORA	A		; Null terminator?
	JZ	TokenExit	; Exit if end of input
	; Try to match a keyword
	PUSH	DE		; Save output pointer
	LXI	DE,KEYWORDS-1	; Point to keyword table
	PUSH	BC		; Save current char
	MVI	B,7FH		; Initialize keyword ID counter
	MOV	C,M		; Get input char (redundant but part of original)
	MOV	C,M
	XCHG			; HL = keyword ptr, DE = input ptr
NextKeyword:
	INX	HL		; Advance to next keyword char
	ORA	M		; Check for end of keyword (bit 7 set)
	JP	NextKeyword	; Loop if not end of keyword yet
	; Found end of keyword - advance to next keyword
	INR	B		; Increment keyword ID
	MOV	A,M		; Get keyword char
	ANI	7FH		; Mask off bit 7
	JZ	NotKeyword	; If zero, end of keyword table
	CMP	C		; Compare to input char
	JNZ	NextKeyword	; Try next keyword if no match
	; First char matches - check rest of keyword
	XCHG			; DE = keyword ptr, HL = input ptr
	PUSH	HL		; Save input position
	INX	DE		; Advance keyword ptr
KwCompare:
	LDAX	DE		; Get keyword char
	ORA	A		; Check bit 7 (end of keyword)
	JM	KwMatch		; Jump if matched entire keyword
	MOV	C,A		; Save keyword char
	RST	2		; Get next input char
	CMP	C		; Compare
	JZ	KwCompare	; Continue if match
	POP	HL		; Restore input position
	JMP	NextKeyword	; Try next keyword

KwMatch:
	POP	PSW		; Discard saved input position
	MOV	A,B		; A = keyword ID
	ORI	80H		; Set bit 7 (token marker)
	JP	WriteToken	; (Always jumps - LXI trick continues)
NotKeyword:
	; Not a keyword - output the literal character
	MOV	C,B		; Restore char from B
	POP	PSW		; Clean up stack
	XCHG			; Restore pointers
	XCHG
	MOV	A,C		; A = character to output
	POP	BC		; Restore saved BC
	POP	DE		; Restore output pointer
WriteToken:
WriteChar:
	INX	HL		; Advance input pointer
	STAX	DE		; Store character/token to output
	INX	DE		; Advance output pointer
	INR	C		; Increment length counter
	; Check if we just wrote REM token
	SUI	8EH		; REM token?
	JNZ	TokenLoop	; No - continue tokenizing
	MOV	B,A		; B = 0 (terminator for FreeCopy)
; Free copy loop - copy without tokenizing (for strings and REM)
FreeCopyLoop:
	MOV	A,M		; Get character
	ORA	A		; Null terminator?
	JZ	TokenExit	; Exit if end
	CMP	B		; Terminator character?
	JZ	WriteChar	; If so, write it and resume tokenizing
FreeCopy:
	INX	HL		; Advance input
	STAX	DE		; Copy character
	INR	C		; Increment length
	INX	DE
	JMP	FreeCopyLoop

TokenExit:
	LXI	HL,COMMA_PREFIX	; Point to comma before LINE_BUFFER
	STAX	DE		; Write three null terminators
	INX	DE
	STAX	DE
	INX	DE
	STAX	DE
	RET

;=============================================================================
; InputLine - Get a Line of Input from Terminal
; Handles backspace ('_') and line cancel ('@')
; Output: HL = LINE_BUFFER
;=============================================================================
Backspace:
	DCR	B		; Decrement char count
	DCX	HL		; Back up pointer
	RST	3		; Echo backspace char
	JNZ	InputNext	; Continue if not at start
LineCancel:
	RST	3		; Echo cancel char
	CALL	NewLine		; Print newline
InputLine:
	LXI	HL,LINE_BUFFER	; Point to input buffer
	MVI	B,1		; Initialize char count
InputNext:
	CALL	GetChar		; Get character from terminal
	MOV	C,A		; Save in C
	CPI	0DH		; Carriage return?
	JZ	TerminateLine	; Done if CR
	CPI	'@'		; Line cancel?
	JZ	LineCancel
	CPI	'_'		; Backspace?
	JZ	Backspace
	CPI	' '		; Control char?
	JC	InputNext	; Ignore if < space
	CPI	7DH		; DEL or higher?
	JNC	InputNext	; Ignore if >= 7D
	; Valid character - store it
	MOV	A,B		; Check line length
	CPI	72		; Buffer full?
	MVI	A,07H		; Bell character
	JNC	EchoChar	; Ring bell if full
	MOV	A,C		; Get character back
	MOV	M,C		; Store in buffer
	INX	HL		; Advance pointer
	INR	B		; Increment count
EchoChar:
	RST	3		; Echo character
	JMP	InputNext	; Get next character

;=============================================================================
; I/O Routines (hardware-dependent, modified by Init)
;=============================================================================
OutChar_tail:
	CPI	72		; Check column position
	CZ	NewLine		; Newline if at end
	INR	A		; Increment column
	STA	TERMINAL_X	; Save column
WaitTxReady:
	IN	00H		; Check transmit ready (port 0 status)
	ANI	0C8H		; Mask ready bit
	JNZ	WaitTxReady	; Wait until ready
	POP	PSW		; Restore character
	OUT	01H		; Send character (port 1 data)
	PUSH	PSW		; Save again
	IN	13H		; Check for paper tape mode
	POP	PSW
	RET

;-----------------------------------------------------------------------------
; GetChar - Get Character from Terminal
;-----------------------------------------------------------------------------
GetChar:
	IN	00H		; Check receive ready (port 0 status)
	ANI	01H		; Mask ready bit
	JNZ	GetChar		; Wait until ready
	IN	01H		; Get character (port 1 data)
	ANI	7FH		; Strip high bit
	RET
;=============================================================================
; LIST Handler
; Lists the program. As the stored program is in tokenised form (keywords are
; single-byte IDs), LIST decodes tokens back to keyword strings for display.
;=============================================================================
List:
	CALL	LineNumberFromStr	; Get line number argument into DE
	RNZ			; Return if non-numeric argument
	POP	BC		; Discard return address (we loop ourselves)
	CALL	FindProgramLine	; Find starting line, BC=line addr
	PUSH	BC		; Save line address
;-----------------------------------------------------------------------------
; ListNextLine - Loop through program lines
;-----------------------------------------------------------------------------
ListNextLine:
	POP	HL		; HL = current program line address
	RST	6		; Push (HL), (HL+1) - next line pointer
	POP	BC		; BC = next line address
	MOV	A,B		; Check if next line is null (end of program)
	ORA	C
	JZ	Main		; Exit to Main if at end
	CALL	TestBreakKey	; Allow user to break listing
	PUSH	BC		; Save next line address
	CALL	NewLine		; Print newline
	RST	6		; Push line number
	XTHL			; HL=line number, (SP)=prog ptr
	CALL	PrintInt	; Print line number
	MVI	A,' '		; Prepare to print space
	POP	HL		; HL = program line content pointer
;-----------------------------------------------------------------------------
; ListChar - Print characters, expanding tokens to keywords
;-----------------------------------------------------------------------------
ListChar:
	RST	3		; Print character in A
	MOV	A,M		; Get next character
	ORA	A		; Test for null (end of line)
	INX	HL		; Advance pointer
	JZ	ListNextLine	; If null, go to next line
	JP	ListChar	; If bit 7 clear, print and continue
	; Bit 7 set - this is a keyword token, need to expand it
	SUI	7FH		; Convert token to keyword index+1
	MOV	C,A		; C = keyword counter
	PUSH	HL		; Save program pointer
	LXI	DE,KEYWORDS	; DE = start of keyword table
	PUSH	DE
;-----------------------------------------------------------------------------
; ToNextKeyword - Scan through keyword table to find the right one
;-----------------------------------------------------------------------------
ToNextKeyword:
	LDAX	DE		; Get keyword character
	INX	DE		; Advance pointer
	ORA	A		; Test bit 7 (last char of keyword)
	JP	ToNextKeyword	; If not last char, keep scanning
	; Found end of a keyword
	DCR	C		; Decrement keyword counter
	POP	HL		; HL = start of this keyword
	JNZ	ToNextKeyword-1	; If not the one we want, keep going
;-----------------------------------------------------------------------------
; PrintKeyword - Print the keyword characters
;-----------------------------------------------------------------------------
PrintKeyword:
	MOV	A,M		; Get keyword character
	ORA	A		; Test bit 7
	JM	ListChar-1	; If last char, go back (POP HL first)
	RST	3		; Print character
	INX	HL		; Advance to next character
	JMP	PrintKeyword	; Continue printing keyword
;=============================================================================
; FOR Handler
; Although FOR indicates the beginning of a loop, the handler only gets called
; once. Subsequent iterations return to the statement AFTER FOR, not to FOR.
; FOR sets up a flow control structure (13 bytes) on the stack:
;   - 1 byte: KWID_FOR (81H)
;   - 2 bytes: loop variable address
;   - 4 bytes: STEP value (floating point)
;   - 1 byte: direction (01=forward, FF=backward)
;   - 4 bytes: TO value (limit, floating point)
;   - 2 bytes: line number of FOR statement
;   - 2 bytes: program pointer after FOR statement
;=============================================================================
For:
	CALL	Let		; Assign initial value to loop variable
	XTHL			; Swap prog ptr with return addr
	CALL	GetFlowPtr	; Check for existing FOR with same var
	POP	DE		; DE = program pointer
	JNZ	ForNoReuse	; If no existing FOR, skip cleanup
	DAD	BC		; HL = old SP + struct size (remove old struct)
	SPHL			; Clean up old FOR structure
ForNoReuse:
	XCHG			; HL = prog ptr, DE = stack ptr
	MVI	C,08H		; Check for 8*4=32 bytes stack space
	CALL	CheckEnoughVarSpace
	PUSH	HL		; Save program pointer
	CALL	FindNextStatement	; Find end of FOR statement
	XTHL			; Swap: (SP)=stmt end, HL=prog ptr
	PUSH	HL		; Push program pointer
	LHLD	CURRENT_LINE	; Get current line number
	XTHL			; Swap: (SP)=line number, HL=prog ptr
	RST	1		; Syntax check for 'TO' token
	DB	95H		; Token for TO
;-----------------------------------------------------------------------------
; Parse TO value and push onto stack
;-----------------------------------------------------------------------------
	CALL	ArithParse	; Evaluate TO expression
	PUSH	HL		; Save program pointer
	CALL	FCopyToBCDE	; Get TO value into BCDE
	POP	HL		; Restore program pointer
	PUSH	BC		; Push TO value (high word)
	PUSH	DE		; Push TO value (low word)
	; Initialize STEP value to 1.0 (8100 0000 = 1.0)
	LXI	BC,8100H	; B=81H (exponent), C=00
	MOV	D,C		; D=00
	MOV	E,D		; E=00
	; Check for optional STEP clause
	MOV	A,M		; Get next token
	CPI	97H		; Is it STEP token?
	MVI	A,01H		; Default direction = forward
	JNZ	PushStepValue	; If no STEP, use default 1.0
	; STEP clause present - evaluate it
	CALL	ArithParse+1	; Skip token and evaluate STEP
	PUSH	HL		; Save program pointer
	CALL	FCopyToBCDE	; Get STEP value into BCDE
	RST	5		; Test sign of STEP (sets A to direction)
	POP	HL		; Restore program pointer
PushStepValue:
	PUSH	BC		; Push STEP value (high word)
	PUSH	DE		; Push STEP value (low word)
	PUSH	PSW		; Push direction byte (1 or -1)
	INX	SP		; Adjust SP (only push 1 byte)
	PUSH	HL		; Push program pointer
	LHLD	PROG_PTR_TEMP	; Get loop variable address
	XTHL			; Swap: (SP)=var addr, HL=prog ptr
;-----------------------------------------------------------------------------
; EndOfForHandler - Push FOR token and fall into ExecNext
;-----------------------------------------------------------------------------
;=============================================================================
; ExecNext - Execute next statement
; Having executed one statement, moves to the next statement on the line
; or to the next line if there are no more statements.
;=============================================================================
ExecNext:
	CALL	TestBreakKey	; Give user chance to break execution
	MOV	A,M		; Get current character
	CPI	':'		; Is it statement separator?
	JZ	Exec		; If colon, execute next statement
	ORA	A		; Is it null (end of line)?
	JNZ	SyntaxError	; If not null or colon, syntax error
	; End of line - move to next line
	INX	HL		; Skip null terminator
	MOV	A,M		; Get low byte of next line address
	INX	HL
	ORA	M		; OR with high byte
	JZ	StopCont	; If both zero, end of program
	; More program lines exist
	INX	HL		; Point to line number
	MOV	E,M		; Get line number low byte
	INX	HL
	MOV	D,M		; Get line number high byte
	XCHG			; HL = line number
	SHLD	CURRENT_LINE	; Store current line number
	XCHG			; HL = program pointer
;-----------------------------------------------------------------------------
; Exec - Execute a statement of BASIC code pointed to by HL
;-----------------------------------------------------------------------------
Exec:
	RST	2		; Get first character of statement
	LXI	DE,ExecNext	; Return address after statement
	PUSH	DE		; Push return address
ExecStatement:
	RZ			; Return if empty statement
	SUI	80H		; Subtract keyword base
	JC	Let		; If < 80H, implicit LET statement
	CPI	14H		; Is it a general keyword (0-19)?
	JNC	SyntaxError	; If >= 20, syntax error
	; Look up keyword handler in function table
	RLC			; Multiply by 2 (word table)
	MOV	C,A		; BC = offset into table
	MVI	B,00H
	XCHG			; DE = program pointer
	LXI	HL,KW_GENERAL_FNS	; HL = function table
	DAD	BC		; HL = pointer to function address
	MOV	C,M		; Get function address low byte
	INX	HL
	MOV	B,M		; Get function address high byte
	PUSH	BC		; Push function address
	XCHG			; HL = program pointer
	RST	2		; Get next character
	RET			; Jump to keyword handler
;-----------------------------------------------------------------------------
; NextChar_tail - Continuation of RST 2 (NextChar)
; Skips spaces, sets carry if char >= '0', sets Z if char is null
;-----------------------------------------------------------------------------
NextChar_tail:
	CPI	' '		; Is it a space?
	JZ	NextChar	; If space, get next char
	CPI	'0'		; Compare to '0'
	CMC			; Complement carry (C set if digit)
	INR	A		; Set Z flag if A was 0
	DCR	A		; (without changing A)
	RET
;-----------------------------------------------------------------------------
; RESTORE Handler
; Resets the DATA pointer to just before the start of the program
;-----------------------------------------------------------------------------
Restore:
	XCHG			; Save HL in DE
	LHLD	PROGRAM_BASE	; Get start of program
	DCX	HL		; Point to byte before program
	SHLD	DATA_PROG_PTR	; Store as DATA pointer
	XCHG			; Restore HL
	RET
;-----------------------------------------------------------------------------
; TestBreakKey - Check if user pressed Ctrl-C to break
; Returns if no key or non-break key, jumps to Stop if Ctrl-C
;-----------------------------------------------------------------------------
TestBreakKey:
	IN	00H		; Check if key pressed
	ANI	01H		; Mask ready bit
	RNZ			; Return if no key
	CALL	GetChar_tail	; Get the character
	CPI	03H		; Is it Ctrl-C (break)?
	JZ	Stop		; If so, stop program
	RET			; Otherwise return (key ignored)
;-----------------------------------------------------------------------------
; CharIsAlpha - Check if character at (HL) is alphabetic
; Returns: Carry clear if A-Z, Carry set otherwise
;-----------------------------------------------------------------------------
CharIsAlpha:
	MOV	A,M		; Get character
	CPI	'A'		; Compare to 'A'
	RC			; Return with carry if < 'A'
	CPI	'Z'+1		; Compare to 'Z'+1
	CMC			; Complement carry
	RET
;-----------------------------------------------------------------------------
; GetSubscript - Get array subscript as positive integer
; Evaluates expression and returns integer value in CDE
;-----------------------------------------------------------------------------
GetSubscript:
	RST	2		; Get next character
	CALL	ArithParse	; Evaluate expression
	RST	5		; Test sign of result
	JM	FunctionCallError	; Error if negative
	LDA	FACCUM+3	; Get exponent
	CPI	90H		; Check if > 32767
	JC	FAsInteger	; Convert to integer if valid
FunctionCallError:
	MVI	E,08H		; FC - Function Call error
	JMP	Error
;=============================================================================
; LineNumberFromStr - Parse line number from string
; Input: HL = string pointer
; Output: DE = line number (0-65529), Z flag set if valid number found
; Returns NZ if string doesn't start with a digit
; Maximum line number is 65529 (errors if > 6552 before last digit)
;=============================================================================
LineNumberFromStr:
	DCX	HL		; Back up to get char before current
	LXI	DE,0		; Initialize result to 0
NextLineNumChar:
	RST	2		; Get next non-space character
	RNC			; Return if not a digit (NC means < '0')
	PUSH	HL		; Save string pointer
	PUSH	PSW		; Save digit character
	LXI	HL,6552		; Check if result > 6552
	RST	4		; Compare HL to DE
	JC	SyntaxError	; Error if > 6552 (result would be > 65529)
	; Multiply current result by 10: DE = DE*10
	MOV	H,D		; HL = DE
	MOV	L,E
	DAD	DE		; HL = DE*2
	DAD	HL		; HL = DE*4
	DAD	DE		; HL = DE*5
	DAD	HL		; HL = DE*10
	; Add new digit
	POP	PSW		; Restore digit character
	SUI	'0'		; Convert ASCII to value
	MOV	E,A		; DE = digit value
	MVI	D,00H
	DAD	DE		; HL = result*10 + digit
	XCHG			; DE = new result
	POP	HL		; Restore string pointer
	JMP	NextLineNumChar	; Continue parsing
;=============================================================================
; GOSUB Handler
; Sets up a flow control structure on stack and falls into GOTO.
; Stack structure: KWID_GOSUB (8CH), line number (2), prog ptr (2)
;=============================================================================
Gosub:
	MVI	C,03H		; Need 3 words (6 bytes) stack space
	CALL	CheckEnoughVarSpace
	POP	BC		; Preserve return address
	PUSH	HL		; Push program pointer
	PUSH	HL		; Push again (will become line number)
	LHLD	CURRENT_LINE	; Get current line number
	XTHL			; Swap with stacked prog ptr
	MVI	A,8CH		; KWID_GOSUB token
	PUSH	PSW		; Push token (high byte)
	INX	SP		; Adjust SP (only pushed 1 byte)
	PUSH	BC		; Push return address
	; Fall through to GOTO
;=============================================================================
; GOTO Handler
; Sets program execution to continue from the line number argument.
;=============================================================================
Goto:
	CALL	LineNumberFromStr	; Get target line number in DE
	RNZ			; Return (error) if no line number
	CALL	FindProgramLine	; Find the line, BC = address
	MOV	H,B		; HL = line address
	MOV	L,C
	DCX	HL		; Adjust (FindProgramLine returns +1)
	RC			; Return if line found (carry set)
	MVI	E,0EH		; UL - Undefined Line error
	JMP	Error
;=============================================================================
; RETURN Handler
; Returns program execution to statement after the last GOSUB.
; Information about where to return is kept in flow struct on stack.
;=============================================================================
Return:
	RNZ			; No arguments allowed
	MVI	D,0FFH		; Search for any flow struct (not FOR)
	CALL	GetFlowPtr	; Find flow structure on stack
	SPHL			; Set SP to flow structure
	CPI	8CH		; Is it KWID_GOSUB?
	MVI	E,04H		; RG - Return without Gosub error
	JNZ	Error		; Error if not GOSUB
	POP	HL		; Get saved line number
	SHLD	CURRENT_LINE	; Restore current line
	LXI	HL,ExecNext	; Set return to ExecNext
	XTHL			; Swap with prog ptr, HL = prog ptr
	; Fall through to FindNextStatement
;=============================================================================
; FindNextStatement - Find end of statement or end of line
; Uses LXI trick: entered normally, C=':' (colon)
; Scans forward until null or C character found
;=============================================================================
FindNextStatement:
	DB	01H		; LXI B opcode - skip next 2 bytes
	DB	':'		; Statement separator (skipped)
;-----------------------------------------------------------------------------
; REM Handler - Entry point when REM keyword encountered
; Uses MVI C,00 to scan for null only (skip rest of line)
;-----------------------------------------------------------------------------
Rem:
	MVI	C,00H		; Scan for null terminator only
FindStmtLoop:
	MOV	A,M		; Get character
	ORA	A		; Is it null?
	RZ			; Return if end of line
	CMP	C		; Is it the target character?
	RZ			; Return if found
	INX	HL		; Advance pointer
	JMP	FindStmtLoop	; Keep scanning
;=============================================================================
; LET Handler
; Assigns a value to a variable. LET A=5 or just A=5 (implicit LET)
;=============================================================================
Let:
	CALL	GetVar		; Get variable address in DE
	RST	1		; Syntax check for '='
	DB	9DH		; Token for '='
;-----------------------------------------------------------------------------
; AssignVar - Assign expression result to variable at DE
; Input: DE = variable address, HL = expression to evaluate
;-----------------------------------------------------------------------------
AssignVar:
	PUSH	DE		; Save variable address
	CALL	ArithParse	; Evaluate expression into FACCUM
	XTHL			; HL = var addr, (SP) = prog ptr
	SHLD	PROG_PTR_TEMP	; Save var addr (for FOR loop detection)
	PUSH	HL		; Save var address
	CALL	FCopyToMem	; Copy FACCUM to variable
	POP	DE		; DE = var address
	POP	HL		; HL = program pointer
	RET
;=============================================================================
; IF Handler
; Evaluates a condition (lhs <op> rhs) where <op> is >, =, <, or combination
; Comparison operators are converted to a bitmask:
;   bit 0 = '>' present, bit 1 = '=' present, bit 2 = '<' present
; So <= and =< both equal 6, >= and => equal 3, <> equals 5
;=============================================================================
If:
	CALL	ArithParse	; Evaluate left-hand side expression
	MOV	A,M		; Get first char of comparison operator
	CALL	FPush		; Push LHS value onto stack
	MVI	D,00H		; D = comparison operator bitmask
GetCompareOpLoop:
	SUI	9CH		; Subtract KWID_> (9C=>, 9D==, 9E=<)
	JC	GotCompareOp	; Exit loop if not a comparison token
	CPI	03H		; Check if it's one of the 3 comp ops
	JNC	GotCompareOp	; Exit if not
	; Set the appropriate bit in D
	CPI	01H		; Compare to '=' offset
	RAL			; Rotate carry into bit 0
	ORA	D		; OR with existing bits
	MOV	D,A		; Save updated bitmask
	RST	2		; Get next character
	JMP	GetCompareOpLoop
GotCompareOp:
	MOV	A,D		; Get comparison bitmask
	ORA	A		; Any comparison operators?
	JZ	SyntaxError	; Error if no comparison operator
	PUSH	PSW		; Save comparison bitmask
	CALL	ArithParse	; Evaluate right-hand side
	RST	1		; Syntax check for THEN
	DB	96H		; Token for THEN
	DCX	HL		; Back up pointer
	POP	PSW		; Restore comparison bitmask
	POP	BC		; Pop LHS high word
	POP	DE		; Pop LHS low word
	PUSH	HL		; Save program pointer
	PUSH	PSW		; Save comparison bitmask
	CALL	FCompare	; Compare LHS to RHS (result in A)
	; Convert FCompare result (-1,0,1) to bit pattern and test
	INR	A		; -1->0, 0->1, 1->2
	RAL			; 0->0, 1->2, 2->4 (bits 0,1,2)
	POP	BC		; B = comparison bitmask
	ANA	B		; Test if result matches required comparison
	POP	HL		; Restore program pointer
	JZ	Rem		; If false, skip rest of line (like REM)
	; Condition is true - execute THEN clause
	RST	2		; Get first char after THEN
	JC	Goto		; If digit, implicit GOTO
	JMP	ExecStatement	; Otherwise execute statement
;-----------------------------------------------------------------------------
; PrintLoop re-entry point (backs up and gets next char)
;-----------------------------------------------------------------------------
PrintLoopEntry:
	DCX	HL		; Back up pointer
	RST	2		; Get next character
;=============================================================================
; PRINT Handler
; Prints expressions, string literals, with optional formatting (TAB, comma, ;)
;=============================================================================
Print:
	JZ	NewLine		; If end of line, just print newline
PrintLoop:
	RZ			; Return if end of statement
	CPI	'"'		; String literal?
	CZ	PrintString	; Print string if so
	JZ	PrintLoopEntry	; Loop back for more
	CPI	94H		; TAB( keyword?
	JZ	Tab		; Handle TAB function
	PUSH	HL		; Save program pointer
	CPI	','		; Comma (tab to next zone)?
	JZ	ToNextTabBreak	; Handle comma
	CPI	';'		; Semicolon (no spacing)?
	JZ	ExitTab		; Just continue (no spacing)
	; Must be an expression to print
	POP	BC		; Discard saved pointer
	CALL	ArithParse	; Evaluate expression
	PUSH	HL		; Save program pointer
	CALL	FOut		; Convert FACCUM to string
	CALL	PrintStringLoop	; Print the string
	MVI	A,' '		; Print trailing space
	RST	3
	POP	HL		; Restore program pointer
	JMP	PrintLoopEntry	; Continue with more print items
;-----------------------------------------------------------------------------
; TerminateInput - End input line with null and reset pointer
;-----------------------------------------------------------------------------
TerminateInput:
	MVI	M,00H		; Write null terminator
	LXI	HL,LINE_BUFFER	; Point to start of input buffer
;-----------------------------------------------------------------------------
; NewLine - Print CR/LF plus trailing nulls for teletype timing
;-----------------------------------------------------------------------------
NewLine:
	MVI	A,0DH		; Carriage return
	STA	TERMINAL_X	; Reset column counter
	RST	3		; Print CR
	MVI	A,0AH		; Line feed
	RST	3		; Print LF
	LDA	TERMINAL_Y	; Get null count for timing
PrintNullLoop:
	DCR	A		; Decrement counter
	STA	TERMINAL_X	; Store as column position
	RZ			; Return when done
	PUSH	PSW		; Save counter
	XRA	A		; A = 0 (null character)
	RST	3		; Print null
	POP	PSW		; Restore counter
	JMP	PrintNullLoop	; Loop
;-----------------------------------------------------------------------------
; PrintString - Print string literal (stops at null or closing quote)
;-----------------------------------------------------------------------------
PrintString:
	INX	HL		; Skip opening quote
PrintStringLoop:
	MOV	A,M		; Get character
	ORA	A		; Null terminator?
	RZ			; Return if end
	INX	HL		; Advance pointer
	CPI	'"'		; Closing quote?
	RZ			; Return if end of string
	RST	3		; Print character
	CPI	0DH		; Carriage return?
	CZ	NewLine		; If CR, do full newline
	JMP	PrintStringLoop	; Continue
;-----------------------------------------------------------------------------
; ToNextTabBreak - Move to next 14-column tab zone (comma handler)
;-----------------------------------------------------------------------------
ToNextTabBreak:
	LDA	TERMINAL_X	; Get current column
	CPI	56		; Past last tab zone?
	CNC	NewLine		; If so, go to new line
	JNC	ExitTab		; And continue
CalcSpaceCount:
	SUI	14		; Subtract zone width
	JNC	CalcSpaceCount	; Loop until negative
	CMA			; A = spaces to next zone - 1
	JMP	PrintSpaces	; Print the spaces
;-----------------------------------------------------------------------------
; TAB Handler - Tab to absolute column position
; TAB(n) moves to column n
;-----------------------------------------------------------------------------
Tab:
	CALL	GetSubscript	; Get column number in E
	RST	1		; Syntax check for ')'
	DB	')'
PrintSpaces:
	DCX	HL		; Back up pointer
	PUSH	HL		; Save program pointer
	LDA	TERMINAL_X	; Get current column
	CMA			; Negate
	ADD	E		; Add target column
	JNC	ExitTab		; If already past target, skip
PrintSpaceLoop:
	INR	A		; A = number of spaces to print
	MOV	B,A		; B = counter
	MVI	A,' '		; Space character
PrintSpaceInner:
	RST	3		; Print space
	DCR	B		; Decrement counter
	JNZ	PrintSpaceInner	; Loop until done
ExitTab:
	POP	HL		; Restore program pointer
	RST	2		; Get next character
	JMP	PrintLoop	; Continue printing
;=============================================================================
; INPUT Handler
; Lets user input values at a '?' prompt. INPUT only works in program mode.
;=============================================================================
Input:
	PUSH	HL		; Save program pointer
	LHLD	CURRENT_LINE	; Get current line number
	MVI	E,16H		; ID - Illegal Direct mode error
	INX	HL		; Check if line# = FFFF (direct mode)
	MOV	A,L
	ORA	H
	JZ	Error		; Error if in direct mode
	CALL	InputLineWithPrompt	; Get user input
	JMP	InputReadCommon	; Join common code
;=============================================================================
; READ Handler
; Reads data from DATA statements in the program
;=============================================================================
Read:
	PUSH	HL		; Save program pointer
	LHLD	DATA_PROG_PTR	; Get current DATA pointer
	ORI	0AFH		; Set A to non-zero (marks as READ)
;-----------------------------------------------------------------------------
; Common code for INPUT and READ
; A=0 for INPUT, A<>0 for READ
;-----------------------------------------------------------------------------
InputReadCommon:
	STA	INPUT_OR_READ	; Store INPUT/READ flag
	XTHL			; HL=prog ptr, (SP)=data ptr
	DB	01H		; LXI B - skip next 2 bytes
ReadNext:
	RST	1		; Syntax check for comma
	DB	','
	CALL	GetVar		; Get variable address in DE
	XTHL			; HL=data ptr, (SP)=prog ptr
	PUSH	DE		; Save variable address
	; Check what's at data pointer
	MOV	A,M		; Get data character
	CPI	','		; Is it comma separator?
	JZ	GotDataItem	; If comma, we have data
	ORA	A		; Is it null (end of line)?
	JNZ	SyntaxError	; Error if not null or comma
	; Need more data
	LDA	INPUT_OR_READ	; Check if INPUT or READ
	ORA	A
	INX	HL		; Advance past null
	JNZ	NextDataLine	; If READ, find next DATA line
	; INPUT needs another '?' prompt
	MVI	A,'?'		; Print question mark
	RST	3
	CALL	InputLineWithPrompt	; Get more input
GotDataItem:
	POP	DE		; Restore variable address
	INX	HL		; Skip comma/advance to data
	CALL	AssignVar	; Assign data to variable
	XTHL			; HL=prog ptr, (SP)=data ptr
	DCX	HL		; Back up (AssignVar advanced it)
	RST	2		; Get next character
	JNZ	ReadNext	; If more vars, continue
	; Done with all variables
	POP	DE		; DE = data pointer
	LDA	INPUT_OR_READ	; Check if INPUT or READ
	ORA	A
	RZ			; Return if INPUT
	XCHG			; HL = data pointer
	JNZ	SaveDataPtr	; Save new DATA pointer
;-----------------------------------------------------------------------------
; NextDataLine - Scan for next DATA statement
;-----------------------------------------------------------------------------
NextDataLine:
	POP	HL		; Get current position
ScanForData:
	RST	6		; Get next line address
	MOV	A,C		; Check if end of program
	ORA	B
	MVI	E,06H		; OD - Out of Data error
	JZ	Error		; Error if no more lines
	INX	HL		; Skip line number
	RST	2		; Get first keyword
	CPI	83H		; Is it DATA keyword?
	JNZ	NextDataLine	; If not, try next line
	POP	BC		; Discard saved pointer
	JMP	GotDataItem	; Found DATA, get item
;=============================================================================
; NEXT Handler
; Increments FOR loop variable and tests against limit.
; If loop not complete, jumps back to statement after FOR.
; If complete, removes FOR structure from stack and continues.
;=============================================================================
Next:
	CALL	GetVar		; Get loop variable address in DE
	SHLD	PROG_PTR_TEMP	; Save prog ptr (end of NEXT stmt)
	CALL	GetFlowPtr	; Find FOR struct on stack
	SPHL			; Set SP to FOR structure
	PUSH	DE		; Save loop variable address
	MOV	A,M		; Get direction byte from struct
	INX	HL		; Point to STEP value
	PUSH	PSW		; Save direction byte
	PUSH	DE		; Save var address again
	MVI	E,00H		; NF - Next without For error
	JNZ	Error		; Error if no FOR found
	; Load STEP value into FACCUM
	CALL	FLoadFromMem	; FACCUM = STEP value
	XTHL			; HL = var addr, (SP) = struct ptr
	; Add STEP to loop variable
	PUSH	HL		; Save var address
	CALL	FAddMem		; FACCUM = var + STEP
	POP	HL		; HL = var address
	CALL	FCopyToMem	; Store updated var value
	; Load TO limit value
	POP	HL		; HL = struct ptr (now at TO value)
	CALL	FLoadBCDEFromMem	; BCDE = TO limit
	; Compare var to limit
	PUSH	HL		; Save struct ptr
	CALL	FCompare	; Compare var to limit (-1,0,1)
	POP	HL		; Restore struct ptr
	POP	BC		; B = direction byte (1=up, -1=down)
	; Check if loop complete: compare result - direction = 0 means done
	SUB	B		; If result=direction, loop done
	CALL	FLoadBCDEFromMem	; BC=FOR stmt ptr, DE=line number
	JZ	ForLoopDone	; Jump if loop complete
	; Loop not done - go back to FOR statement
	XCHG			; HL = line number
	SHLD	CURRENT_LINE	; Set current line
	MOV	L,C		; HL = FOR statement pointer
	MOV	H,B
	JMP	EndOfForHandler	; Push FOR token and execute
ForLoopDone:
	SPHL			; Remove FOR struct from stack
	LHLD	PROG_PTR_TEMP	; Get ptr to end of NEXT
	JMP	ExecNext	; Continue after NEXT
;=============================================================================
; Expression Evaluation
; EvalExpression expects '(' first, ArithParse doesn't
; Returns result in FACCUM
;=============================================================================
EvalExpression:
	RST	1		; Syntax check for '('
	DB	'('
;-----------------------------------------------------------------------------
; ArithParse - Parse and evaluate arithmetic expression
; Uses operator precedence parsing with the KW_ARITH_OP_FNS table
;-----------------------------------------------------------------------------
ArithParse:
	DCX	HL		; Back up (will be advanced by NextChar)
ArithParseLoop:
	MVI	D,00H		; D = current precedence level
ArithParsePrecedence:
	PUSH	DE		; Save precedence
	MVI	C,01H		; Need 1 word stack space
	CALL	CheckEnoughVarSpace
	CALL	EvalTerm	; Evaluate a term (number, var, function)
	SHLD	EXPR_PTR_TEMP	; Save program pointer
;-----------------------------------------------------------------------------
; ArithParseOp - Check for arithmetic operator after term
;-----------------------------------------------------------------------------
ArithParseOp:
	LHLD	EXPR_PTR_TEMP	; Restore program pointer
	POP	BC		; B = previous precedence
	MOV	A,M		; Get next character
	MVI	D,00H
	SUI	98H		; Subtract KWID_+ (first arith op)
	RC			; Return if < '+' token
	CPI	04H		; Check if +, -, *, /
	RNC			; Return if not arithmetic operator
	; Calculate offset into KW_ARITH_OP_FNS table (3 bytes per entry)
	MOV	E,A		; E = operator index
	RLC			; A = index * 2
	ADD	E		; A = index * 3
	MOV	E,A		; DE = offset
	LXI	HL,KW_ARITH_OP_FNS
	DAD	DE		; HL points to table entry
	; Check operator precedence
	MOV	A,B		; A = previous precedence
	MOV	D,M		; D = this operator's precedence
	CMP	D		; Compare precedences
	RNC			; Return if prev >= this (lower precedence)
	; Higher precedence - need to evaluate this operator first
	INX	HL		; Point to function address
	PUSH	BC		; Save previous precedence
	LXI	BC,ArithParseOp	; Return address after operation
	PUSH	BC
	MOV	C,D		; Save new precedence in C
	CALL	FPush		; Push current value onto stack
	MOV	D,C		; Restore precedence to D
	RST	6		; Push function address from (HL)
	LHLD	EXPR_PTR_TEMP	; Restore program pointer
	JMP	ArithParsePrecedence	; Parse next term with new precedence
;-----------------------------------------------------------------------------
; EvalTerm - Evaluate a single term in an expression
; Can be: number, variable, function call, or (expression)
;-----------------------------------------------------------------------------
EvalTerm:
	RST	2		; Get next character
	JC	FIn		; If digit, parse number
	CALL	CharIsAlpha	; Check if alphabetic
	JNC	EvalVarTerm	; If letter, evaluate variable
	CPI	98H		; Is it '+' (unary plus)?
	JZ	EvalTerm	; Ignore leading '+'
	CPI	'.'		; Decimal point?
	JZ	FIn		; Parse number starting with '.'
	CPI	99H		; Is it '-' (unary minus)?
	JZ	EvalMinusTerm	; Handle negation
	SUI	9FH		; Subtract first inline function token
	JNC	EvalInlineFn	; If inline function, evaluate it
	; Must be parenthesized expression
EvalBracketed:
	CALL	EvalExpression	; Evaluate (expects and consumes '(')
	RST	1		; Syntax check for ')'
	DB	')'
	RET
;-----------------------------------------------------------------------------
; EvalMinusTerm - Evaluate negated term (-x)
;-----------------------------------------------------------------------------
EvalMinusTerm:
	CALL	EvalTerm	; Evaluate the term
	PUSH	HL		; Save program pointer
	CALL	FNegate		; Negate FACCUM
PopHLRet:
	POP	HL		; Restore program pointer
	RET
;-----------------------------------------------------------------------------
; EvalVarTerm - Evaluate a variable reference
;-----------------------------------------------------------------------------
EvalVarTerm:
	CALL	GetVar		; Get variable address in DE
	PUSH	HL		; Save program pointer
	XCHG			; HL = variable address
	CALL	FLoadFromMem	; Load variable value into FACCUM
	POP	HL		; Restore program pointer
	RET
;-----------------------------------------------------------------------------
; EvalInlineFn - Evaluate inline function (SGN, INT, ABS, etc.)
;-----------------------------------------------------------------------------
EvalInlineFn:
	MVI	B,00H		; Calculate offset into KW_INLINE_FNS
	RLC			; A = function index * 2
	MOV	C,A		; BC = offset
	PUSH	BC		; Save offset
	RST	2		; Get next char
	CALL	EvalBracketed	; Evaluate argument
	XTHL			; HL = offset, (SP) = prog ptr
	LXI	DE,PopHLRet	; Return address (POP HL; RET)
	PUSH	DE
	LXI	BC,KW_INLINE_FNS
	DAD	BC		; HL = function address ptr
	RST	6		; Push function address
	RET			; Jump to function
;=============================================================================
; DIM Statement Handler
; Declares arrays. DimContd is the continuation point for multiple dims.
; Format: DIM A(10), B(20), ...
;=============================================================================
DimContd:
	DCX	HL		; Back up program pointer
	RST	2		; NextChar - get next char
	RZ			; Return if end of line
	RST	1		; SyntaxCheck for comma
	DB	','
Dim:	LXI	BC,DimContd	; Set return address for next DIM item
	PUSH	BC
	ORI	0AFH		; Set A non-zero (fall into GetVar+1)
				; This flags we're declaring, not accessing
;=============================================================================
; GetVar - Variable Lookup/Creation
; Given variable name at HL, returns pointer to variable value in DE.
; If variable doesn't exist, allocates and initializes it.
; Entry: HL=program pointer to variable name
;        A=0 for normal access, NZ if called from DIM
; Exit:  DE=pointer to variable value (4 bytes)
;        HL=updated program pointer
;=============================================================================
	STA	DIM_OR_EVAL	; Store DIM/EVAL flag
	MOV	B,M		; B = first char of variable name
	CALL	CharIsAlpha	; Check if alphabetic
	JC	SyntaxError	; Error if not alpha
	XRA	A		; Clear A
	MOV	C,A		; C = 0 (default second char)
	RST	2		; NextChar
	JNC	GetVar		; If not alphanumeric, jump to GetVar
	MOV	C,A		; C = second char of variable name
	RST	2		; NextChar
; Check if next char is '(' - if so, it's an array access
GetVar:	SUI	'('		; Subtract '(' (28H)
	JZ	GetArrayVar	; Jump if array variable
	; Simple variable lookup - search VAR_BASE to VAR_ARRAY_BASE
	PUSH	HL		; Save program pointer
	LHLD	VAR_ARRAY_BASE	; DE = end of simple variables
	XCHG
	LHLD	VAR_BASE	; HL = start of simple variables
; Loop through existing variables looking for name match
FindVarLoop:
	RST	4		; CompareHLDE - at end of variables?
	JZ	AllocNewVar	; Not found, allocate new variable
	MOV	A,C		; Compare second char of name
	SUB	M		; With stored variable name
	INX	HL
	JNZ	FindVarNext	; No match on second char
	MOV	A,B		; Compare first char
	SUB	M
FindVarNext:
	INX	HL
	JZ	VarFound	; Names match - variable found
	INX	HL		; Skip over 4-byte value
	INX	HL
	INX	HL
	INX	HL
	JMP	FindVarLoop	; Try next variable
; Allocate new variable - but first check if called from EvalTerm
; If so, don't allocate (undeclared variable in expression = 0)
AllocNewVar:
	POP	HL		; HL = prog ptr
	XTHL			; (SP) = prog ptr, HL = return address
	PUSH	DE		; Save DE
	LXI	DE,EvalVarTerm+3 ; Address inside EvalTerm
	RST	4		; Compare return address
	POP	DE		; Restore DE
	JZ	CalledFromEval	; If from evaluator, don't allocate
	; OK to allocate - restore stack and proceed
	XTHL			; (SP) = ret addr, HL = prog ptr
	PUSH	HL		; Prog ptr back on stack
	PUSH	BC		; Save variable name BC
	LXI	BC,6		; Need 6 bytes (2 name + 4 value)
	LHLD	VAR_TOP		; Get current top
	PUSH	HL		; Save old top
	DAD	BC		; HL = new top
	POP	BC		; BC = old top
	PUSH	HL		; Save new top
	CALL	CopyMemoryUp	; Move array block up 6 bytes
	POP	HL
	SHLD	VAR_TOP		; Update VAR_TOP
	MOV	H,B		; HL = old VAR_TOP (where arrays were)
	MOV	L,C
	SHLD	VAR_ARRAY_BASE	; Update VAR_ARRAY_BASE
; Initialize new variable to zero (6 bytes)
InitVarLoop:
	DCX	HL
	MVI	M,0
	RST	4		; CompareHLDE - done?
	JNZ	InitVarLoop
	; Write variable name at start
	POP	DE		; DE = variable name (BC was pushed)
	MOV	M,E		; Store second char of name
	INX	HL
	MOV	M,D		; Store first char of name
	INX	HL
; Variable found or allocated - return with DE pointing to value
VarFound:
	XCHG			; DE = ptr to variable value
	POP	HL		; HL = program pointer
	RET
; Called from expression evaluator - return with FACCUM = 0
CalledFromEval:
	STA	FACCUM		; A=0 from compare, set FACCUM to 0
	POP	HL		; Restore program pointer
	RET
;=============================================================================
; GetArrayVar - Array Variable Access/Allocation
; BC = variable name, HL = prog ptr (after '(')
; DIM_OR_EVAL: 0 = accessing element, NZ = declaring array
;=============================================================================
GetArrayVar:
	PUSH	BC		; Save variable name
	LDA	DIM_OR_EVAL	; Get DIM/EVAL flag
	PUSH	PSW		; Save it
	CALL	GetSubscript	; Get subscript into DE
	RST	1		; SyntaxCheck for ')'
	DB	')'
	POP	PSW		; Restore DIM/EVAL flag
	STA	DIM_OR_EVAL
	XTHL			; HL = var name, (SP) = prog ptr
	XCHG			; DE = var name, HL = subscript
	; Multiply subscript by 4 (each element is 4 bytes)
	DAD	HL		; *2
	DAD	HL		; *4
	PUSH	HL		; Save subscript*4
	LHLD	VAR_ARRAY_BASE	; Start of array storage
	DB	01H		; LXI BC,... (skip next 2 bytes)
; Find array loop - search through arrays for matching name
FindArrayLoop:
	POP	BC		; BC = subscript*4 (or junk first time)
	DAD	BC		; Advance pointer
	XCHG			; DE = current array ptr
	PUSH	HL		; Save subscript*4
	LHLD	VAR_TOP		; End of array storage
	RST	4		; CompareHLDE - at end?
	XCHG
	POP	DE		; DE = subscript*4
	JZ	AllocArray	; Not found, allocate new array
	; Check if this array matches our variable name
	RST	6		; PushNextWord - get array name
	XTHL			; (SP) = array name, HL = subscript*4
	RST	4		; Compare names
	POP	HL		; HL = array name from this array
	RST	6		; PushNextWord - get array size
	JNZ	FindArrayLoop	; No match, try next array
	; Array found - check if we're in DIM (error - redim)
	LDA	DIM_OR_EVAL
	ORA	A
	MVI	E,12H		; DD error - Duplicate Definition
	JNZ	Error
; Array element retrieval - check subscript is in bounds
GetArrayElement:
	POP	DE		; DE = subscript*4
	DCX	DE		; Adjust for compare
	XTHL			; HL = subscript*4 from stack, (SP) = array size
	RST	4		; Compare subscript vs array size
	MVI	E,10H		; BS error - Bad Subscript
	JNC	Error		; Error if subscript >= size
	; Calculate element address
	POP	DE		; DE = array base (after size word)
	DAD	DE		; HL = element address
	POP	DE		; DE = prog ptr
	XCHG			; DE = element ptr, HL = prog ptr
	RET
;=============================================================================
; AllocArray - Allocate space for new array
; DE = variable name, HL = ptr to where array will be stored
; Stack has subscript*4 (the size requested)
;=============================================================================
AllocArray:
	MOV	M,E		; Store array name (2 bytes)
	INX	HL
	MOV	M,D
	INX	HL
	; Set default size to 44 bytes (11 elements * 4 bytes)
	; This is for implicit DIM (first use without DIM statement)
	LXI	DE,44		; Default size: 11 elements (0-10)
	LDA	DIM_OR_EVAL
	ORA	A
	JZ	StoreArraySize	; If not DIM, use default
	; DIM statement - get requested size from stack
	POP	DE		; DE = subscript*4 (requested size)
	PUSH	DE		; Put it back
	INX	DE		; Add 4 for one extra element
	INX	DE		; (subscript is 0-based)
	INX	DE
	INX	DE
StoreArraySize:
	PUSH	DE		; Save size
	MOV	M,E		; Store array size (2 bytes)
	INX	HL
	MOV	M,D
	INX	HL
	; Check memory and update VAR_TOP
	PUSH	HL		; Save ptr to array data area
	DAD	DE		; HL = new VAR_TOP
	CALL	CheckEnoughMem	; Make sure it fits
	SHLD	VAR_TOP		; Update VAR_TOP
	POP	DE		; DE = array data start
; Initialize all array elements to zero
InitArrayElements:
	DCX	HL
	MVI	M,0
	RST	4		; CompareHLDE - done?
	JNZ	InitArrayElements
	JMP	GetArrayElement	; Return element pointer
;=============================================================================
; Floating Point Math Routines
; FACCUM format: 4 bytes - 3 bytes mantissa + 1 byte exponent
; Mantissa is stored with implicit high bit, sign in bit 7 of high byte
; Exponent is biased by 128 (80H)
;=============================================================================

;-----------------------------------------------------------------------------
; FWordToFloat - Convert 16-bit integer (AB) to floating point
; Entry: A=high byte, B=low byte of integer
; Exit: Result in FACCUM
; NOTE: This routine is unused in 4K BASIC (for 8K compatibility)
;-----------------------------------------------------------------------------
FWordToFloat:
	MOV	D,B		; D = low byte
	MVI	E,0		; E = 0 (low mantissa)
	MVI	B,90H		; Exponent = 2^16 (144 decimal)
	JMP	FCharToFloat+5	; Continue in conversion routine

;-----------------------------------------------------------------------------
; FAddOneHalf - Add 0.5 to FACCUM (for rounding)
;-----------------------------------------------------------------------------
FAddOneHalf:
	LXI	HL,ONE_HALF	; Point to 0.5 constant
FAddMem:
	CALL	FLoadBCDEfromMem ; Load BCDE from memory
	JMP	FAdd+2		; Add to FACCUM

;-----------------------------------------------------------------------------
; FSub - Floating point subtraction: FACCUM = stack - FACCUM
; Entry: LHS on stack, RHS in FACCUM
;-----------------------------------------------------------------------------
	POP	BC		; Get LHS exponent/high mantissa
	POP	DE		; Get LHS low mantissa
FSub:	CALL	FNegate		; Negate RHS
	DB	21H		; LXI H,... to skip into FAdd
;-----------------------------------------------------------------------------
; FAdd - Floating point addition: FACCUM = BCDE + FACCUM
; Entry: LHS in BCDE, RHS in FACCUM
; Exit: Result in FACCUM
;-----------------------------------------------------------------------------
FAdd:	MOV	A,B		; Check LHS exponent
	ORA	A		; If LHS is zero
	RZ			; Just return (FACCUM unchanged)
	LDA	FACCUM		; Check RHS exponent
	ORA	A
	JZ	FLoadFromBCDE	; If RHS=0, result is LHS
	; Compare exponents to align mantissas
	SUB	B		; A = RHS exp - LHS exp
	JNC	FAddAligned	; If RHS exp >= LHS exp, continue
	; Swap LHS and RHS (make larger exponent in FACCUM)
	CMA			; Negate exponent difference
	INR	A
	XCHG			; Swap DE
	CALL	FPush		; Push FACCUM to stack
	XCHG
	CALL	FLoadFromBCDE	; Copy BCDE to FACCUM
	POP	BC		; Pop old FACCUM to BCDE
	POP	DE
FAddAligned:
	PUSH	PSW		; Save exponent difference
	CALL	FUnpackMantissas ; Unpack mantissas, A = sign relationship
	MOV	H,A		; H = sign relationship
	POP	PSW		; A = exponent difference
	CALL	FMantissaRtMult	; Shift LHS right by exp diff
	ORA	H		; Check sign relationship
	LXI	HL,FACCUM	; Point to FACCUM
	JP	FSubMantissas	; If signs differ, subtract
	; Signs same - add mantissas
	CALL	FAddMantissas
	JNC	FRoundUp	; No overflow, round up
	INX	HL		; Point to exponent
	INR	M		; Increment exponent
	JZ	Overflow	; Error if overflow
	CALL	FMantissaRtOnce	; Shift right once
	JMP	FRoundUp
;-----------------------------------------------------------------------------
; FSubMantissas - Subtract LHS from RHS mantissa
; Entry: HL points to FACCUM, LHS in BCDE
; Exit: Result in BCDE
;-----------------------------------------------------------------------------
FSubMantissas:
	XRA	A		; B = 0 - B
	SUB	B
	MOV	B,A
	MOV	A,M		; E = (FACCUM) - E
	SBB	E
	MOV	E,A
	INX	HL
	MOV	A,M		; D = (FACCUM+1) - D
	SBB	D
	MOV	D,A
	INX	HL
	MOV	A,M		; C = (FACCUM+2) - C
	SBB	C
	MOV	C,A
; Fall into FNormalise

;-----------------------------------------------------------------------------
; FNormalise - Normalize result and store in FACCUM
; Entry: Result mantissa in CDEB (4 bytes), carry set if need negate
; Exit: Normalized result in FACCUM
;-----------------------------------------------------------------------------
FNormalise:
	CC	FNegateInt	; Negate if carry set
FNormaliseNoNeg:
	MVI	H,0		; H = shift count
	MOV	A,C		; Check high byte of mantissa
	ORA	A
	JM	FRoundUp	; Already normalized (bit 7 set)
; Shift left until bit 7 of C is set
FNormaliseLoop:
	CPI	0E0H		; Have we shifted 32 times?
	JZ	FZero		; Result is zero
	DCR	H		; Count shifts
	MOV	A,B		; Left-shift extra mantissa byte
	ADD	A
	MOV	B,A
	CALL	FMantissaLeft	; Left-shift CDE
	MOV	A,H
	JP	FNormaliseLoop	; Loop if not done
	; Adjust exponent by shift count (H is negative)
	LXI	HL,FACCUM	; Point to exponent
	ADD	M		; Add (negative) shift count
	MOV	M,A
	JNC	FZero		; Underflow = zero
	RZ
;-----------------------------------------------------------------------------
; FRoundUp - Round up mantissa and set sign
; Entry: CDEB = mantissa (B is extra precision byte)
; Exit: Result stored in FACCUM
;-----------------------------------------------------------------------------
FRoundUp:
	MOV	A,B		; A = extra mantissa byte
	LXI	HL,FACCUM	; Point to FACCUM
	ORA	A		; If bit 7 of extra byte set
	CM	FMantissaInc	; Round up the mantissa
	; Set sign and store result
	MOV	B,M		; B = exponent
	INX	HL
	MOV	A,M		; A = FTEMP_SIGN
	ANI	80H		; Isolate sign bit
	XRA	C		; Combine with mantissa high bit
	MOV	C,A		; C = signed high mantissa
	JMP	FLoadFromBCDE	; Store result

;-----------------------------------------------------------------------------
; FMantissaLeft - Shift mantissa CDE left by one bit
; Entry: CDE = mantissa, carry contains bit to shift in
; Exit: CDE shifted left, carry = bit shifted out
;-----------------------------------------------------------------------------
FMantissaLeft:
	MOV	A,E		; Shift E left
	RAL
	MOV	E,A
	MOV	A,D		; Shift D left with carry
	RAL
	MOV	D,A
	MOV	A,C		; Shift C left with carry
	ADC	A
	MOV	C,A
	RET

;-----------------------------------------------------------------------------
; FMantissaInc - Increment mantissa CDE
; Handles overflow by setting C=80H and incrementing exponent
;-----------------------------------------------------------------------------
FMantissaInc:
	INR	E
	RNZ
	INR	D
	RNZ
	INR	C
	RNZ
	MVI	C,80H		; Mantissa overflowed, set to 1.0
	INR	M		; Increment exponent
	RNZ
Overflow:
	MVI	E,0AH		; OV error
	JMP	Error

;-----------------------------------------------------------------------------
; FAddMantissas - Add mantissa at HL to mantissa in CDE
; Entry: HL points to 3-byte mantissa, CDE = mantissa
; Exit: CDE = sum, carry set on overflow
;-----------------------------------------------------------------------------
FAddMantissas:
	MOV	A,M		; Add low bytes
	ADD	E
	MOV	E,A
	INX	HL
	MOV	A,M		; Add middle bytes with carry
	ADC	D
	MOV	D,A
	INX	HL
	MOV	A,M		; Add high bytes with carry
	ADC	C
	MOV	C,A
	RET

;-----------------------------------------------------------------------------
; FNegateInt - Negate 32-bit integer CDEB (for sign handling)
; Also complements FTEMP_SIGN
;-----------------------------------------------------------------------------
FNegateInt:
	LXI	HL,FTEMP_SIGN	; Complement sign
	MOV	A,M
	CMA
	MOV	M,A
	XRA	A		; CDEB = 0 - CDEB
	MOV	L,A
	SUB	B
	MOV	B,A
	MOV	A,L
	SBB	E
	MOV	E,A
	MOV	A,L
	SBB	D
	MOV	D,A
	MOV	A,L
	SBB	C
	MOV	C,A
	RET

;-----------------------------------------------------------------------------
; FMantissaRtMult - Shift mantissa CDE right by A places
; Entry: A = shift count, CDE = mantissa
; Exit: CDEB = shifted mantissa (B = extra precision byte)
;-----------------------------------------------------------------------------
FMantissaRtMult:
	MVI	B,0		; Initialize extra byte
	INR	A		; Adjust count
	MOV	L,A
FMantissaRtLoop:
	XRA	A
	DCR	L
	RZ			; Done
	CALL	FMantissaRtOnce
	JMP	FMantissaRtLoop

;-----------------------------------------------------------------------------
; FMantissaRtOnce - Shift mantissa CDEB right by one bit
;-----------------------------------------------------------------------------
FMantissaRtOnce:
	MOV	A,C		; Shift C right
	RAR
	MOV	C,A
	MOV	A,D		; Shift D right with carry
	RAR
	MOV	D,A
	MOV	A,E		; Shift E right with carry
	RAR
	MOV	E,A
	MOV	A,B		; Shift B right with carry
	RAR
	MOV	B,A
	RET
;-----------------------------------------------------------------------------
; FMul - Floating point multiplication: FACCUM = stack * FACCUM
; Uses shift-and-add algorithm for mantissa multiplication
;-----------------------------------------------------------------------------
	POP	BC		; Get LHS from stack
	POP	DE
FMul:	RST	5		; FTestSign - check if RHS is zero
	RZ			; Return if zero
	; Add exponents (L=0 means add)
	MVI	L,0
	CALL	FExponentAdd
	; Store LHS mantissa in self-modifying code locations
	MOV	A,C
	STA	FMulInnerLoop+13 ; High byte of LHS mantissa
	XCHG
	SHLD	FMulInnerLoop+8	; Low two bytes of LHS mantissa
	; Initialize result mantissa to 0
	LXI	BC,0
	MOV	D,B
	MOV	E,B
	; Set return address to FNormalise
	LXI	HL,FNormaliseNoNeg
	PUSH	HL
	; Push outer loop address twice (for 3 bytes of mantissa)
	LXI	HL,FMulOuterLoop
	PUSH	HL
	PUSH	HL
	LXI	HL,FACCUM+1	; Point to RHS mantissa
; Outer loop: process one byte of RHS mantissa at a time
FMulOuterLoop:
	MOV	A,M		; Get RHS mantissa byte
	INX	HL
	PUSH	HL		; Save pointer
	MVI	L,8		; 8 bits per byte
; Inner loop: shift-and-add for each bit
FMulInnerLoop:
	RAR			; Test low bit of RHS byte
	MOV	H,A		; Save remaining bits
	MOV	A,C		; A = result high byte
	JNC	FMulNoAdd	; Skip add if bit was 0
	; Add LHS mantissa to result
	PUSH	HL
	LXI	HL,0		; Self-modified: LHS low bytes
	DAD	DE
	POP	DE
	ACI	0		; Self-modified: LHS high byte
	XCHG
FMulNoAdd:
	CALL	FMantissaRtOnce+1 ; Shift result right
	DCR	L		; Count bits
	MOV	A,H		; Restore RHS byte
	JNZ	FMulInnerLoop
PopHLRet:
	POP	HL		; Restore FACCUM pointer
	RET			; Return (to outer loop or FNormalise)
;-----------------------------------------------------------------------------
; FDivByTen - Divide FACCUM by 10.0
; Used in number output to bring values into range
;-----------------------------------------------------------------------------
FDivByTen:
	CALL	FPush		; Push FACCUM to stack
	LXI	BC,8420H	; BCDE = 10.0 (exponent 84H, mantissa 20 00 00)
	LXI	DE,0
	CALL	FLoadFromBCDE	; Load 10.0 into FACCUM
	; Fall into FDiv

;-----------------------------------------------------------------------------
; FDiv - Floating point division: FACCUM = stack / FACCUM
; Uses repeated subtraction (long division) algorithm
;-----------------------------------------------------------------------------
	POP	BC		; Get LHS (dividend) from stack
	POP	DE
FDiv:	RST	5		; FTestSign - check if RHS (divisor) is zero
	JZ	DivideByZero	; Error if divide by zero
	; Subtract exponents (L=FF means subtract)
	MVI	L,0FFH
	CALL	FExponentAdd
	; Multiply FACCUM by 4 (add 2 to exponent)
	INR	M
	INR	M
	; Store RHS mantissa in self-modifying code locations
	DCX	HL
	MOV	A,M
	STA	FDivLoop+11	; High byte
	DCX	HL
	MOV	A,M
	STA	FDivLoop+7	; Middle byte
	DCX	HL
	MOV	A,M
	STA	FDivLoop+3	; Low byte
	; Initialize for long division
	MOV	B,C		; B = LHS high mantissa byte
	XCHG			; HL = LHS low mantissa
	XRA	A
	MOV	C,A		; Initialize result mantissa to 0
	MOV	D,A
	MOV	E,A
	STA	FDivLoop+18	; Initialize carry byte
; Long division loop
FDivLoop:
	PUSH	HL		; Save dividend
	PUSH	BC
	; Subtract divisor from dividend (self-modifying operands)
	MOV	A,L
	SUI	0		; Self-modified: divisor low byte
	MOV	L,A
	MOV	A,H
	SBI	0		; Self-modified: divisor middle byte
	MOV	H,A
	MOV	A,B
	SBI	0		; Self-modified: divisor high byte
	MOV	B,A
	MVI	A,0		; Self-modified: carry byte
	SBI	0
	CMC			; Complement carry for comparison
	JNC	FDivNoSubtract
	; Subtraction succeeded - keep result
	STA	FDivLoop+18	; Update carry
	POP	PSW		; Discard old values
	POP	PSW
	STC			; Set carry for quotient bit
	DB	0D2H		; JNC to skip restore (opcode only)
FDivNoSubtract:
	POP	BC		; Restore original values
	POP	HL
	; Shift quotient bit into result
	MOV	A,C
	INR	A		; Test if normalized
	DCR	A
	RAR			; Shift carry into result
	JM	FRoundUp	; Done if normalized
	RAL			; Undo the shift
	CALL	FMantissaLeft	; Shift result left
	; Shift dividend left (multiply by 2)
	DAD	HL
	MOV	A,B
	RAL
	MOV	B,A
	LDA	FDivLoop+18	; Shift carry byte
	RAL
	STA	FDivLoop+18
	; Check if dividend is zero
	MOV	A,C
	ORA	D
	ORA	E
	JNZ	FDivLoop
	; Decrement exponent and continue
	PUSH	HL
	LXI	HL,FACCUM
	DCR	M
	POP	HL
	JNZ	FDivLoop
	JMP	Overflow	; Exponent underflow
;-----------------------------------------------------------------------------
; FExponentAdd - Add or subtract exponents for FMul/FDiv
; Entry: L=0 for add (FMul), L=FF for subtract (FDiv)
;        BCDE = LHS, FACCUM = RHS
; Exit: Combined exponent stored in FACCUM, mantissas unpacked
;-----------------------------------------------------------------------------
FExponentAdd:
	MOV	A,B		; Check if LHS is zero
	ORA	A
	JZ	FExpAddZero	; Exit early if LHS is zero
	MOV	A,L		; Get add/subtract flag
	LXI	HL,FACCUM	; Point to RHS exponent
	XRA	M		; XOR with RHS exponent (complement for subtract)
	ADD	B		; Add LHS exponent
	MOV	B,A
	RAR			; Move carry to bit 7
	XRA	B		; Check for overflow
	MOV	A,B
	JP	FExpAddStore	; No overflow, continue
	; Add bias and store exponent
	ADI	80H		; Add bias
	MOV	M,A		; Store in FACCUM
	JZ	PopHLRet	; Zero = underflow, exit via PopHLRet
	; Unpack mantissas and store sign
	CALL	FUnpackMantissas
	MOV	M,A		; Store sign relationship
	DCX	HL		; Point to mantissa high byte
	RET
FExpAddStore:
	ORA	A		; Set flags
FExpAddZero:
	POP	HL		; Remove return address
	JM	Overflow	; Negative = overflow error
; Fall into FZero

;-----------------------------------------------------------------------------
; FZero - Set FACCUM to zero
;-----------------------------------------------------------------------------
FZero:	XRA	A
	STA	FACCUM		; Zero exponent = zero value
	RET
;-----------------------------------------------------------------------------
; FMulByTen - Multiply FACCUM by 10.0 (optimized)
; Uses: FACCUM * 10 = (FACCUM * 4 + FACCUM) * 2
;-----------------------------------------------------------------------------
FMulByTen:
	CALL	FCopyToBCDE	; Copy FACCUM to BCDE
	MOV	A,B		; Check if zero
	ORA	A
	RZ			; Return if zero
	ADI	2		; Multiply by 4 (add 2 to exponent)
	JC	Overflow	; Check overflow
	MOV	B,A
	CALL	FAdd		; Add to FACCUM (now FACCUM*5)
	LXI	HL,FACCUM	; Multiply by 2 (add 1 to exponent)
	INR	M
	RNZ
	JMP	Overflow

;-----------------------------------------------------------------------------
; FTestSign_tail - Continuation of RST 5 (FTestSign)
; Returns: A=0 if FACCUM=0, A=1 if positive, A=-1 if negative
;-----------------------------------------------------------------------------
FTestSign_tail:
	LDA	FACCUM+2	; Get sign byte
	CPI	2FH		; Compare to determine sign
	RAL			; Rotate sign into carry
	SBB	A		; A = -1 if negative, 0 if positive
	RNZ			; Return if non-zero (negative)
	INR	A		; Return 1 for positive
	RET

;-----------------------------------------------------------------------------
; Sgn - SGN function: returns -1, 0, or 1 based on sign of FACCUM
;-----------------------------------------------------------------------------
Sgn:	RST	5		; FTestSign
; Fall through to convert result to float

;-----------------------------------------------------------------------------
; FCharToFloat - Convert signed byte in A to floating point
; Entry: A = signed byte (-128 to 127)
; Exit: Result in FACCUM
;-----------------------------------------------------------------------------
FCharToFloat:
	MVI	B,88H		; Exponent for 8-bit integer
	LXI	DE,0		; Low mantissa bytes = 0
FCharToFloat2:
	LXI	HL,FACCUM	; Point to FACCUM
	MOV	C,A		; C = mantissa high byte
	MOV	M,B		; Store exponent
	MVI	B,0		; B = 0 (extra precision)
	INX	HL
	MVI	M,80H		; Set implicit high bit
	RAL			; Get sign bit into carry
	JMP	FNormalise	; Normalize result

;-----------------------------------------------------------------------------
; Abs - ABS function: absolute value
;-----------------------------------------------------------------------------
Abs:	RST	5		; FTestSign
	RP			; Return if positive or zero
; Fall into FNegate

;-----------------------------------------------------------------------------
; FNegate - Negate FACCUM (flip sign bit)
;-----------------------------------------------------------------------------
FNegate:
	LXI	HL,FACCUM+2	; Point to sign byte
	MOV	A,M
	XRI	80H		; Flip sign bit
	MOV	M,A
	RET

;-----------------------------------------------------------------------------
; FPush - Push FACCUM onto stack
; Preserves return address, pushes FACCUM as 2 words (BCDE format)
;-----------------------------------------------------------------------------
FPush:	XCHG			; Save DE
	LHLD	FACCUM+1	; Get low 2 bytes
	XTHL			; Swap with return address
	PUSH	HL		; Push return address
	LHLD	FACCUM+2	; Get high 2 bytes (mantissa high + exponent)
	XTHL			; Swap with return address (now on stack)
	PUSH	HL		; Push high 2 bytes
	XCHG			; Restore DE
	RET

;-----------------------------------------------------------------------------
; FLoadFromMem - Load FACCUM from memory
; Entry: HL = pointer to 4-byte float
;-----------------------------------------------------------------------------
FLoadFromMem:
	CALL	FLoadBCDEfromMem ; Load BCDE from memory
; Fall into FLoadFromBCDE

;-----------------------------------------------------------------------------
; FLoadFromBCDE - Load FACCUM from BCDE
;-----------------------------------------------------------------------------
FLoadFromBCDE:
	XCHG			; HL = low mantissa
	SHLD	FACCUM+1	; Store low mantissa
	MOV	H,B		; HL = exponent/high mantissa
	MOV	L,C
	SHLD	FACCUM+2	; Store high mantissa and exponent
	XCHG			; Restore HL
	RET

;-----------------------------------------------------------------------------
; FCopyToBCDE - Copy FACCUM to BCDE registers
;-----------------------------------------------------------------------------
FCopyToBCDE:
	LXI	HL,FACCUM+1	; Point to mantissa
FLoadBCDEfromMem:
	MOV	E,M		; E = low mantissa byte
	INX	HL
	MOV	D,M		; D = middle mantissa byte
	INX	HL
	MOV	C,M		; C = high mantissa byte (with sign)
	INX	HL
	MOV	B,M		; B = exponent
	INX	HL
	RET
;-----------------------------------------------------------------------------
; FCopyToMem - Copy FACCUM to memory location
; Entry: HL = destination pointer
;-----------------------------------------------------------------------------
FCopyToMem:
	LXI	DE,FACCUM+1	; Source = FACCUM mantissa
	MVI	B,4		; 4 bytes to copy
FCopyLoop:
	LDAX	DE
	MOV	M,A
	INX	DE
	INX	HL
	DCR	B
	JNZ	FCopyLoop
	RET

;-----------------------------------------------------------------------------
; FUnpackMantissas - Unpack mantissas for arithmetic operations
; Sets implicit high bit, determines sign relationship
; Entry: BCDE = LHS number, FACCUM = RHS number
; Exit: A = sign relationship (positive if same sign, negative if different)
;       C, FACCUM mantissas have implicit bit set
;-----------------------------------------------------------------------------
FUnpackMantissas:
	LXI	HL,FACCUM+2	; Point to RHS sign byte
	MOV	A,M		; Get RHS sign
	RLC			; Rotate sign to carry
	STC			; Set carry (implicit high bit)
	RAR			; Combine: bit 7=1, bit 6=old sign
	MOV	M,A		; Store back
	CMC			; Complement for sign extraction
	RAR			; A = sign indicator
	INX	HL		; Skip to FTEMP_SIGN
	INX	HL
	MOV	M,A		; Store sign indicator
	; Same for LHS mantissa in C
	MOV	A,C
	RLC			; Get sign to carry
	STC			; Set implicit bit
	RAR			; Bit 7 = 1, bit 6 = old sign
	MOV	C,A
	RAR			; Get sign for comparison
	XRA	M		; XOR with RHS sign
	RET			; A positive = same sign, negative = different
;-----------------------------------------------------------------------------
; FCompare - Compare BCDE with FACCUM
; Entry: BCDE = number to compare
; Exit: A = -1 if BCDE < FACCUM, 0 if equal, 1 if BCDE > FACCUM
;       Zero flag set if equal
;-----------------------------------------------------------------------------
FCompareWithBCDE:
	MOV	A,B		; Check if BCDE is zero
	ORA	A
	JZ	FTestSign	; If zero, result depends on FACCUM sign
	LXI	HL,FTestSign_tail-1 ; Return address for sign check
	PUSH	HL
	RST	5		; FTestSign - check FACCUM
	MOV	A,C		; Get BCDE sign
	RZ			; Return if FACCUM is zero
	LXI	HL,FACCUM+2	; Compare signs
	XRA	M
	MOV	A,C
	RM			; Different signs - return sign of BCDE
	CALL	FCompareBytes	; Same sign - compare magnitudes
	RAR			; Move result to low bit
	XRA	C		; Adjust for sign
	RET

; Compare bytes of BCDE with FACCUM
FCompareBytes:
	INX	HL		; Point to exponent
	MOV	A,B		; Compare exponents
	CMP	M
	RNZ
	DCX	HL		; Compare high mantissa
	MOV	A,C
	CMP	M
	RNZ
	DCX	HL		; Compare middle mantissa
	MOV	A,D
	CMP	M
	RNZ
	DCX	HL		; Compare low mantissa
	MOV	A,E
	SUB	M
	RNZ
	POP	HL		; Equal - discard return addresses
	POP	HL
	RET

;-----------------------------------------------------------------------------
; FCompare - Convert FACCUM to integer in BCDE for comparison
; Used by INT function and comparisons
;-----------------------------------------------------------------------------
FCompare:
	MOV	B,A		; Initialize BCDE to 0
	MOV	C,A
	MOV	D,A
	MOV	E,A
	ORA	A
	RZ			; Return if FACCUM is zero
	PUSH	HL
	CALL	FCopyToBCDE	; Copy FACCUM to BCDE
	CALL	FUnpackMantissas ; Unpack mantissa
	XRA	M		; Get sign relationship
	MOV	H,A
	CM	FCompareNeg	; Negate if needed
	MVI	A,98H		; 24-bit integer exponent
	SUB	B		; Calculate shift count
	CALL	FMantissaRtMult	; Shift to integer
	MOV	A,H
	RAL			; Check sign
	CC	FMantissaInc	; Round up if needed
	MVI	B,0
	CC	FNegateInt	; Negate if negative
	POP	HL
	RET

FCompareNeg:
	DCX	DE		; Decrement for negate
	MOV	A,D
	ANA	E
	INR	A
	RNZ
	DCX	BC
	RET

;-----------------------------------------------------------------------------
; Int - INT function: truncate to integer
;-----------------------------------------------------------------------------
Int:	LXI	HL,FACCUM	; Point to exponent
	MOV	A,M
	CPI	98H		; Check if already integer
	RNC			; Return if exponent >= 24 bits
	CALL	FCompare	; Convert to integer in BCDE
	MVI	M,98H		; Set exponent for integer
	MOV	A,C		; Get sign
	RAL			; Rotate sign to carry
	JMP	FNormalise	; Normalize result
;-----------------------------------------------------------------------------
; FIn - Read ASCII string and convert to floating point in FACCUM
; Input: HL points to before the number string
; Variables used:
;   B = count of fractional digits (after decimal point)
;   C = decimal point flag (0xFF = not seen, 0x00 = seen)
;   D = exponent sign (0xFF = negative, 0x01 = positive)
;   E = exponent value
;-----------------------------------------------------------------------------
FInInit:
	DCX	HL		; Point to just before number
	CALL	FZero		; Clear FACCUM
	MOV	B,A		; B = 0 (fractional digit count)
	MOV	D,A		; D = 0 (exponent sign)
	MOV	E,A		; E = 0 (exponent value)
	CMA			; A = 0xFF
	MOV	C,A		; C = 0xFF (no decimal point yet)
; Main parsing loop - process one character at a time
FInCharLoop:
	RST	2		; NextChar - get next character
	JC	FInDigit	; If digit, process it
	CPI	2EH		; Decimal point?
	JZ	FInDecPt	; Yes, mark decimal point seen
	CPI	45H		; 'E' for exponent?
	JNZ	FInScale	; No, done parsing - scale result
	; Process exponent after 'E'
	RST	2		; NextChar - get sign or first digit
	DCR	D		; Assume negative (D = -1)
	CPI	99H		; Minus token?
	JZ	FInExpDigit	; Yes, keep D = -1
	INR	D		; No, restore D = 0
	CPI	98H		; Plus token?
	JZ	FInExpDigit	; Yes, D = 0 (positive)
	DCX	HL		; Back up to re-read char
FInExpDigit:
	RST	2		; NextChar - get exponent digit
	JC	FInExpAccum	; If digit, accumulate exponent
	INR	D		; D was -1? (negative exponent)
	JNZ	FInScale	; No, done with exponent
	; Negate exponent for negative
	XRA	A
	SUB	E		; E = -E
	MOV	E,A
	INR	C		; Reset C (was 0xFF)
FInDecPt:
	INR	C		; Mark decimal point seen (C = 0)
	JZ	FInCharLoop	; Continue if first decimal point
; Scale the result by 10^(E-B) where E=exponent, B=fractional digits
FInScale:
	PUSH	HL		; Save program pointer
	MOV	A,E		; A = exponent
	SUB	B		; A = exponent - fractional digits
FInScaleLoop:
	CP	FInMulTen	; If positive, multiply by 10
	JP	FInScaleEnd	; Check if done
	; Negative - divide by 10
	PUSH	PSW
	CALL	FDivByTen
	POP	PSW
	INR	A		; Move toward zero
FInScaleEnd:
	JNZ	FInScaleLoop	; Continue until A = 0
	POP	HL		; Restore program pointer
	RET
; Multiply by 10 helper (for positive scaling)
FInMulTen:
	RZ			; Return if A = 0
	PUSH	PSW
	CALL	FMulByTen
	POP	PSW
	DCR	A		; Move toward zero
	RET
; Process a digit: multiply current value by 10, add digit
FInDigit:
	PUSH	DE		; Save exponent info
	MOV	D,A		; D = digit character
	MOV	A,B		; Update fractional count
	ADC	C		; Add with carry (C = 0 after decimal)
	MOV	B,A
	PUSH	BC		; Save BC
	PUSH	HL		; Save program pointer
	PUSH	DE		; Save digit
	CALL	FMulByTen	; FACCUM *= 10
	POP	PSW		; Get digit back in A
	SUI	30H		; Convert ASCII to value
	CALL	FPush		; Save current FACCUM
	CALL	FCharToFloat	; Convert digit to float
	POP	BC		; Get old FACCUM
	POP	DE
	CALL	FAdd		; Add digit to total
	POP	HL		; Restore program pointer
	POP	BC		; Restore BC
	POP	DE		; Restore exponent info
	JMP	FInCharLoop	; Continue parsing
; Accumulate exponent digit: E = E*10 + digit
FInExpAccum:
	MOV	A,E		; A = current exponent
	RLC			; A = E*2
	RLC			; A = E*4
	ADD	E		; A = E*5
	RLC			; A = E*10
	ADD	M		; Add digit character
	SUI	30H		; Convert from ASCII
	MOV	E,A		; Store back
	JMP	FInExpDigit	; Continue reading exponent
;-----------------------------------------------------------------------------
; PrintIN - Print " IN " followed by line number (for error messages)
;-----------------------------------------------------------------------------
PrintIN:
	PUSH	HL
	LXI	HL,szIn		; " IN " string
	CALL	PrintString
	POP	HL
;-----------------------------------------------------------------------------
; PrintInt - Print integer in HL (converts to float and prints)
; The integer occupies the lower 16 bits of mantissa with exponent=24
;-----------------------------------------------------------------------------
PrintInt:
	XCHG			; DE = integer value
	XRA	A		; C = 0
	MVI	B,98H		; B = exponent 24 (2^24)
	CALL	FCharToFloat+5	; Convert to float (skip sign handling)
	LXI	HL,PrintString	; Return to PrintString after FOut
	PUSH	HL
;-----------------------------------------------------------------------------
; FOut - Float Output: Convert FACCUM to ASCII string in FBUFFER
; Output string is then printed by returning to PrintString
;-----------------------------------------------------------------------------
FOutStart:
	LXI	HL,FBUFFER	; Output buffer
	PUSH	HL
	RST	5		; FTestSign - check FACCUM sign
	MVI	M,20H		; Assume positive: leading space
	JP	FOutSetZero	; If positive, skip
	MVI	M,2DH		; Negative: leading '-'
FOutSetZero:
	INX	HL
	MVI	M,30H		; Write '0' (for zero case)
	JZ	FOut_tail	; If zero, done (just " 0")
	; Make FACCUM positive for processing
	PUSH	HL		; Save buffer position
	CM	FNegate		; Negate if negative
	XRA	A		; Initialize decimal exponent adjustment = 0
	PUSH	PSW
	CALL	FOutUnder1M	; Ensure FACCUM < 1,000,000
; Loop to bring FACCUM >= 100,000
FOutOver100K:
	LXI	BC,9143H	; BCDE = 100000.0
	LXI	DE,4FF8H
	CALL	FCompareWithBCDE
	JPO	FOutPrepare	; If FACCUM >= 100000, continue
	POP	PSW		; Get decimal exponent adjustment
	CALL	FInMulTen	; Multiply by 10, decrement adjustment
	PUSH	PSW
	JMP	FOutOver100K
; Divide by 10 and increment exponent adjustment
FOutDiv10:
	CALL	FDivByTen
	POP	PSW
	INR	A		; Increment decimal exponent
	PUSH	PSW
	CALL	FOutUnder1M	; Check if under 1M again
; FACCUM is now between 100,000 and 1,000,000
; Add 0.5 for rounding and convert to integer
FOutPrepare:
	CALL	FAddMem		; Add 0.5 (ONE_HALF)
	INR	A
	CALL	FCompare	; Convert to integer in CDE
	CALL	FLoadFromBCDE	; Store integer back to FACCUM
	; Determine output format (scientific or normal)
	LXI	BC,0206H	; B=2, C=6 (6 digits)
	POP	PSW		; A = decimal exponent adjustment
	ADD	C		; A = adjustment + 6
	JM	FOutUseExp	; If A < 0, use scientific
	CPI	07H
	JNC	FOutUseExp	; If A >= 7, use scientific
	INR	A		; Use normal format
	MOV	B,A		; B = decimal point position
	MVI	A,01H		; A=1 means no exponent output
FOutUseExp:
	DCR	A
	POP	HL		; HL = output buffer
	PUSH	PSW		; Save exponent flag
	LXI	DE,DECIMAL_POWERS ; Table of 100000, 10000, 1000...
; Output each digit by repeated subtraction
FOutDigitLoop:
	DCR	B		; Decrement decimal point counter
	MVI	M,2EH		; Write '.' (may be overwritten)
	CZ	IncHL		; If B=0, actually keep the '.'
	PUSH	BC
	PUSH	HL
	PUSH	DE
	CALL	FCopyToBCDE	; Get FACCUM to BCDE
	POP	HL		; HL points to power of 10 table
	MVI	B,2FH		; B = '0' - 1
; Subtract power of 10 until underflow
FOutSubLoop:
	INR	B		; Increment digit
	MOV	A,E		; Subtract 3-byte power from CDE
	SUB	M
	MOV	E,A
	INX	HL
	MOV	A,D
	SBB	M
	MOV	D,A
	INX	HL
	MOV	A,C
	SBB	M
	MOV	C,A
	DCX	HL
	DCX	HL
	JNC	FOutSubLoop	; Continue until underflow
	CALL	FNormalise	; Add back (undo last subtraction)
	INX	HL		; Move to next power
	CALL	FLoadFromBCDE	; Store result back
	XCHG			; DE = power table ptr
	POP	HL		; HL = output buffer
	MOV	M,B		; Store digit
	INX	HL
	POP	BC
	DCR	C		; More digits?
	JNZ	FOutDigitLoop	; Yes, continue
	; Strip trailing zeros
	DCR	B
	JZ	FOutExpPart	; Skip if no trailing zeros
FOutStripZeros:
	DCX	HL
	MOV	A,M
	CPI	30H		; '0'?
	JZ	FOutStripZeros	; Strip it
	CPI	2EH		; Decimal point?
	CNZ	IncHL		; If not '.', keep this char
FOutExpPart:
	POP	PSW		; Get exponent flag
	JZ	FOutNullTerm	; If 0, no exponent needed
	; Write scientific notation exponent
	MVI	M,45H		; 'E'
	INX	HL
	MVI	M,2BH		; Assume '+'
	JP	FOutExpDigits	; If positive exponent
	MVI	M,2DH		; Negative: '-'
	CMA			; Negate exponent
	INR	A
FOutExpDigits:
	MVI	B,2FH		; B = '0' - 1
FOutExpLoop:
	INR	B		; Count tens digit
	SUI	0AH
	JNC	FOutExpLoop
	ADI	3AH		; A = ones digit + '0'
	INX	HL
	MOV	M,B		; Store tens digit
FOut_tail:
	INX	HL
	MOV	M,A		; Store ones digit
	INX	HL
FOutNullTerm:
	MOV	M,C		; Null terminator (C=0)
	POP	HL		; Return buffer pointer
	RET
;-----------------------------------------------------------------------------
; FOutUnder1M - Ensure FACCUM < 1,000,000 by dividing by 10
;-----------------------------------------------------------------------------
FOutUnder1M:
	LXI	BC,9474H	; BCDE = 1000000.0
	LXI	DE,23F7H
	CALL	FCompareWithBCDE
	POP	HL		; Get return address
	JPO	FOutDiv10	; If >= 1M, divide by 10
	PCHL			; Otherwise return normally
;-----------------------------------------------------------------------------
; Floating Point Constants
;-----------------------------------------------------------------------------
ONE_HALF:
	DB	00H,00H,00H,80H	; 0.5 (mantissa 00 00 00, exp 80)
; Table of powers of 10 as 24-bit integers (for digit extraction)
DECIMAL_POWERS:
	DB	0A0H,86H,01H	; 100000
	DB	10H,27H,00H	; 10000
	DB	0E8H,03H,00H	; 1000
	DB	64H,00H,00H	; 100
	DB	0AH,00H,00H	; 10
	DB	01H,00H,00H	; 1
;-----------------------------------------------------------------------------
; SQR - Square Root (Optional Function #1)
; Uses Newton's method: x[n+1] = (x[n] + N/x[n]) / 2
; Iterates 4 times for convergence
;-----------------------------------------------------------------------------
Sqr:	RST	5		; FTestSign - check argument
	JM	FunctionCallError ; Negative: FC error
	RZ			; Zero: return zero
	; Extract exponent/2 for later (sqrt scales exponent by half)
	LXI	HL,FACCUM_EXP	; Point to exponent
	MOV	A,M		; Get exponent
	RAR			; Divide by 2 (into carry too)
	PUSH	PSW		; Save exponent/2 + carry
	PUSH	HL		; Save exponent pointer
	; Set exponent to 0x80 or 0x81 (normalize to ~1.0)
	MVI	A,40H		; Base 0x40
	RAL			; Add carry from above
	MOV	M,A		; Set new exponent
	; Copy FACCUM to FBUFFER as initial guess
	LXI	HL,FBUFFER
	CALL	FCopyToMem
	; Newton's method: 4 iterations
	MVI	A,04H		; Iteration count
SqrLoop:
	PUSH	PSW		; Save count
	CALL	FPush		; Push current estimate
	LXI	HL,FBUFFER	; Original value
	CALL	FLoadBCDEfromMem
	CALL	FMul		; FACCUM = estimate * original
	POP	BC		; Get pushed estimate
	POP	DE
	CALL	FAdd		; FACCUM = estimate + original/estimate
	; Multiply by 0.5 (divide by 2)
	LXI	BC,8000H	; BCDE = 0.5
	MOV	D,C
	MOV	E,C
	CALL	FMul+2		; FACCUM = (estimate + N/estimate) / 2
	POP	PSW		; Get iteration count
	DCR	A
	JNZ	SqrLoop		; Continue if not done
	; Restore exponent correction
	POP	HL		; HL = exponent pointer
	POP	PSW		; A = original exponent/2
	ADI	0C0H		; Adjust for bias (0x80 - 0x40)
	ADD	M		; Add to computed exponent
	MOV	M,A		; Store final exponent
	RET
;-----------------------------------------------------------------------------
; RND - Random Number Generator (Optional Function #2)
; Uses linear congruential generator: seed = seed * 11879546 + offset
; Returns random number 0 <= x < 1
; If argument is negative, reseeds from argument
;-----------------------------------------------------------------------------
Rnd:	RST	5		; FTestSign - check argument
	LXI	HL,RND_SEED	; Point to current seed
	CALL	FLoadFromMem	; Load seed to FACCUM
	RZ			; If zero, return zero
	; Linear congruential: seed * 11879546
	LXI	BC,9835H	; Multiplier constant
	LXI	DE,447AH
	CALL	FMul+2
	; Add small constant
	LXI	BC,6828H	; Addend constant
	LXI	DE,0B146H
	CALL	FAdd
	; Scramble mantissa bytes and normalize to 0-1 range
	CALL	FCopyToBCDE	; Get result to BCDE
	MOV	A,E		; Swap low and high mantissa bytes
	MOV	E,C
	MOV	C,A
	MVI	M,80H		; Set FTEMP_SIGN = positive
	DCX	HL
	MOV	B,M		; Save exponent
	MVI	M,80H		; Set exponent = 0 (value < 1)
	CALL	FNormalise+3	; Normalize result
	; Save new seed and return
	LXI	HL,RND_SEED
	JMP	FCopyToMem	; Store new seed and return
RND_SEED:
	DB	52H,0C7H,4FH,80H ; Initial seed: 0.811635
;-----------------------------------------------------------------------------
; SIN - Sine Function (Optional Function #3)
; Uses Taylor series approximation after reducing angle to -0.25 to 0.25
; Input: angle in radians in FACCUM
;-----------------------------------------------------------------------------
Sin:	CALL	FPush		; Push x (radians)
	; Scale to turns: u = x / (2*pi)
	LXI	BC,8349H	; BCDE = 2*pi = 6.283185
	LXI	DE,0FDBH
	CALL	FLoadFromBCDE	; Load 2*pi
	POP	BC		; Get x
	POP	DE
	CALL	FMul		; u = x / 2pi (actually wrong - should be FDiv)
	; Get fractional part: u = u - INT(u)
	CALL	FPush		; Push u
	CALL	Int		; INT(u)
	POP	BC		; Get u
	POP	DE
	CALL	FSub		; u = u - INT(u), now -1 < u < 1
	; Reduce to quadrant: subtract 0.25
	LXI	BC,7F00H	; BCDE = 0.25
	MOV	D,C
	MOV	E,C
	CALL	FSub		; u = u - 0.25
	; Check sign for quadrant adjustment
	RST	5		; FTestSign
	STC			; Set carry (no negate needed)
	JP	SinQuadrant	; If positive, continue
	; Negative: add 0.5 and check again
	CALL	FAddMem		; Add ONE_HALF
	RST	5		; FTestSign again
	ORA	A		; Clear carry (negate needed)
SinQuadrant:
	PUSH	PSW		; Save carry (negate flag)
	CP	FNegate		; If positive, negate
	; Add 0.25 back
	LXI	BC,7F00H	; BCDE = 0.25
	MOV	D,C
	MOV	E,C
	CALL	FAdd		; Adjust quadrant
	POP	PSW
	CNC	FNegate		; Final sign adjustment
	; Now compute Taylor series for sine
	; sin(q)  q * (c0 + q * (c1 + q * (c2 + q * (c3 + q * c4))))
	CALL	FPush		; Push q
	CALL	FCopyToBCDE	; Get q to BCDE
	CALL	FMul+2		; q = q * q
	CALL	FPush		; Push q
	LXI	HL,SIN_COEFFS	; Taylor coefficients table
	CALL	FLoadFromMem	; Load first coefficient
	POP	BC		; Get q
	POP	DE
	MVI	A,04H		; 4 iterations
SinTaylorLoop:
	PUSH	PSW		; Save count
	PUSH	DE		; Push q
	PUSH	BC
	PUSH	HL		; Save coefficient pointer
	CALL	FMul+2		; acc = acc * q
	POP	HL		; Get coefficient pointer
	CALL	FLoadBCDEfromMem ; Load next coefficient
	PUSH	HL		; Save updated pointer
	CALL	FAdd		; acc = acc * q + coeff
	POP	HL		; Restore pointer
	POP	BC		; Get q
	POP	DE
	POP	PSW		; Get count
	DCR	A
	JNZ	SinTaylorLoop	; Continue if not done
	JMP	FMul		; Final multiply by q and return
;-----------------------------------------------------------------------------
; Taylor series coefficients for sine
; These approximate: sin(pi*x) / (pi*x) for small x
;-----------------------------------------------------------------------------
SIN_COEFFS:
	DB	0BAH,0D7H,1EH,86H ; 39.710670
	DB	64H,26H,99H,87H	  ; -76.574982
	DB	58H,34H,23H,87H	  ; 81.602234
	DB	0E0H,5DH,0A5H,86H ; -41.341675
	DB	0DAH,0FH,49H,83H  ; 6.283185 (2*pi)
	DB	00H,00H		  ; End marker
;=============================================================================
; INITIALIZATION CODE (Part 1 - I/O Detection)
; This code runs once at cold start to detect terminal hardware
; and configure I/O ports. Memory is reclaimed after initialization.
;=============================================================================
DetectIO:
	IN	0FFH		; Read sense switches
	ANI	0F0H		; Mask upper nibble
	RRC			; Shift to get device type
	RRC
	CPI	3CH		; Check for specific device
	RZ			; Return if match
	CPI	38H		; Check for alternate device
	STC			; Set carry
	JNZ	IOConfigTable	; Not found, use config table
	; Read device-specific configuration
	LXI	HL,0FFFH	; Top of memory
	MOV	C,M		; Get config byte
	DCX	HL
	MOV	A,M		; Get another config byte
	ANI	0F0H
	RRC
	RRC
IOConfigTable:
	PUSH	PSW
	MOV	L,A		; Index into config table
	MVI	H,00H
	LXI	DE,IO_CONFIG_TABLE
	DAD	DE		; HL = table entry
	MOV	A,M		; Load configuration values
	INX	HL
	MOV	D,M
	INX	HL
	MOV	B,M
	INX	HL
	MOV	E,M
	MOV	H,A
	POP	PSW
	PUSH	PSW
	MOV	A,H
	JC	StoreIOConfig
	MOV	A,C
StoreIOConfig:
	STA	0DA0H		; Store I/O port
	POP	PSW
	LXI	HL,DoOptionalFns ; Return address after I/O config
	PUSH	HL
	MVI	C,0FFH
	CPI	10H
	LXI	HL,Start
	SHLD	D038F		; Store jump address
	JZ	IOConfigAlt
	CPI	08H
	RNC			; Return if device type >= 8
	ADI	11H
	PUSH	PSW
	MVI	A,03H
	CALL	IOPortOut
	POP	PSW
	JMP	IOPortOut
IOConfigAlt:
	XRA	A
	CALL	IOPortOut
	CALL	IOPortInc
	CALL	IOPortInc
	CMA
	MVI	C,01H
	CALL	IOPortInc
	PUSH	HL
	LHLD	IOPortOut
	MVI	L,0DBH
	SHLD	D038F
	POP	HL
	MVI	A,2CH
	DCR	M
	CALL	IOPortOut
	DCR	M
	DCR	M
	DCR	M
IOPortInc:
	LXI	HL,0DA0H
	INR	M
IOPortOut:
	OUT	10H		; Output to I/O port
	RET
;-----------------------------------------------------------------------------
; I/O Configuration Table
; Contains device-specific parameters for different terminal types
;-----------------------------------------------------------------------------
IO_CONFIG_TABLE:
	DB	10H,0CAH,01H,02H ; Device 0 config
	DB	10H,0CAH,01H,02H ; Device 1 config
	DB	00H,0C2H,01H,80H ; Device 2 config
	DB	06H,0C2H,01H,80H ; Device 3 config
	DB	20H,0CAH,80H,80H ; Device 4 config
	DB	04H,0CAH,02H,01H ; Device 5 config
	DB	24H,0CAH	 ; Device 6 config (partial)
	DB	40H,40H		 ; More config data
;-----------------------------------------------------------------------------
; ConfigIO - Configure I/O code with detected hardware settings
; Called after DetectIO to set up I/O port addresses in the code
;-----------------------------------------------------------------------------
ConfigIO:
	MOV	H,D		; Get detected I/O parameters
	MOV	L,B
	SHLD	0396H		; Patch InputChar device-ready check
	MOV	A,H
	ANI	0C8H		; Mask for TestBreakKey
	MOV	H,A
	SHLD	0484H		; Patch TestBreakKey
	XCHG
	SHLD	D0387		; Patch output port address
	LDA	0DA0H		; Get input port number
	STA	0394H		; Patch InputChar port
	STA	0482H		; Patch TestBreakKey port
	INR	A
	STA	039BH		; Patch another I/O reference
	ADD	C
	STA	D0385		; Store print buffer offset
	INR	A
	STA	D038D		; Store another buffer offset
	RET

	DB	0, 0		; Padding/unused

;=============================================================================
; Init - Initialization Code
; This code runs once at startup, asks user for memory size and terminal
; width, then initializes BASIC and prints "XXXX BYTES FREE"
; This memory is reclaimed for program storage after init completes.
;=============================================================================
Init:	LXI	HL,0F40H	; Default top of memory (3904 bytes)
	SPHL			; Set stack pointer
	SHLD	STACK_TOP	; Save stack top
	CALL	DetectIO	; Detect and configure I/O hardware
	LXI	HL,0FFFFH	; Current line = -1 (direct mode)
	SHLD	CURRENT_LINE
	CALL	OutputNewline	; Print newline
; Ask user for memory size
AskMemorySize:
	LXI	HL,szMemorySize	; "MEMORY SIZE"
	CALL	PrintStr
	CALL	InputLine	; Get user input
	JC	AskMemorySize	; Retry on error
	RST	2		; NextChar
	ORA	A		; Empty input?
	JNZ	ParseMemorySize	; No, parse the number
	; Auto-detect memory size
	LXI	HL,0EFAH	; Start just above init code
AutoDetectMem:
	INX	HL		; Check next byte
	MOV	A,H		; Check for wrap to 0000
	ORA	L
	JZ	GotMemoryTop	; Wrapped, use previous address
	MOV	A,M		; Read memory
	CMA			; Complement
	MOV	M,A		; Write back
	CMP	M		; Did it stick?
	JZ	AutoDetectMem	; Yes, continue
	JMP	GotMemoryTop	; No, found top of RAM
ParseMemorySize:
	LXI	HL,LINE_BUFFER	; Parse number from input
	CALL	LineNumberFromStr
	MOV	A,M		; Check for trailing garbage
	ORA	A
	JNZ	SyntaxError
	XCHG			; HL = memory size
GotMemoryTop:
	DCX	HL		; HL = last usable address (top-1)
	PUSH	HL		; Save memory top on stack
;-----------------------------------------------------------------------
; Ask user for terminal width (default 72 if empty)
;-----------------------------------------------------------------------
AskTerminalWidth:
	LXI	HL,szTerminalWidth
	CALL	PrintString
	CALL	InputLineWithQ	; Get input with "?" prompt
	JC	AskTerminalWidth ; On break, ask again
	RST	2		; NextChar - get first char
	ORA	A		; Empty input?
	MVI	A,48H		; Default width = 72 (0x48)
	MOV	E,A		; Save default in E
	JZ	SetTermWidth	; If empty, use default
	CALL	LineNumberFromStr ; Parse width from input
	MOV	A,E		; Get parsed width
	CPI	0FH		; Minimum width = 15
	JC	AskTerminalWidth ; Too small, ask again
SetTermWidth:
	STA	TERMINAL_WIDTH	; Store terminal width
;-----------------------------------------------------------------------
; Calculate last tab stop position
; Tab stops are every 14 characters. Calculate: width - (width % 14)
;-----------------------------------------------------------------------
CalcTabStop:
	SUI	0EH		; Subtract 14
	JNC	CalcTabStop	; Loop until negative
	ADI	1CH		; Add 28 (14*2) to restore + offset
	CMA			; Negate to get -remainder
	INR	A
	ADD	E		; Add to width: last_tab = width - (width % 14)
	STA	05C5H		; Store last tab position
;-----------------------------------------------------------------------
; Optional function configuration (SIN, RND, SQR)
; User can disable functions to reclaim memory for program storage.
; Each function descriptor contains: base addr, prompt string, jump table entry
;-----------------------------------------------------------------------
AskOptionalFns:
	LXI	HL,OPT_FN_DESCS	; Point to function descriptors
OptFnLoop:
	RST	6		; PushNextWord - push program base for this fn
	LXI	DE,szSIN	; End marker (first string after descriptors)
	RST	4		; CompareHLDE - past end of table?
	JZ	OptFnDone	; Yes, done with optional functions
	RST	6		; PushNextWord - get prompt string address
	XTHL			; HL = prompt string, stack has descriptor ptr
	CALL	PrintString	; Print "WANT xxx"
	CALL	InputLineWithQ	; Get Y/N response
	RST	2		; NextChar - get first char of response
	POP	HL		; Restore descriptor pointer
	CPI	59H		; 'Y' - want this function?
OptFnDone:
	POP	DE		; Get program base address
	JZ	InitComplete	; Yes or end of table, keep function
	CPI	4EH		; 'N' - don't want this function?
	JNZ	AskOptionalFns	; Invalid response, start over
	; User said No - disable the function
	RST	6		; PushNextWord - get jump table entry address
	XTHL			; HL = jump table entry, stack has descriptor ptr
	LXI	DE,FunctionCallError ; Error handler address
	MOV	M,E		; Patch jump table to point to error
	INX	HL
	MOV	M,D
	POP	HL		; Restore descriptor pointer
	JMP	OptFnLoop	; Process next function
;-----------------------------------------------------------------------
; Initialization complete - set up program base and memory
;-----------------------------------------------------------------------
InitComplete:
	XCHG			; HL = program base address (from DE)
	MVI	M,00H		; Write null byte at program base
	INX	HL
	SHLD	PROGRAM_BASE	; Store program base address
	XTHL			; HL = memory top, push program base
	LXI	DE,0F40H	; Minimum memory required
	RST	4		; CompareHLDE - enough memory?
	JC	OutOfMemory	; No, error
	POP	DE		; DE = program base
	SPHL			; Set stack pointer to memory top
	SHLD	STACK_TOP	; Save stack top
	XCHG			; HL = program base, DE = stack top
	CALL	CheckEnoughMem	; Verify enough space between them
	; Calculate free bytes: (stack_top - program_base) - 16
	MOV	A,E		; DE still has stack top
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A		; HL = stack_top - program_base
	LXI	BC,0FFF0H	; -16 for overhead
	DAD	BC		; HL = free bytes
	CALL	PrintInt	; Print free byte count
	LXI	HL,szByteFree	; " BYTES FREE" message
	CALL	PrintString
	; Patch startup code for subsequent runs
	LXI	HL,PrintString	; After first run, Main should call
	SHLD	0205H		;   PrintString instead of restart code
	CALL	Run		; Initialize variables (NEW without msg)
	; Redirect cold start to warm start
	LXI	HL,Main		; Future starts go to Main
	SHLD	0002H		;   instead of Init
	PCHL			; Jump to Main
;-----------------------------------------------------------------------
; Optional Function Descriptors
; Each entry: program_base (DW), prompt_string (DW), jump_table_entry (DW)
; If user says Yes, program_base becomes the start of user program storage
; If No, the jump_table_entry is patched to point to FunctionCallError
;-----------------------------------------------------------------------
OPT_FN_DESCS:
	; SIN function descriptor
	DW	0D22H		; Program base if SIN enabled
	DW	szSIN		; Prompt string "SIN"
	DW	004FH		; Jump table entry for SIN
	; RND function descriptor
	DW	0CA0H		; Program base if RND enabled (SIN disabled)
	DW	szRND		; Prompt string "RND"
	DW	004DH		; Jump table entry for RND
	; SQR function descriptor
	DW	0C6DH		; Program base if SQR enabled (SIN,RND disabled)
	DW	szSQR		; Prompt string "SQR"
	DW	004BH		; Jump table entry for SQR
	; End marker / minimum program base
	DW	0C2FH		; Program base if all optional fns disabled
;-----------------------------------------------------------------------
; Initialization String Constants
;-----------------------------------------------------------------------
szSIN:	DB	'SIN',0		; Optional function prompts
szRND:	DB	'RND',0
szSQR:	DB	'SQR',0
szTerminalWidth:
	DB	'TERMINAL WIDTH',0
szMemorySize:
	DB	'MEMORY SIZE',0

	END